{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/mux.js/lib/utils/stream.js","webpack:///./node_modules/mux.js/lib/m2ts/stream-types.js","webpack:///./node_modules/mux.js/lib/codecs/adts.js","webpack:///./node_modules/mux.js/lib/codecs/h264.js","webpack:///./node_modules/mux.js/lib/mp4/probe.js","webpack:///./node_modules/mux.js/lib/mp4/transmuxer.js","webpack:///./node_modules/mux.js/lib/m2ts/m2ts.js","webpack:///./node_modules/mux.js/lib/aac/utils.js","webpack:///./node_modules/mux.js/lib/flv/flv-tag.js","webpack:///./node_modules/superagent/lib/is-object.js","webpack:///./node_modules/route-parser/lib/route/nodes.js","webpack:///./node_modules/route-parser/lib/route/visitors/create_visitor.js","webpack:///./node_modules/mux.js/lib/mp4/mp4-generator.js","webpack:///./node_modules/mux.js/lib/m2ts/caption-stream.js","webpack:///./node_modules/mux.js/lib/tools/caption-packet-parser.js","webpack:///./node_modules/mux.js/lib/m2ts/timestamp-rollover-stream.js","webpack:///./node_modules/mux.js/lib/tools/mp4-inspector.js","webpack:///./node_modules/superagent/lib/client.js","webpack:///./node_modules/component-emitter/index.js","webpack:///./node_modules/superagent/lib/request-base.js","webpack:///./node_modules/superagent/lib/response-base.js","webpack:///./node_modules/superagent/lib/utils.js","webpack:///./node_modules/superagent/lib/agent-base.js","webpack:///./node_modules/route-parser/index.js","webpack:///./node_modules/route-parser/lib/route.js","webpack:///./node_modules/route-parser/lib/route/parser.js","webpack:///./node_modules/route-parser/lib/route/compiled-grammar.js","webpack:///./node_modules/route-parser/lib/route/visitors/regexp.js","webpack:///./node_modules/route-parser/lib/route/visitors/reverse.js","webpack:///./src/client/index.js","webpack:///./node_modules/events/events.js","webpack:///./node_modules/isomorphic-ws/browser.js","webpack:///(webpack)/buildin/global.js","webpack:///./node_modules/mux.js/lib/index.js","webpack:///./node_modules/mux.js/lib/codecs/index.js","webpack:///./node_modules/mux.js/lib/utils/exp-golomb.js","webpack:///./node_modules/mux.js/lib/mp4/index.js","webpack:///./node_modules/mux.js/lib/utils/bin.js","webpack:///./node_modules/mux.js/lib/mp4/frame-utils.js","webpack:///./node_modules/mux.js/lib/mp4/audio-frame-utils.js","webpack:///./node_modules/mux.js/lib/data/silence.js","webpack:///./node_modules/mux.js/lib/utils/clock.js","webpack:///./node_modules/mux.js/lib/mp4/track-decode-info.js","webpack:///./node_modules/mux.js/lib/m2ts/metadata-stream.js","webpack:///./node_modules/mux.js/lib/aac/index.js","webpack:///./node_modules/mux.js/lib/mp4/caption-parser.js","webpack:///./node_modules/mux.js/lib/flv/index.js","webpack:///./node_modules/mux.js/lib/flv/transmuxer.js","webpack:///./node_modules/mux.js/lib/flv/coalesce-stream.js","webpack:///./node_modules/mux.js/lib/flv/tag-list.js","webpack:///./node_modules/mux.js/lib/flv/flv-header.js","webpack:///./node_modules/mux.js/lib/m2ts/index.js","webpack:///./node_modules/mux.js/lib/tools/flv-inspector.js","webpack:///./node_modules/mux.js/lib/tools/ts-inspector.js","webpack:///./node_modules/mux.js/lib/m2ts/probe.js","webpack:///./node_modules/flatted/esm/index.js","webpack:///./src/static/player/logger.js","webpack:///./src/static/player/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Stream","this","init","listeners","on","type","listener","concat","off","index","indexOf","slice","splice","trigger","callbacks","length","args","arguments","push","apply","dispose","pipe","destination","data","flushSource","flush","H264_STREAM_TYPE","ADTS_STREAM_TYPE","METADATA_STREAM_TYPE","AdtsStream","ADTS_SAMPLING_FREQUENCIES","buffer","packet","frameLength","protectionSkipBytes","frameEnd","oldBuffer","sampleCount","adtsFrameDuration","frameNum","Uint8Array","byteLength","set","pts","dts","audioobjecttype","channelcount","samplerate","samplingfrequencyindex","samplesize","subarray","undefined","H264Stream","NalByteStream","PROFILES_WITH_OPTIONAL_SPS_DATA","ExpGolomb","syncPoint","swapBuffer","100","110","122","244","44","83","86","118","128","138","139","134","self","trackId","currentPts","currentDts","discardEmulationPreventionBytes","readSequenceParameterSet","skipScalingList","nalByteStream","event","nalUnitType","escapedRBSP","config","count","expGolombDecoder","j","lastScale","nextScale","readExpGolomb","newLength","newData","emulationPreventionBytesPositions","sourceIndex","shift","profileIdc","levelIdc","profileCompatibility","chromaFormatIdc","picOrderCntType","numRefFramesInPicOrderCntCycle","picWidthInMbsMinus1","picHeightInMapUnitsMinus1","frameMbsOnlyFlag","scalingListCount","sarRatio","frameCropLeftOffset","frameCropRightOffset","frameCropTopOffset","frameCropBottomOffset","sarScale","readUnsignedByte","skipUnsignedExpGolomb","readUnsignedExpGolomb","skipBits","readBoolean","skipExpGolomb","readBits","width","Math","ceil","height","findBox","parseType","timescale","startTime","getVideoTrackIds","toUnsigned","path","size","end","subresults","results","result","String","fromCharCode","reduce","trak","tkhd","version","id","mdhd","fragment","trafs","baseTimes","map","traf","tfhd","scale","tfdt","pow","Infinity","min","isFinite","traks","videoTrackIds","forEach","hdlrs","tkhds","hdlr","view","handlerType","DataView","byteOffset","getUint8","getUint32","VideoSegmentStream","AudioSegmentStream","Transmuxer","CoalesceStream","mp4","frameUtils","audioFrameUtils","trackDecodeInfo","m2ts","AacStream","isLikelyAacData","AUDIO_PROPERTIES","VIDEO_PROPERTIES","arrayEquals","a","b","generateVideoSegmentTimingInfo","baseMediaDecodeTime","startDts","startPts","endDts","endPts","prependedContentDuration","start","track","options","adtsFrames","sequenceNumber","earliestAllowedDts","audioAppendStartTs","videoBaseMediaDecodeTime","collectDtsInfo","prop","setEarliestDts","earliestDts","timelineStartInfo","setVideoBaseMediaDecodeTime","setAudioAppendStart","timestamp","frames","moof","mdat","boxes","trimAdtsFramesByEarliestDts","calculateTrackBaseMediaDecodeTime","keepOriginalTimestamps","prefixWithSilence","samples","generateSampleTable","concatenateFrameData","clearDtsInfo","pps","nalUnits","gopsToAlignWith","minPTS","gopCache_","nalUnit","sps","gopForFusion","gops","firstGop","lastGop","resetStream_","groupNalsIntoFrames","groupFramesIntoGops","keyFrame","getGopForFusion_","duration","unshift","nalCount","extendFirstKeyFrame","alignedGops","alignGopsAtEnd","alignGopsAtEnd_","alignGopsAtStart_","gop","pop","concatenateNalData","dtsDistance","nearestGopObj","currentGop","currentGopObj","nearestDistance","alignIndex","gopIndex","align","alignEndIndex","matchFound","trimIndex","metadata","total","alignGopsWith","newGopsToAlignWith","metadataStream","numberOfTracks","remux","remuxTracks","pendingTracks","videoTrack","pendingBoxes","pendingCaptions","pendingMetadata","pendingBytes","emittedTracks","output","text","audioTrack","caption","id3","initSegment","offset","captions","captionStreams","info","timelineStartPts","endTime","stream","cueTime","dispatchType","hasFlushed","transmuxPipeline_","setupAacPipeline","pipeline","MetadataStream","aacStream","audioTimestampRolloverStream","TimestampRolloverStream","timedMetadataTimestampRolloverStream","adtsStream","coalesceStream","headOfPipeline","frame","setTimestamp","timeStamp","audioSegmentStream","codec","setupTsPipeline","packetStream","TransportPacketStream","parseStream","TransportParseStream","elementaryStream","ElementaryStream","videoTimestampRolloverStream","h264Stream","captionStream","CaptionStream","tracks","videoSegmentStream","setBaseMediaDecodeTime","discontinuity","reset","isAac","resetCaptions","StreamTypes","m2tsStreamTypes","bytesInBuffer","bytes","everything","startIndex","endIndex","parsePsi","parsePat","parsePmt","packetsWaitingForPmt","programMapTable","payload","psi","payloadUnitStartIndicator","pat","section_number","last_section_number","pmtPid","pmt","tableEnd","video","audio","timed-metadata","streamType","pid","processPes_","STREAM_TYPES","h264","adts","timedMetadata","flushStream","forceFlush","packetFlushable","packetData","pes","ptsDtsFlags","packetLength","dataAlignmentIndicator","PAT_PID","MP2T_PACKET_LENGTH","Cea608Stream","parseSyncSafeInteger","charCodeAt","parseId3TagSize","header","byteIndex","returnSize","parseAdtsSize","lowThree","middle","parseSampleRate","parseAacTimestamp","frameStart","frameSize","unescape","toString","percentEncode","FlvTag","extraData","adHoc","bufferStartSize","prepareWrite","flv","minLength","position","widthBytes","heightBytes","videocodecidBytes","VIDEO_TAG","AUDIO_TAG","METADATA_TAG","Error","writeBytes","max","writeByte","byte","writeShort","short","setUint16","negIndex","pos","nalUnitSize","startNalUnit","endNalUnit","nalContainer","nalStart","nalLength","setUint32","writeMetaDataDouble","val","setFloat64","writeMetaDataBoolean","setUint8","finalize","dtsDelta","len","frameTime","isAudioFrame","tag","isVideoFrame","isMetaData","isKeyFrame","obj","createNode","displayName","props","children","Root","Concat","Literal","Splat","Param","Optional","nodeTypes","keys","handlers","nodeType","visit","node","context","box","dinf","esds","ftyp","mfhd","minf","moov","mvex","mvhd","mdia","sdtp","stbl","stsd","trex","trun","types","MAJOR_BRAND","MINOR_VERSION","AVC1_BRAND","VIDEO_HDLR","AUDIO_HDLR","HDLR_TYPES","VMHD","SMHD","DREF","STCO","STSC","STSZ","STTS","videoSample","audioSample","audioTrun","videoTrun","trunHeader","UINT32_MAX","avc1","avcC","btrt","dref","mp4a","smhd","stco","stsc","stsz","stts","styp","vmhd","trackFragments","flags","dependsOn","isDependedOn","sequenceParameterSets","pictureParameterSets","Array","trackFragmentHeader","trackFragmentDecodeTime","trackFragmentRun","sampleDependencyTable","upperWordBaseMediaDecodeTime","lowerWordBaseMediaDecodeTime","floor","durationPresent","sizePresent","flagsPresent","compositionTimeOffset","sample","isLeading","hasRedundancy","paddingValue","isNonSyncSample","degradationPriority","fileType","movie","cea708Parser","captionPackets_","ccStreams_","cc","sei","userData","newCaptionPackets","parseSei","payloadType","USER_DATA_REGISTERED_ITU_T_T35","parseUserData","latestDts_","ignoreNextEqualDts_","numSameDts_","parseCaptionPackets","elem","idx","presortIndex","sort","dispatchCea608Packet","activeCea608Channel_","ccStream","setsChannel1Active","setsChannel2Active","ccData","CHARACTER_TRANSLATION","42","92","94","95","96","123","124","125","126","127","304","305","306","307","308","309","310","311","312","313","314","315","316","317","318","319","544","545","546","547","548","549","550","551","552","553","554","555","556","557","558","559","560","561","562","563","564","565","566","567","568","569","570","571","572","573","574","575","800","801","802","803","804","805","806","807","808","809","810","811","812","813","814","815","816","817","818","819","820","821","822","823","824","825","826","827","828","829","830","831","getCharFromCode","code","ROWS","createDisplayBuffer","BOTTOM_ROW","field","dataChannel","field_","dataChannel_","name_","setConstants","swap","char0","char1","lastControlCode_","PADDING_","RESUME_CAPTION_LOADING_","mode_","END_OF_CAPTION_","clearFormatting","flushDisplayed","displayed_","nonDisplayed_","startPts_","ROLL_UP_2_ROWS_","rollUpRows_","setRollUp","ROLL_UP_3_ROWS_","ROLL_UP_4_ROWS_","CARRIAGE_RETURN_","shiftRowsUp_","BACKSPACE_","row_","ERASE_DISPLAYED_MEMORY_","ERASE_NON_DISPLAYED_MEMORY_","RESUME_DIRECT_CAPTIONING_","isSpecialCharacter","column_","isExtCharacter","isMidRowCode","addFormatting","isOffsetControlCode","isPAC","row","formatting_","isColorPAC","isNormalChar","content","trim","e","console","error","join","replace","topRow_","BASE_","EXT_","CONTROL_","OFFSET_","char","newBaseRow","format","reverse","popOn","baseRow","rollUp","paintOn","payloadSize","handleRollover","reference","direction","abs","lastDTS","referenceDTS","type_","inspectMp4","textifyMp4","parseMp4Date","seconds","Date","parseSampleFlags","nalParse","avcStream","avcView","parse","dataReferenceIndex","getUint16","horizresolution","vertresolution","frameCount","depth","numOfPictureParameterSets","nalSize","configurationVersion","avcProfileIndication","avcLevelIndication","lengthSizeMinusOne","numOfSequenceParameterSets","bufferSizeDB","maxBitrate","avgBitrate","esId","streamPriority","decoderConfig","objectProfileIndication","bufferSize","decoderConfigDescriptor","audioObjectType","samplingFrequencyIndex","channelConfiguration","majorBrand","minorVersion","compatibleBrands","dataReferences","decodeURIComponent","escape","nals","language","creationTime","modificationTime","streamDescriptor","rate","volume","matrix","Uint32Array","nextTrackId","pdin","initialDelay","sidx","references","referenceId","earliestPresentationTime","firstOffset","referenceCount","referenceType","referencedSize","subsegmentDuration","startsWithSap","sapType","sapDeltaTime","balance","chunkOffsets","entryCount","sampleToChunks","firstChunk","samplesPerChunk","sampleDescriptionIndex","sampleDescriptions","sampleSize","entries","timeToSamples","sampleDelta","baseDataOffsetPresent","sampleDescriptionIndexPresent","defaultSampleDurationPresent","defaultSampleSizePresent","defaultSampleFlagsPresent","durationIsEmpty","defaultBaseIsMoof","baseDataOffset","defaultSampleDuration","defaultSampleSize","defaultSampleFlags","baseDataOffsetIsMoof","layer","alternateGroup","defaultSampleDescriptionIndex","sampleDependsOn","sampleIsDependedOn","sampleHasRedundancy","samplePaddingValue","sampleIsDifferenceSample","sampleDegradationPriority","dataOffsetPresent","firstSampleFlagsPresent","sampleDurationPresent","sampleSizePresent","sampleFlagsPresent","sampleCompositionTimeOffsetPresent","dataOffset","getInt32","url ","graphicsmode","opcolor","Uint16Array","ab","ArrayBuffer","v","z","inspectedMp4","indent","filter","prefix","match","line","JSON","stringify","split","inspect","textify","parseTfdt","parseHdlr","parseTfhd","parseTrun","parseSidx","root","window","warn","Emitter","RequestBase","isObject","ResponseBase","Agent","noop","request","method","url","Request","getXHR","XMLHttpRequest","location","protocol","ActiveXObject","serialize","pairs","pushEncodedKeyValuePair","isArray","subkey","encodeURIComponent","parseString","str","pair","isJSON","mime","test","Response","req","xhr","responseType","responseText","statusText","status","_setStatusProperties","headers","lines","fields","toLowerCase","parseHeader","getAllResponseHeaders","getResponseHeader","_setHeaderProperties","_responseType","body","response","_parseBody","_query","_header","new_err","err","res","original","rawResponse","statusCode","callback","emit","_isResponseOK","custom_err","del","fn","send","serializeObject","html","json","xml","urlencoded","form","form-data","application/x-www-form-urlencoded","application/json","_parser","toError","msg","accept","auth","user","pass","btoa","_auth","string","query","attach","file","_data","_getFormData","append","_formData","FormData","_shouldRetry","_retry","_callback","clearTimeout","_maxRetries","retries","_retries","crossDomainError","crossDomain","ca","agent","write","_isHost","_endCalled","_finalizeQueryString","_end","_aborted","_setTimeouts","onreadystatechange","readyState","_responseTimeoutTimer","timedout","handleProgress","percent","loaded","hasListeners","onprogress","upload","username","password","open","_withCredentials","withCredentials","contentType","_serializer","setRequestHeader","_setDefaults","head","patch","post","put","mixin","addEventListener","_callbacks","once","removeListener","removeAllListeners","removeEventListener","cb","_timer","timeout","_timeout","_responseTimeout","option","deadline","retry","_retryCallback","ERROR_CODES","override","then","resolve","reject","_fullfilledPromise","Promise","innerResolve","innerReject","use","ok","_okCallback","getHeader","unset","abort","base64Encoder","redirects","_maxRedirects","maxResponseSize","TypeError","_maxResponseSize","toJSON","isObj","sortQuery","_sort","queryArr","substring","_appendQueryString","trace","_timeoutError","reason","errno","setTimeout","utils","ct","params","links","link","parseLinks","statusType","redirect","clientError","serverError","created","accepted","noContent","badRequest","unauthorized","notAcceptable","forbidden","notFound","unprocessableEntity","parts","cleanHeader","changesOrigin","_defaults","def","Route","Parser","RegexpVisitor","ReverseVisitor","spec","route","ast","matched","parser","yy","k","$V0","$V1","$V2","$V3","$V4","symbols_","expressions","EOF","expression","optional","literal","splat","param","(",")","LITERAL","SPLAT","PARAM","$accept","$end","terminals_","2","5","11","12","13","14","15","productions_","performAction","yytext","yyleng","yylineno","yystate","$$","_$","$0","$","table","3","4","6","7","8","9","10","1","defaultActions","parseError","hash","recoverable","_parseError","message","input","stack","vstack","lstack","recovering","lexer","sharedState","setInput","yylloc","yyloc","ranges","getPrototypeOf","symbol","preErrorSymbol","state","action","newState","expected","lex","token","yyval","errStr","showPosition","loc","first_line","last_line","first_column","last_column","range","_input","_more","_backtrack","done","conditionStack","ch","unput","substr","oldLines","more","backtrack_lexer","less","pastInput","past","upcomingInput","next","pre","test_match","indexed_rule","backup","matches","tempMatch","rules","_currentRules","flex","begin","condition","popState","conditions","topState","pushState","stateStackSize","yy_","$avoiding_name_collisions","YY_START","INITIAL","inclusive","createVisitor","escapeRegExp","Matcher","captures","re","exec","matchParams","capture","memo","child","childResult","RegExp","childResults","some","decodeURI","encodeURI","EventEmitter","require","WebSocket","muxjs","constructor","super","transmuxer","merged","cue","[object Object]","address","ws","heartbeatInterval","started","binaryType","onopen","setInterval","onclose","clearInterval","wasClean","log","onmessage","typedArray","onerror","onOpen","onError","onClose","close","ReflectOwnKeys","R","Reflect","ReflectApply","target","receiver","Function","ownKeys","getOwnPropertySymbols","getOwnPropertyNames","NumberIsNaN","Number","isNaN","_events","_eventsCount","_maxListeners","defaultMaxListeners","$getMaxListeners","that","_addListener","prepend","events","existing","warning","newListener","warned","w","emitter","_onceWrap","fired","wrapFn","wrapped","_listeners","unwrap","evlistener","arr","ret","unwrapListeners","arrayClone","listenerCount","copy","arg","RangeError","setMaxListeners","getMaxListeners","doError","er","handler","addListener","prependListener","prependOnceListener","list","originalListener","spliceOne","rawListeners","eventNames","global","MozWebSocket","g","codecs","mp2t","tools","workingData","workingBytesAvailable","workingWord","workingBitsAvailable","bitsAvailable","loadWord","workingBytes","availableBytes","skipBytes","bits","valu","skipLeadingZeros","leadingZeroCount","clz","generator","probe","CaptionParser","sampleForFrame","currentNal","currentFrame","h","nalsByteLength","numberOfNals","coneOfSilence","clock","baseMediaDecodeTimeTs","frameDuration","silentFrame","audioGapDuration","audioFillFrameCount","audioFillDuration","audioTsToVideoTs","ONE_SECOND_IN_TS","videoTsToAudioTs","minSegmentDts","minSegmentPts","array","sum","sumFrameByteLengths","metaTable","highPrefix","lowPrefix","zeroFill","96000","88200","64000","48000","44100","32000","24000","16000","12000","11025","8000","part","secondsToVideoTs","secondsToAudioTs","videoTsToSeconds","audioTsToSeconds","sampleRate","maxSegmentDts","maxSegmentPts","parseUtf8","tagParsers","TXXX","description","WXXX","PRIV","owner","privateData","settings","debug","descriptor","tagSize","chunk","aacUtils","bytesLeft","tempLength","mapToSample","approximateOffset","parseCaptionNals","segment","videoTrackId","mdats","captionNals","mdatTrafPairs","matchingTraf","seiNals","headerInfo","truns","seiNal","lastMatchedSample","matchingSample","findSeiNals","allSamples","parseSamples","segmentCache","parsedCaptions","isInitialized","isNewInit","timescales","parsedData","cachedSegment","parseEmbeddedCaptions","pushNals","nal","clearParsedCaptions","resetCaptionStream","clearAllCaptions","getFlvHeader","collectTimelineInfo","metaDataTag","extraDataTag","TagList","oldExtraData","videoKeyFrames","round","adtsFrame","lastMetaPts","tags","writeMetaDataTags","onVideoKeyFrame","h264Frame","finishFrame","newMetadata","metaTag","extraTag","videoTags","audioTags","processedTracks","metadataLength","headBytes","tagTypes","18","hexStringList","toUpperCase","parseVideoTag","codecID","parseInt","frameType","compositionTime","avcPacketType","CompositionTime","nalUnitTypeRaw","parseAVCTag","parseAudioTag","soundFormat","soundRate","soundSize","soundType","aacPacketType","parseAACTag","inspectFlvTag","tagType","dataSize","streamID","parseGenericTag","inspectTag","parsedResults","flvTagArray","ts","aac","parseAudioPes_","pesType","pusi","parsed","endLoop","parsePesType","parsePayloadUnitStartIndicator","parsePesTime","parseVideoPes_","firstKeyFrame","videoPacketContainsKeyFrame","inspectTs_","parsePsi_","baseTimestamp","audioCount","audioTimescale","inspectAac_","segmentInfo","audioBaseTimestamp","dtsTime","ptsTime","videoBaseTimestamp","adjustTimestamp_","parsePid","parseAdaptionField","parseNalUnitType","payloadOffset","frameBuffer","frameI","frameSyncPoint","foundKeyFrame","Flatted","Primitive","primitive","reviver","Primitives","primitives","tmp","revive","has","add","Set","","replacer","space","firstRun","known","Map","after","level","color","sanitizedValue","Client","element","document","querySelector","windowLogger","makeLogger","videoLogger","mediaSourceLogger","sourceBufferLogger","websocketLogger","mediaError","parsedRoute","pathname","async","streamUrl","client","mediaSource","MediaSource","src","URL","createObjectURL","handle","queue","addSourceBuffer","updating","appendBuffer","initialize"],"mappings":"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","file":"index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 55);\n","/**\n * mux.js\n *\n * Copyright (c) 2014 Brightcove\n * All rights reserved.\n *\n * A lightweight readable stream implemention that handles event dispatching.\n * Objects that inherit from streams should call init in their constructors.\n */\n'use strict';\n\nvar Stream = function() {\n  this.init = function() {\n    var listeners = {};\n    /**\n     * Add a listener for a specified event type.\n     * @param type {string} the event name\n     * @param listener {function} the callback to be invoked when an event of\n     * the specified type occurs\n     */\n    this.on = function(type, listener) {\n      if (!listeners[type]) {\n        listeners[type] = [];\n      }\n      listeners[type] = listeners[type].concat(listener);\n    };\n    /**\n     * Remove a listener for a specified event type.\n     * @param type {string} the event name\n     * @param listener {function} a function previously registered for this\n     * type of event through `on`\n     */\n    this.off = function(type, listener) {\n      var index;\n      if (!listeners[type]) {\n        return false;\n      }\n      index = listeners[type].indexOf(listener);\n      listeners[type] = listeners[type].slice();\n      listeners[type].splice(index, 1);\n      return index > -1;\n    };\n    /**\n     * Trigger an event of the specified type on this stream. Any additional\n     * arguments to this function are passed as parameters to event listeners.\n     * @param type {string} the event name\n     */\n    this.trigger = function(type) {\n      var callbacks, i, length, args;\n      callbacks = listeners[type];\n      if (!callbacks) {\n        return;\n      }\n      // Slicing the arguments on every invocation of this method\n      // can add a significant amount of overhead. Avoid the\n      // intermediate object creation for the common case of a\n      // single callback argument\n      if (arguments.length === 2) {\n        length = callbacks.length;\n        for (i = 0; i < length; ++i) {\n          callbacks[i].call(this, arguments[1]);\n        }\n      } else {\n        args = [];\n        i = arguments.length;\n        for (i = 1; i < arguments.length; ++i) {\n          args.push(arguments[i]);\n        }\n        length = callbacks.length;\n        for (i = 0; i < length; ++i) {\n          callbacks[i].apply(this, args);\n        }\n      }\n    };\n    /**\n     * Destroys the stream and cleans up.\n     */\n    this.dispose = function() {\n      listeners = {};\n    };\n  };\n};\n\n/**\n * Forwards all `data` events on this stream to the destination stream. The\n * destination stream should provide a method `push` to receive the data\n * events as they arrive.\n * @param destination {stream} the stream that will receive all `data` events\n * @param autoFlush {boolean} if false, we will not call `flush` on the destination\n *                            when the current stream emits a 'done' event\n * @see http://nodejs.org/api/stream.html#stream_readable_pipe_destination_options\n */\nStream.prototype.pipe = function(destination) {\n  this.on('data', function(data) {\n    destination.push(data);\n  });\n\n  this.on('done', function(flushSource) {\n    destination.flush(flushSource);\n  });\n\n  return destination;\n};\n\n// Default stream functions that are expected to be overridden to perform\n// actual work. These are provided by the prototype as a sort of no-op\n// implementation so that we don't have to check for their existence in the\n// `pipe` function above.\nStream.prototype.push = function(data) {\n  this.trigger('data', data);\n};\n\nStream.prototype.flush = function(flushSource) {\n  this.trigger('done', flushSource);\n};\n\nmodule.exports = Stream;\n","'use strict';\n\nmodule.exports = {\n  H264_STREAM_TYPE: 0x1B,\n  ADTS_STREAM_TYPE: 0x0F,\n  METADATA_STREAM_TYPE: 0x15\n};\n","'use strict';\n\nvar Stream = require('../utils/stream.js');\n\nvar AdtsStream;\n\nvar\n  ADTS_SAMPLING_FREQUENCIES = [\n    96000,\n    88200,\n    64000,\n    48000,\n    44100,\n    32000,\n    24000,\n    22050,\n    16000,\n    12000,\n    11025,\n    8000,\n    7350\n  ];\n\n/*\n * Accepts a ElementaryStream and emits data events with parsed\n * AAC Audio Frames of the individual packets. Input audio in ADTS\n * format is unpacked and re-emitted as AAC frames.\n *\n * @see http://wiki.multimedia.cx/index.php?title=ADTS\n * @see http://wiki.multimedia.cx/?title=Understanding_AAC\n */\nAdtsStream = function() {\n  var buffer;\n\n  AdtsStream.prototype.init.call(this);\n\n  this.push = function(packet) {\n    var\n      i = 0,\n      frameNum = 0,\n      frameLength,\n      protectionSkipBytes,\n      frameEnd,\n      oldBuffer,\n      sampleCount,\n      adtsFrameDuration;\n\n    if (packet.type !== 'audio') {\n      // ignore non-audio data\n      return;\n    }\n\n    // Prepend any data in the buffer to the input data so that we can parse\n    // aac frames the cross a PES packet boundary\n    if (buffer) {\n      oldBuffer = buffer;\n      buffer = new Uint8Array(oldBuffer.byteLength + packet.data.byteLength);\n      buffer.set(oldBuffer);\n      buffer.set(packet.data, oldBuffer.byteLength);\n    } else {\n      buffer = packet.data;\n    }\n\n    // unpack any ADTS frames which have been fully received\n    // for details on the ADTS header, see http://wiki.multimedia.cx/index.php?title=ADTS\n    while (i + 5 < buffer.length) {\n\n      // Loook for the start of an ADTS header..\n      if (buffer[i] !== 0xFF || (buffer[i + 1] & 0xF6) !== 0xF0) {\n        // If a valid header was not found,  jump one forward and attempt to\n        // find a valid ADTS header starting at the next byte\n        i++;\n        continue;\n      }\n\n      // The protection skip bit tells us if we have 2 bytes of CRC data at the\n      // end of the ADTS header\n      protectionSkipBytes = (~buffer[i + 1] & 0x01) * 2;\n\n      // Frame length is a 13 bit integer starting 16 bits from the\n      // end of the sync sequence\n      frameLength = ((buffer[i + 3] & 0x03) << 11) |\n        (buffer[i + 4] << 3) |\n        ((buffer[i + 5] & 0xe0) >> 5);\n\n      sampleCount = ((buffer[i + 6] & 0x03) + 1) * 1024;\n      adtsFrameDuration = (sampleCount * 90000) /\n        ADTS_SAMPLING_FREQUENCIES[(buffer[i + 2] & 0x3c) >>> 2];\n\n      frameEnd = i + frameLength;\n\n      // If we don't have enough data to actually finish this ADTS frame, return\n      // and wait for more data\n      if (buffer.byteLength < frameEnd) {\n        return;\n      }\n\n      // Otherwise, deliver the complete AAC frame\n      this.trigger('data', {\n        pts: packet.pts + (frameNum * adtsFrameDuration),\n        dts: packet.dts + (frameNum * adtsFrameDuration),\n        sampleCount: sampleCount,\n        audioobjecttype: ((buffer[i + 2] >>> 6) & 0x03) + 1,\n        channelcount: ((buffer[i + 2] & 1) << 2) |\n          ((buffer[i + 3] & 0xc0) >>> 6),\n        samplerate: ADTS_SAMPLING_FREQUENCIES[(buffer[i + 2] & 0x3c) >>> 2],\n        samplingfrequencyindex: (buffer[i + 2] & 0x3c) >>> 2,\n        // assume ISO/IEC 14496-12 AudioSampleEntry default of 16\n        samplesize: 16,\n        data: buffer.subarray(i + 7 + protectionSkipBytes, frameEnd)\n      });\n\n      // If the buffer is empty, clear it and return\n      if (buffer.byteLength === frameEnd) {\n        buffer = undefined;\n        return;\n      }\n\n      frameNum++;\n\n      // Remove the finished frame from the buffer and start the process again\n      buffer = buffer.subarray(frameEnd);\n    }\n  };\n  this.flush = function() {\n    this.trigger('done');\n  };\n};\n\nAdtsStream.prototype = new Stream();\n\nmodule.exports = AdtsStream;\n","'use strict';\n\nvar Stream = require('../utils/stream.js');\nvar ExpGolomb = require('../utils/exp-golomb.js');\n\nvar H264Stream, NalByteStream;\nvar PROFILES_WITH_OPTIONAL_SPS_DATA;\n\n/**\n * Accepts a NAL unit byte stream and unpacks the embedded NAL units.\n */\nNalByteStream = function() {\n  var\n    syncPoint = 0,\n    i,\n    buffer;\n  NalByteStream.prototype.init.call(this);\n\n  /*\n   * Scans a byte stream and triggers a data event with the NAL units found.\n   * @param {Object} data Event received from H264Stream\n   * @param {Uint8Array} data.data The h264 byte stream to be scanned\n   *\n   * @see H264Stream.push\n   */\n  this.push = function(data) {\n    var swapBuffer;\n\n    if (!buffer) {\n      buffer = data.data;\n    } else {\n      swapBuffer = new Uint8Array(buffer.byteLength + data.data.byteLength);\n      swapBuffer.set(buffer);\n      swapBuffer.set(data.data, buffer.byteLength);\n      buffer = swapBuffer;\n    }\n\n    // Rec. ITU-T H.264, Annex B\n    // scan for NAL unit boundaries\n\n    // a match looks like this:\n    // 0 0 1 .. NAL .. 0 0 1\n    // ^ sync point        ^ i\n    // or this:\n    // 0 0 1 .. NAL .. 0 0 0\n    // ^ sync point        ^ i\n\n    // advance the sync point to a NAL start, if necessary\n    for (; syncPoint < buffer.byteLength - 3; syncPoint++) {\n      if (buffer[syncPoint + 2] === 1) {\n        // the sync point is properly aligned\n        i = syncPoint + 5;\n        break;\n      }\n    }\n\n    while (i < buffer.byteLength) {\n      // look at the current byte to determine if we've hit the end of\n      // a NAL unit boundary\n      switch (buffer[i]) {\n      case 0:\n        // skip past non-sync sequences\n        if (buffer[i - 1] !== 0) {\n          i += 2;\n          break;\n        } else if (buffer[i - 2] !== 0) {\n          i++;\n          break;\n        }\n\n        // deliver the NAL unit if it isn't empty\n        if (syncPoint + 3 !== i - 2) {\n          this.trigger('data', buffer.subarray(syncPoint + 3, i - 2));\n        }\n\n        // drop trailing zeroes\n        do {\n          i++;\n        } while (buffer[i] !== 1 && i < buffer.length);\n        syncPoint = i - 2;\n        i += 3;\n        break;\n      case 1:\n        // skip past non-sync sequences\n        if (buffer[i - 1] !== 0 ||\n            buffer[i - 2] !== 0) {\n          i += 3;\n          break;\n        }\n\n        // deliver the NAL unit\n        this.trigger('data', buffer.subarray(syncPoint + 3, i - 2));\n        syncPoint = i - 2;\n        i += 3;\n        break;\n      default:\n        // the current byte isn't a one or zero, so it cannot be part\n        // of a sync sequence\n        i += 3;\n        break;\n      }\n    }\n    // filter out the NAL units that were delivered\n    buffer = buffer.subarray(syncPoint);\n    i -= syncPoint;\n    syncPoint = 0;\n  };\n\n  this.flush = function() {\n    // deliver the last buffered NAL unit\n    if (buffer && buffer.byteLength > 3) {\n      this.trigger('data', buffer.subarray(syncPoint + 3));\n    }\n    // reset the stream state\n    buffer = null;\n    syncPoint = 0;\n    this.trigger('done');\n  };\n};\nNalByteStream.prototype = new Stream();\n\n// values of profile_idc that indicate additional fields are included in the SPS\n// see Recommendation ITU-T H.264 (4/2013),\n// 7.3.2.1.1 Sequence parameter set data syntax\nPROFILES_WITH_OPTIONAL_SPS_DATA = {\n  100: true,\n  110: true,\n  122: true,\n  244: true,\n  44: true,\n  83: true,\n  86: true,\n  118: true,\n  128: true,\n  138: true,\n  139: true,\n  134: true\n};\n\n/**\n * Accepts input from a ElementaryStream and produces H.264 NAL unit data\n * events.\n */\nH264Stream = function() {\n  var\n    nalByteStream = new NalByteStream(),\n    self,\n    trackId,\n    currentPts,\n    currentDts,\n\n    discardEmulationPreventionBytes,\n    readSequenceParameterSet,\n    skipScalingList;\n\n  H264Stream.prototype.init.call(this);\n  self = this;\n\n  /*\n   * Pushes a packet from a stream onto the NalByteStream\n   *\n   * @param {Object} packet - A packet received from a stream\n   * @param {Uint8Array} packet.data - The raw bytes of the packet\n   * @param {Number} packet.dts - Decode timestamp of the packet\n   * @param {Number} packet.pts - Presentation timestamp of the packet\n   * @param {Number} packet.trackId - The id of the h264 track this packet came from\n   * @param {('video'|'audio')} packet.type - The type of packet\n   *\n   */\n  this.push = function(packet) {\n    if (packet.type !== 'video') {\n      return;\n    }\n    trackId = packet.trackId;\n    currentPts = packet.pts;\n    currentDts = packet.dts;\n\n    nalByteStream.push(packet);\n  };\n\n  /*\n   * Identify NAL unit types and pass on the NALU, trackId, presentation and decode timestamps\n   * for the NALUs to the next stream component.\n   * Also, preprocess caption and sequence parameter NALUs.\n   *\n   * @param {Uint8Array} data - A NAL unit identified by `NalByteStream.push`\n   * @see NalByteStream.push\n   */\n  nalByteStream.on('data', function(data) {\n    var\n      event = {\n        trackId: trackId,\n        pts: currentPts,\n        dts: currentDts,\n        data: data\n      };\n\n    switch (data[0] & 0x1f) {\n    case 0x05:\n      event.nalUnitType = 'slice_layer_without_partitioning_rbsp_idr';\n      break;\n    case 0x06:\n      event.nalUnitType = 'sei_rbsp';\n      event.escapedRBSP = discardEmulationPreventionBytes(data.subarray(1));\n      break;\n    case 0x07:\n      event.nalUnitType = 'seq_parameter_set_rbsp';\n      event.escapedRBSP = discardEmulationPreventionBytes(data.subarray(1));\n      event.config = readSequenceParameterSet(event.escapedRBSP);\n      break;\n    case 0x08:\n      event.nalUnitType = 'pic_parameter_set_rbsp';\n      break;\n    case 0x09:\n      event.nalUnitType = 'access_unit_delimiter_rbsp';\n      break;\n\n    default:\n      break;\n    }\n    // This triggers data on the H264Stream\n    self.trigger('data', event);\n  });\n  nalByteStream.on('done', function() {\n    self.trigger('done');\n  });\n\n  this.flush = function() {\n    nalByteStream.flush();\n  };\n\n  /**\n   * Advance the ExpGolomb decoder past a scaling list. The scaling\n   * list is optionally transmitted as part of a sequence parameter\n   * set and is not relevant to transmuxing.\n   * @param count {number} the number of entries in this scaling list\n   * @param expGolombDecoder {object} an ExpGolomb pointed to the\n   * start of a scaling list\n   * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1\n   */\n  skipScalingList = function(count, expGolombDecoder) {\n    var\n      lastScale = 8,\n      nextScale = 8,\n      j,\n      deltaScale;\n\n    for (j = 0; j < count; j++) {\n      if (nextScale !== 0) {\n        deltaScale = expGolombDecoder.readExpGolomb();\n        nextScale = (lastScale + deltaScale + 256) % 256;\n      }\n\n      lastScale = (nextScale === 0) ? lastScale : nextScale;\n    }\n  };\n\n  /**\n   * Expunge any \"Emulation Prevention\" bytes from a \"Raw Byte\n   * Sequence Payload\"\n   * @param data {Uint8Array} the bytes of a RBSP from a NAL\n   * unit\n   * @return {Uint8Array} the RBSP without any Emulation\n   * Prevention Bytes\n   */\n  discardEmulationPreventionBytes = function(data) {\n    var\n      length = data.byteLength,\n      emulationPreventionBytesPositions = [],\n      i = 1,\n      newLength, newData;\n\n    // Find all `Emulation Prevention Bytes`\n    while (i < length - 2) {\n      if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\n        emulationPreventionBytesPositions.push(i + 2);\n        i += 2;\n      } else {\n        i++;\n      }\n    }\n\n    // If no Emulation Prevention Bytes were found just return the original\n    // array\n    if (emulationPreventionBytesPositions.length === 0) {\n      return data;\n    }\n\n    // Create a new array to hold the NAL unit data\n    newLength = length - emulationPreventionBytesPositions.length;\n    newData = new Uint8Array(newLength);\n    var sourceIndex = 0;\n\n    for (i = 0; i < newLength; sourceIndex++, i++) {\n      if (sourceIndex === emulationPreventionBytesPositions[0]) {\n        // Skip this byte\n        sourceIndex++;\n        // Remove this position index\n        emulationPreventionBytesPositions.shift();\n      }\n      newData[i] = data[sourceIndex];\n    }\n\n    return newData;\n  };\n\n  /**\n   * Read a sequence parameter set and return some interesting video\n   * properties. A sequence parameter set is the H264 metadata that\n   * describes the properties of upcoming video frames.\n   * @param data {Uint8Array} the bytes of a sequence parameter set\n   * @return {object} an object with configuration parsed from the\n   * sequence parameter set, including the dimensions of the\n   * associated video frames.\n   */\n  readSequenceParameterSet = function(data) {\n    var\n      frameCropLeftOffset = 0,\n      frameCropRightOffset = 0,\n      frameCropTopOffset = 0,\n      frameCropBottomOffset = 0,\n      sarScale = 1,\n      expGolombDecoder, profileIdc, levelIdc, profileCompatibility,\n      chromaFormatIdc, picOrderCntType,\n      numRefFramesInPicOrderCntCycle, picWidthInMbsMinus1,\n      picHeightInMapUnitsMinus1,\n      frameMbsOnlyFlag,\n      scalingListCount,\n      sarRatio,\n      aspectRatioIdc,\n      i;\n\n    expGolombDecoder = new ExpGolomb(data);\n    profileIdc = expGolombDecoder.readUnsignedByte(); // profile_idc\n    profileCompatibility = expGolombDecoder.readUnsignedByte(); // constraint_set[0-5]_flag\n    levelIdc = expGolombDecoder.readUnsignedByte(); // level_idc u(8)\n    expGolombDecoder.skipUnsignedExpGolomb(); // seq_parameter_set_id\n\n    // some profiles have more optional data we don't need\n    if (PROFILES_WITH_OPTIONAL_SPS_DATA[profileIdc]) {\n      chromaFormatIdc = expGolombDecoder.readUnsignedExpGolomb();\n      if (chromaFormatIdc === 3) {\n        expGolombDecoder.skipBits(1); // separate_colour_plane_flag\n      }\n      expGolombDecoder.skipUnsignedExpGolomb(); // bit_depth_luma_minus8\n      expGolombDecoder.skipUnsignedExpGolomb(); // bit_depth_chroma_minus8\n      expGolombDecoder.skipBits(1); // qpprime_y_zero_transform_bypass_flag\n      if (expGolombDecoder.readBoolean()) { // seq_scaling_matrix_present_flag\n        scalingListCount = (chromaFormatIdc !== 3) ? 8 : 12;\n        for (i = 0; i < scalingListCount; i++) {\n          if (expGolombDecoder.readBoolean()) { // seq_scaling_list_present_flag[ i ]\n            if (i < 6) {\n              skipScalingList(16, expGolombDecoder);\n            } else {\n              skipScalingList(64, expGolombDecoder);\n            }\n          }\n        }\n      }\n    }\n\n    expGolombDecoder.skipUnsignedExpGolomb(); // log2_max_frame_num_minus4\n    picOrderCntType = expGolombDecoder.readUnsignedExpGolomb();\n\n    if (picOrderCntType === 0) {\n      expGolombDecoder.readUnsignedExpGolomb(); // log2_max_pic_order_cnt_lsb_minus4\n    } else if (picOrderCntType === 1) {\n      expGolombDecoder.skipBits(1); // delta_pic_order_always_zero_flag\n      expGolombDecoder.skipExpGolomb(); // offset_for_non_ref_pic\n      expGolombDecoder.skipExpGolomb(); // offset_for_top_to_bottom_field\n      numRefFramesInPicOrderCntCycle = expGolombDecoder.readUnsignedExpGolomb();\n      for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {\n        expGolombDecoder.skipExpGolomb(); // offset_for_ref_frame[ i ]\n      }\n    }\n\n    expGolombDecoder.skipUnsignedExpGolomb(); // max_num_ref_frames\n    expGolombDecoder.skipBits(1); // gaps_in_frame_num_value_allowed_flag\n\n    picWidthInMbsMinus1 = expGolombDecoder.readUnsignedExpGolomb();\n    picHeightInMapUnitsMinus1 = expGolombDecoder.readUnsignedExpGolomb();\n\n    frameMbsOnlyFlag = expGolombDecoder.readBits(1);\n    if (frameMbsOnlyFlag === 0) {\n      expGolombDecoder.skipBits(1); // mb_adaptive_frame_field_flag\n    }\n\n    expGolombDecoder.skipBits(1); // direct_8x8_inference_flag\n    if (expGolombDecoder.readBoolean()) { // frame_cropping_flag\n      frameCropLeftOffset = expGolombDecoder.readUnsignedExpGolomb();\n      frameCropRightOffset = expGolombDecoder.readUnsignedExpGolomb();\n      frameCropTopOffset = expGolombDecoder.readUnsignedExpGolomb();\n      frameCropBottomOffset = expGolombDecoder.readUnsignedExpGolomb();\n    }\n    if (expGolombDecoder.readBoolean()) {\n      // vui_parameters_present_flag\n      if (expGolombDecoder.readBoolean()) {\n        // aspect_ratio_info_present_flag\n        aspectRatioIdc = expGolombDecoder.readUnsignedByte();\n        switch (aspectRatioIdc) {\n          case 1: sarRatio = [1, 1]; break;\n          case 2: sarRatio = [12, 11]; break;\n          case 3: sarRatio = [10, 11]; break;\n          case 4: sarRatio = [16, 11]; break;\n          case 5: sarRatio = [40, 33]; break;\n          case 6: sarRatio = [24, 11]; break;\n          case 7: sarRatio = [20, 11]; break;\n          case 8: sarRatio = [32, 11]; break;\n          case 9: sarRatio = [80, 33]; break;\n          case 10: sarRatio = [18, 11]; break;\n          case 11: sarRatio = [15, 11]; break;\n          case 12: sarRatio = [64, 33]; break;\n          case 13: sarRatio = [160, 99]; break;\n          case 14: sarRatio = [4, 3]; break;\n          case 15: sarRatio = [3, 2]; break;\n          case 16: sarRatio = [2, 1]; break;\n          case 255: {\n            sarRatio = [expGolombDecoder.readUnsignedByte() << 8 |\n                        expGolombDecoder.readUnsignedByte(),\n                        expGolombDecoder.readUnsignedByte() << 8 |\n                        expGolombDecoder.readUnsignedByte() ];\n            break;\n          }\n        }\n        if (sarRatio) {\n          sarScale = sarRatio[0] / sarRatio[1];\n        }\n      }\n    }\n    return {\n      profileIdc: profileIdc,\n      levelIdc: levelIdc,\n      profileCompatibility: profileCompatibility,\n      width: Math.ceil((((picWidthInMbsMinus1 + 1) * 16) - frameCropLeftOffset * 2 - frameCropRightOffset * 2) * sarScale),\n      height: ((2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16) - (frameCropTopOffset * 2) - (frameCropBottomOffset * 2)\n    };\n  };\n\n};\nH264Stream.prototype = new Stream();\n\nmodule.exports = {\n  H264Stream: H264Stream,\n  NalByteStream: NalByteStream\n};\n","/**\n * mux.js\n *\n * Copyright (c) 2015 Brightcove\n * All rights reserved.\n *\n * Utilities to detect basic properties and metadata about MP4s.\n */\n'use strict';\n\nvar toUnsigned = require('../utils/bin').toUnsigned;\nvar findBox, parseType, timescale, startTime, getVideoTrackIds;\n\n// Find the data for a box specified by its path\nfindBox = function(data, path) {\n  var results = [],\n      i, size, type, end, subresults;\n\n  if (!path.length) {\n    // short-circuit the search for empty paths\n    return null;\n  }\n\n  for (i = 0; i < data.byteLength;) {\n    size  = toUnsigned(data[i]     << 24 |\n                       data[i + 1] << 16 |\n                       data[i + 2] <<  8 |\n                       data[i + 3]);\n\n    type = parseType(data.subarray(i + 4, i + 8));\n\n    end = size > 1 ? i + size : data.byteLength;\n\n    if (type === path[0]) {\n      if (path.length === 1) {\n        // this is the end of the path and we've found the box we were\n        // looking for\n        results.push(data.subarray(i + 8, end));\n      } else {\n        // recursively search for the next box along the path\n        subresults = findBox(data.subarray(i + 8, end), path.slice(1));\n        if (subresults.length) {\n          results = results.concat(subresults);\n        }\n      }\n    }\n    i = end;\n  }\n\n  // we've finished searching all of data\n  return results;\n};\n\n/**\n * Returns the string representation of an ASCII encoded four byte buffer.\n * @param buffer {Uint8Array} a four-byte buffer to translate\n * @return {string} the corresponding string\n */\nparseType = function(buffer) {\n  var result = '';\n  result += String.fromCharCode(buffer[0]);\n  result += String.fromCharCode(buffer[1]);\n  result += String.fromCharCode(buffer[2]);\n  result += String.fromCharCode(buffer[3]);\n  return result;\n};\n\n/**\n * Parses an MP4 initialization segment and extracts the timescale\n * values for any declared tracks. Timescale values indicate the\n * number of clock ticks per second to assume for time-based values\n * elsewhere in the MP4.\n *\n * To determine the start time of an MP4, you need two pieces of\n * information: the timescale unit and the earliest base media decode\n * time. Multiple timescales can be specified within an MP4 but the\n * base media decode time is always expressed in the timescale from\n * the media header box for the track:\n * ```\n * moov > trak > mdia > mdhd.timescale\n * ```\n * @param init {Uint8Array} the bytes of the init segment\n * @return {object} a hash of track ids to timescale values or null if\n * the init segment is malformed.\n */\ntimescale = function(init) {\n  var\n    result = {},\n    traks = findBox(init, ['moov', 'trak']);\n\n  // mdhd timescale\n  return traks.reduce(function(result, trak) {\n    var tkhd, version, index, id, mdhd;\n\n    tkhd = findBox(trak, ['tkhd'])[0];\n    if (!tkhd) {\n      return null;\n    }\n    version = tkhd[0];\n    index = version === 0 ? 12 : 20;\n    id = toUnsigned(tkhd[index]     << 24 |\n                    tkhd[index + 1] << 16 |\n                    tkhd[index + 2] <<  8 |\n                    tkhd[index + 3]);\n\n    mdhd = findBox(trak, ['mdia', 'mdhd'])[0];\n    if (!mdhd) {\n      return null;\n    }\n    version = mdhd[0];\n    index = version === 0 ? 12 : 20;\n    result[id] = toUnsigned(mdhd[index]     << 24 |\n                            mdhd[index + 1] << 16 |\n                            mdhd[index + 2] <<  8 |\n                            mdhd[index + 3]);\n    return result;\n  }, result);\n};\n\n/**\n * Determine the base media decode start time, in seconds, for an MP4\n * fragment. If multiple fragments are specified, the earliest time is\n * returned.\n *\n * The base media decode time can be parsed from track fragment\n * metadata:\n * ```\n * moof > traf > tfdt.baseMediaDecodeTime\n * ```\n * It requires the timescale value from the mdhd to interpret.\n *\n * @param timescale {object} a hash of track ids to timescale values.\n * @return {number} the earliest base media decode start time for the\n * fragment, in seconds\n */\nstartTime = function(timescale, fragment) {\n  var trafs, baseTimes, result;\n\n  // we need info from two childrend of each track fragment box\n  trafs = findBox(fragment, ['moof', 'traf']);\n\n  // determine the start times for each track\n  baseTimes = [].concat.apply([], trafs.map(function(traf) {\n    return findBox(traf, ['tfhd']).map(function(tfhd) {\n      var id, scale, baseTime;\n\n      // get the track id from the tfhd\n      id = toUnsigned(tfhd[4] << 24 |\n                      tfhd[5] << 16 |\n                      tfhd[6] <<  8 |\n                      tfhd[7]);\n      // assume a 90kHz clock if no timescale was specified\n      scale = timescale[id] || 90e3;\n\n      // get the base media decode time from the tfdt\n      baseTime = findBox(traf, ['tfdt']).map(function(tfdt) {\n        var version, result;\n\n        version = tfdt[0];\n        result = toUnsigned(tfdt[4] << 24 |\n                            tfdt[5] << 16 |\n                            tfdt[6] <<  8 |\n                            tfdt[7]);\n        if (version ===  1) {\n          result *= Math.pow(2, 32);\n          result += toUnsigned(tfdt[8]  << 24 |\n                               tfdt[9]  << 16 |\n                               tfdt[10] <<  8 |\n                               tfdt[11]);\n        }\n        return result;\n      })[0];\n      baseTime = baseTime || Infinity;\n\n      // convert base time to seconds\n      return baseTime / scale;\n    });\n  }));\n\n  // return the minimum\n  result = Math.min.apply(null, baseTimes);\n  return isFinite(result) ? result : 0;\n};\n\n/**\n  * Find the trackIds of the video tracks in this source.\n  * Found by parsing the Handler Reference and Track Header Boxes:\n  *   moov > trak > mdia > hdlr\n  *   moov > trak > tkhd\n  *\n  * @param {Uint8Array} init - The bytes of the init segment for this source\n  * @return {Number[]} A list of trackIds\n  *\n  * @see ISO-BMFF-12/2015, Section 8.4.3\n **/\ngetVideoTrackIds = function(init) {\n  var traks = findBox(init, ['moov', 'trak']);\n  var videoTrackIds = [];\n\n  traks.forEach(function(trak) {\n    var hdlrs = findBox(trak, ['mdia', 'hdlr']);\n    var tkhds = findBox(trak, ['tkhd']);\n\n    hdlrs.forEach(function(hdlr, index) {\n      var handlerType = parseType(hdlr.subarray(8, 12));\n      var tkhd = tkhds[index];\n      var view;\n      var version;\n      var trackId;\n\n      if (handlerType === 'vide') {\n        view = new DataView(tkhd.buffer, tkhd.byteOffset, tkhd.byteLength);\n        version = view.getUint8(0);\n        trackId = (version === 0) ? view.getUint32(12) : view.getUint32(20);\n\n        videoTrackIds.push(trackId);\n      }\n    });\n  });\n\n  return videoTrackIds;\n};\n\nmodule.exports = {\n  findBox: findBox,\n  parseType: parseType,\n  timescale: timescale,\n  startTime: startTime,\n  videoTrackIds: getVideoTrackIds\n};\n","/**\n * mux.js\n *\n * Copyright (c) 2015 Brightcove\n * All rights reserved.\n *\n * A stream-based mp2t to mp4 converter. This utility can be used to\n * deliver mp4s to a SourceBuffer on platforms that support native\n * Media Source Extensions.\n */\n'use strict';\n\nvar Stream = require('../utils/stream.js');\nvar mp4 = require('./mp4-generator.js');\nvar frameUtils = require('./frame-utils');\nvar audioFrameUtils = require('./audio-frame-utils');\nvar trackDecodeInfo = require('./track-decode-info');\nvar m2ts = require('../m2ts/m2ts.js');\nvar AdtsStream = require('../codecs/adts.js');\nvar H264Stream = require('../codecs/h264').H264Stream;\nvar AacStream = require('../aac');\nvar isLikelyAacData = require('../aac/utils').isLikelyAacData;\n\n// constants\nvar AUDIO_PROPERTIES = [\n  'audioobjecttype',\n  'channelcount',\n  'samplerate',\n  'samplingfrequencyindex',\n  'samplesize'\n];\n\nvar VIDEO_PROPERTIES = [\n  'width',\n  'height',\n  'profileIdc',\n  'levelIdc',\n  'profileCompatibility'\n];\n\n// object types\nvar VideoSegmentStream, AudioSegmentStream, Transmuxer, CoalesceStream;\n\n/**\n * Compare two arrays (even typed) for same-ness\n */\nvar arrayEquals = function(a, b) {\n  var\n    i;\n\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  // compare the value of each element in the array\n  for (i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nvar generateVideoSegmentTimingInfo = function(\n  baseMediaDecodeTime,\n  startDts,\n  startPts,\n  endDts,\n  endPts,\n  prependedContentDuration\n) {\n  var\n    ptsOffsetFromDts = startPts - startDts,\n    decodeDuration = endDts - startDts,\n    presentationDuration = endPts - startPts;\n\n  // The PTS and DTS values are based on the actual stream times from the segment,\n  // however, the player time values will reflect a start from the baseMediaDecodeTime.\n  // In order to provide relevant values for the player times, base timing info on the\n  // baseMediaDecodeTime and the DTS and PTS durations of the segment.\n  return {\n    start: {\n      dts: baseMediaDecodeTime,\n      pts: baseMediaDecodeTime + ptsOffsetFromDts\n    },\n    end: {\n      dts: baseMediaDecodeTime + decodeDuration,\n      pts: baseMediaDecodeTime + presentationDuration\n    },\n    prependedContentDuration: prependedContentDuration,\n    baseMediaDecodeTime: baseMediaDecodeTime\n  };\n};\n\n/**\n * Constructs a single-track, ISO BMFF media segment from AAC data\n * events. The output of this stream can be fed to a SourceBuffer\n * configured with a suitable initialization segment.\n * @param track {object} track metadata configuration\n * @param options {object} transmuxer options object\n * @param options.keepOriginalTimestamps {boolean} If true, keep the timestamps\n *        in the source; false to adjust the first segment to start at 0.\n */\nAudioSegmentStream = function(track, options) {\n  var\n    adtsFrames = [],\n    sequenceNumber = 0,\n    earliestAllowedDts = 0,\n    audioAppendStartTs = 0,\n    videoBaseMediaDecodeTime = Infinity;\n\n  options = options || {};\n\n  AudioSegmentStream.prototype.init.call(this);\n\n  this.push = function(data) {\n    trackDecodeInfo.collectDtsInfo(track, data);\n\n    if (track) {\n      AUDIO_PROPERTIES.forEach(function(prop) {\n        track[prop] = data[prop];\n      });\n    }\n\n    // buffer audio data until end() is called\n    adtsFrames.push(data);\n  };\n\n  this.setEarliestDts = function(earliestDts) {\n    earliestAllowedDts = earliestDts - track.timelineStartInfo.baseMediaDecodeTime;\n  };\n\n  this.setVideoBaseMediaDecodeTime = function(baseMediaDecodeTime) {\n    videoBaseMediaDecodeTime = baseMediaDecodeTime;\n  };\n\n  this.setAudioAppendStart = function(timestamp) {\n    audioAppendStartTs = timestamp;\n  };\n\n  this.flush = function() {\n    var\n      frames,\n      moof,\n      mdat,\n      boxes;\n\n    // return early if no audio data has been observed\n    if (adtsFrames.length === 0) {\n      this.trigger('done', 'AudioSegmentStream');\n      return;\n    }\n\n    frames = audioFrameUtils.trimAdtsFramesByEarliestDts(\n      adtsFrames, track, earliestAllowedDts);\n    track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(\n      track, options.keepOriginalTimestamps);\n\n    audioFrameUtils.prefixWithSilence(\n      track, frames, audioAppendStartTs, videoBaseMediaDecodeTime);\n\n    // we have to build the index from byte locations to\n    // samples (that is, adts frames) in the audio data\n    track.samples = audioFrameUtils.generateSampleTable(frames);\n\n    // concatenate the audio data to constuct the mdat\n    mdat = mp4.mdat(audioFrameUtils.concatenateFrameData(frames));\n\n    adtsFrames = [];\n\n    moof = mp4.moof(sequenceNumber, [track]);\n    boxes = new Uint8Array(moof.byteLength + mdat.byteLength);\n\n    // bump the sequence number for next time\n    sequenceNumber++;\n\n    boxes.set(moof);\n    boxes.set(mdat, moof.byteLength);\n\n    trackDecodeInfo.clearDtsInfo(track);\n\n    this.trigger('data', {track: track, boxes: boxes});\n    this.trigger('done', 'AudioSegmentStream');\n  };\n};\n\nAudioSegmentStream.prototype = new Stream();\n\n/**\n * Constructs a single-track, ISO BMFF media segment from H264 data\n * events. The output of this stream can be fed to a SourceBuffer\n * configured with a suitable initialization segment.\n * @param track {object} track metadata configuration\n * @param options {object} transmuxer options object\n * @param options.alignGopsAtEnd {boolean} If true, start from the end of the\n *        gopsToAlignWith list when attempting to align gop pts\n * @param options.keepOriginalTimestamps {boolean} If true, keep the timestamps\n *        in the source; false to adjust the first segment to start at 0.\n */\nVideoSegmentStream = function(track, options) {\n  var\n    sequenceNumber = 0,\n    nalUnits = [],\n    gopsToAlignWith = [],\n    config,\n    pps;\n\n  options = options || {};\n\n  VideoSegmentStream.prototype.init.call(this);\n\n  delete track.minPTS;\n\n  this.gopCache_ = [];\n\n  /**\n    * Constructs a ISO BMFF segment given H264 nalUnits\n    * @param {Object} nalUnit A data event representing a nalUnit\n    * @param {String} nalUnit.nalUnitType\n    * @param {Object} nalUnit.config Properties for a mp4 track\n    * @param {Uint8Array} nalUnit.data The nalUnit bytes\n    * @see lib/codecs/h264.js\n   **/\n  this.push = function(nalUnit) {\n    trackDecodeInfo.collectDtsInfo(track, nalUnit);\n\n    // record the track config\n    if (nalUnit.nalUnitType === 'seq_parameter_set_rbsp' && !config) {\n      config = nalUnit.config;\n      track.sps = [nalUnit.data];\n\n      VIDEO_PROPERTIES.forEach(function(prop) {\n        track[prop] = config[prop];\n      }, this);\n    }\n\n    if (nalUnit.nalUnitType === 'pic_parameter_set_rbsp' &&\n        !pps) {\n      pps = nalUnit.data;\n      track.pps = [nalUnit.data];\n    }\n\n    // buffer video until flush() is called\n    nalUnits.push(nalUnit);\n  };\n\n  /**\n    * Pass constructed ISO BMFF track and boxes on to the\n    * next stream in the pipeline\n   **/\n  this.flush = function() {\n    var\n      frames,\n      gopForFusion,\n      gops,\n      moof,\n      mdat,\n      boxes,\n      prependedContentDuration = 0,\n      firstGop,\n      lastGop;\n\n    // Throw away nalUnits at the start of the byte stream until\n    // we find the first AUD\n    while (nalUnits.length) {\n      if (nalUnits[0].nalUnitType === 'access_unit_delimiter_rbsp') {\n        break;\n      }\n      nalUnits.shift();\n    }\n\n    // Return early if no video data has been observed\n    if (nalUnits.length === 0) {\n      this.resetStream_();\n      this.trigger('done', 'VideoSegmentStream');\n      return;\n    }\n\n    // Organize the raw nal-units into arrays that represent\n    // higher-level constructs such as frames and gops\n    // (group-of-pictures)\n    frames = frameUtils.groupNalsIntoFrames(nalUnits);\n    gops = frameUtils.groupFramesIntoGops(frames);\n\n    // If the first frame of this fragment is not a keyframe we have\n    // a problem since MSE (on Chrome) requires a leading keyframe.\n    //\n    // We have two approaches to repairing this situation:\n    // 1) GOP-FUSION:\n    //    This is where we keep track of the GOPS (group-of-pictures)\n    //    from previous fragments and attempt to find one that we can\n    //    prepend to the current fragment in order to create a valid\n    //    fragment.\n    // 2) KEYFRAME-PULLING:\n    //    Here we search for the first keyframe in the fragment and\n    //    throw away all the frames between the start of the fragment\n    //    and that keyframe. We then extend the duration and pull the\n    //    PTS of the keyframe forward so that it covers the time range\n    //    of the frames that were disposed of.\n    //\n    // #1 is far prefereable over #2 which can cause \"stuttering\" but\n    // requires more things to be just right.\n    if (!gops[0][0].keyFrame) {\n      // Search for a gop for fusion from our gopCache\n      gopForFusion = this.getGopForFusion_(nalUnits[0], track);\n\n      if (gopForFusion) {\n        // in order to provide more accurate timing information about the segment, save\n        // the number of seconds prepended to the original segment due to GOP fusion\n        prependedContentDuration = gopForFusion.duration;\n\n        gops.unshift(gopForFusion);\n        // Adjust Gops' metadata to account for the inclusion of the\n        // new gop at the beginning\n        gops.byteLength += gopForFusion.byteLength;\n        gops.nalCount += gopForFusion.nalCount;\n        gops.pts = gopForFusion.pts;\n        gops.dts = gopForFusion.dts;\n        gops.duration += gopForFusion.duration;\n      } else {\n        // If we didn't find a candidate gop fall back to keyframe-pulling\n        gops = frameUtils.extendFirstKeyFrame(gops);\n      }\n    }\n\n    // Trim gops to align with gopsToAlignWith\n    if (gopsToAlignWith.length) {\n      var alignedGops;\n\n      if (options.alignGopsAtEnd) {\n        alignedGops = this.alignGopsAtEnd_(gops);\n      } else {\n        alignedGops = this.alignGopsAtStart_(gops);\n      }\n\n      if (!alignedGops) {\n        // save all the nals in the last GOP into the gop cache\n        this.gopCache_.unshift({\n          gop: gops.pop(),\n          pps: track.pps,\n          sps: track.sps\n        });\n\n        // Keep a maximum of 6 GOPs in the cache\n        this.gopCache_.length = Math.min(6, this.gopCache_.length);\n\n        // Clear nalUnits\n        nalUnits = [];\n\n        // return early no gops can be aligned with desired gopsToAlignWith\n        this.resetStream_();\n        this.trigger('done', 'VideoSegmentStream');\n        return;\n      }\n\n      // Some gops were trimmed. clear dts info so minSegmentDts and pts are correct\n      // when recalculated before sending off to CoalesceStream\n      trackDecodeInfo.clearDtsInfo(track);\n\n      gops = alignedGops;\n    }\n\n    trackDecodeInfo.collectDtsInfo(track, gops);\n\n    // First, we have to build the index from byte locations to\n    // samples (that is, frames) in the video data\n    track.samples = frameUtils.generateSampleTable(gops);\n\n    // Concatenate the video data and construct the mdat\n    mdat = mp4.mdat(frameUtils.concatenateNalData(gops));\n\n    track.baseMediaDecodeTime = trackDecodeInfo.calculateTrackBaseMediaDecodeTime(\n      track, options.keepOriginalTimestamps);\n\n    this.trigger('processedGopsInfo', gops.map(function(gop) {\n      return {\n        pts: gop.pts,\n        dts: gop.dts,\n        byteLength: gop.byteLength\n      };\n    }));\n\n    firstGop = gops[0];\n    lastGop = gops[gops.length - 1];\n\n    this.trigger(\n      'segmentTimingInfo',\n      generateVideoSegmentTimingInfo(\n        track.baseMediaDecodeTime,\n        firstGop.dts,\n        firstGop.pts,\n        lastGop.dts + lastGop.duration,\n        lastGop.pts + lastGop.duration,\n        prependedContentDuration));\n\n    // save all the nals in the last GOP into the gop cache\n    this.gopCache_.unshift({\n      gop: gops.pop(),\n      pps: track.pps,\n      sps: track.sps\n    });\n\n    // Keep a maximum of 6 GOPs in the cache\n    this.gopCache_.length = Math.min(6, this.gopCache_.length);\n\n    // Clear nalUnits\n    nalUnits = [];\n\n    this.trigger('baseMediaDecodeTime', track.baseMediaDecodeTime);\n    this.trigger('timelineStartInfo', track.timelineStartInfo);\n\n    moof = mp4.moof(sequenceNumber, [track]);\n\n    // it would be great to allocate this array up front instead of\n    // throwing away hundreds of media segment fragments\n    boxes = new Uint8Array(moof.byteLength + mdat.byteLength);\n\n    // Bump the sequence number for next time\n    sequenceNumber++;\n\n    boxes.set(moof);\n    boxes.set(mdat, moof.byteLength);\n\n    this.trigger('data', {track: track, boxes: boxes});\n\n    this.resetStream_();\n\n    // Continue with the flush process now\n    this.trigger('done', 'VideoSegmentStream');\n  };\n\n  this.resetStream_ = function() {\n    trackDecodeInfo.clearDtsInfo(track);\n\n    // reset config and pps because they may differ across segments\n    // for instance, when we are rendition switching\n    config = undefined;\n    pps = undefined;\n  };\n\n  // Search for a candidate Gop for gop-fusion from the gop cache and\n  // return it or return null if no good candidate was found\n  this.getGopForFusion_ = function(nalUnit) {\n    var\n      halfSecond = 45000, // Half-a-second in a 90khz clock\n      allowableOverlap = 10000, // About 3 frames @ 30fps\n      nearestDistance = Infinity,\n      dtsDistance,\n      nearestGopObj,\n      currentGop,\n      currentGopObj,\n      i;\n\n    // Search for the GOP nearest to the beginning of this nal unit\n    for (i = 0; i < this.gopCache_.length; i++) {\n      currentGopObj = this.gopCache_[i];\n      currentGop = currentGopObj.gop;\n\n      // Reject Gops with different SPS or PPS\n      if (!(track.pps && arrayEquals(track.pps[0], currentGopObj.pps[0])) ||\n          !(track.sps && arrayEquals(track.sps[0], currentGopObj.sps[0]))) {\n        continue;\n      }\n\n      // Reject Gops that would require a negative baseMediaDecodeTime\n      if (currentGop.dts < track.timelineStartInfo.dts) {\n        continue;\n      }\n\n      // The distance between the end of the gop and the start of the nalUnit\n      dtsDistance = (nalUnit.dts - currentGop.dts) - currentGop.duration;\n\n      // Only consider GOPS that start before the nal unit and end within\n      // a half-second of the nal unit\n      if (dtsDistance >= -allowableOverlap &&\n          dtsDistance <= halfSecond) {\n\n        // Always use the closest GOP we found if there is more than\n        // one candidate\n        if (!nearestGopObj ||\n            nearestDistance > dtsDistance) {\n          nearestGopObj = currentGopObj;\n          nearestDistance = dtsDistance;\n        }\n      }\n    }\n\n    if (nearestGopObj) {\n      return nearestGopObj.gop;\n    }\n    return null;\n  };\n\n  // trim gop list to the first gop found that has a matching pts with a gop in the list\n  // of gopsToAlignWith starting from the START of the list\n  this.alignGopsAtStart_ = function(gops) {\n    var alignIndex, gopIndex, align, gop, byteLength, nalCount, duration, alignedGops;\n\n    byteLength = gops.byteLength;\n    nalCount = gops.nalCount;\n    duration = gops.duration;\n    alignIndex = gopIndex = 0;\n\n    while (alignIndex < gopsToAlignWith.length && gopIndex < gops.length) {\n      align = gopsToAlignWith[alignIndex];\n      gop = gops[gopIndex];\n\n      if (align.pts === gop.pts) {\n        break;\n      }\n\n      if (gop.pts > align.pts) {\n        // this current gop starts after the current gop we want to align on, so increment\n        // align index\n        alignIndex++;\n        continue;\n      }\n\n      // current gop starts before the current gop we want to align on. so increment gop\n      // index\n      gopIndex++;\n      byteLength -= gop.byteLength;\n      nalCount -= gop.nalCount;\n      duration -= gop.duration;\n    }\n\n    if (gopIndex === 0) {\n      // no gops to trim\n      return gops;\n    }\n\n    if (gopIndex === gops.length) {\n      // all gops trimmed, skip appending all gops\n      return null;\n    }\n\n    alignedGops = gops.slice(gopIndex);\n    alignedGops.byteLength = byteLength;\n    alignedGops.duration = duration;\n    alignedGops.nalCount = nalCount;\n    alignedGops.pts = alignedGops[0].pts;\n    alignedGops.dts = alignedGops[0].dts;\n\n    return alignedGops;\n  };\n\n  // trim gop list to the first gop found that has a matching pts with a gop in the list\n  // of gopsToAlignWith starting from the END of the list\n  this.alignGopsAtEnd_ = function(gops) {\n    var alignIndex, gopIndex, align, gop, alignEndIndex, matchFound;\n\n    alignIndex = gopsToAlignWith.length - 1;\n    gopIndex = gops.length - 1;\n    alignEndIndex = null;\n    matchFound = false;\n\n    while (alignIndex >= 0 && gopIndex >= 0) {\n      align = gopsToAlignWith[alignIndex];\n      gop = gops[gopIndex];\n\n      if (align.pts === gop.pts) {\n        matchFound = true;\n        break;\n      }\n\n      if (align.pts > gop.pts) {\n        alignIndex--;\n        continue;\n      }\n\n      if (alignIndex === gopsToAlignWith.length - 1) {\n        // gop.pts is greater than the last alignment candidate. If no match is found\n        // by the end of this loop, we still want to append gops that come after this\n        // point\n        alignEndIndex = gopIndex;\n      }\n\n      gopIndex--;\n    }\n\n    if (!matchFound && alignEndIndex === null) {\n      return null;\n    }\n\n    var trimIndex;\n\n    if (matchFound) {\n      trimIndex = gopIndex;\n    } else {\n      trimIndex = alignEndIndex;\n    }\n\n    if (trimIndex === 0) {\n      return gops;\n    }\n\n    var alignedGops = gops.slice(trimIndex);\n    var metadata = alignedGops.reduce(function(total, gop) {\n      total.byteLength += gop.byteLength;\n      total.duration += gop.duration;\n      total.nalCount += gop.nalCount;\n      return total;\n    }, { byteLength: 0, duration: 0, nalCount: 0 });\n\n    alignedGops.byteLength = metadata.byteLength;\n    alignedGops.duration = metadata.duration;\n    alignedGops.nalCount = metadata.nalCount;\n    alignedGops.pts = alignedGops[0].pts;\n    alignedGops.dts = alignedGops[0].dts;\n\n    return alignedGops;\n  };\n\n  this.alignGopsWith = function(newGopsToAlignWith) {\n    gopsToAlignWith = newGopsToAlignWith;\n  };\n};\n\nVideoSegmentStream.prototype = new Stream();\n\n/**\n * A Stream that can combine multiple streams (ie. audio & video)\n * into a single output segment for MSE. Also supports audio-only\n * and video-only streams.\n * @param options {object} transmuxer options object\n * @param options.keepOriginalTimestamps {boolean} If true, keep the timestamps\n *        in the source; false to adjust the first segment to start at media timeline start.\n */\nCoalesceStream = function(options, metadataStream) {\n  // Number of Tracks per output segment\n  // If greater than 1, we combine multiple\n  // tracks into a single segment\n  this.numberOfTracks = 0;\n  this.metadataStream = metadataStream;\n\n  options = options || {};\n\n  if (typeof options.remux !== 'undefined') {\n    this.remuxTracks = !!options.remux;\n  } else {\n    this.remuxTracks = true;\n  }\n\n  if (typeof options.keepOriginalTimestamps === 'boolean') {\n    this.keepOriginalTimestamps = options.keepOriginalTimestamps;\n  }\n\n  this.pendingTracks = [];\n  this.videoTrack = null;\n  this.pendingBoxes = [];\n  this.pendingCaptions = [];\n  this.pendingMetadata = [];\n  this.pendingBytes = 0;\n  this.emittedTracks = 0;\n\n  CoalesceStream.prototype.init.call(this);\n\n  // Take output from multiple\n  this.push = function(output) {\n    // buffer incoming captions until the associated video segment\n    // finishes\n    if (output.text) {\n      return this.pendingCaptions.push(output);\n    }\n    // buffer incoming id3 tags until the final flush\n    if (output.frames) {\n      return this.pendingMetadata.push(output);\n    }\n\n    // Add this track to the list of pending tracks and store\n    // important information required for the construction of\n    // the final segment\n    this.pendingTracks.push(output.track);\n    this.pendingBoxes.push(output.boxes);\n    this.pendingBytes += output.boxes.byteLength;\n\n    if (output.track.type === 'video') {\n      this.videoTrack = output.track;\n    }\n    if (output.track.type === 'audio') {\n      this.audioTrack = output.track;\n    }\n  };\n};\n\nCoalesceStream.prototype = new Stream();\nCoalesceStream.prototype.flush = function(flushSource) {\n  var\n    offset = 0,\n    event = {\n      captions: [],\n      captionStreams: {},\n      metadata: [],\n      info: {}\n    },\n    caption,\n    id3,\n    initSegment,\n    timelineStartPts = 0,\n    i;\n\n  if (this.pendingTracks.length < this.numberOfTracks) {\n    if (flushSource !== 'VideoSegmentStream' &&\n        flushSource !== 'AudioSegmentStream') {\n      // Return because we haven't received a flush from a data-generating\n      // portion of the segment (meaning that we have only recieved meta-data\n      // or captions.)\n      return;\n    } else if (this.remuxTracks) {\n      // Return until we have enough tracks from the pipeline to remux (if we\n      // are remuxing audio and video into a single MP4)\n      return;\n    } else if (this.pendingTracks.length === 0) {\n      // In the case where we receive a flush without any data having been\n      // received we consider it an emitted track for the purposes of coalescing\n      // `done` events.\n      // We do this for the case where there is an audio and video track in the\n      // segment but no audio data. (seen in several playlists with alternate\n      // audio tracks and no audio present in the main TS segments.)\n      this.emittedTracks++;\n\n      if (this.emittedTracks >= this.numberOfTracks) {\n        this.trigger('done');\n        this.emittedTracks = 0;\n      }\n      return;\n    }\n  }\n\n  if (this.videoTrack) {\n    timelineStartPts = this.videoTrack.timelineStartInfo.pts;\n    VIDEO_PROPERTIES.forEach(function(prop) {\n      event.info[prop] = this.videoTrack[prop];\n    }, this);\n  } else if (this.audioTrack) {\n    timelineStartPts = this.audioTrack.timelineStartInfo.pts;\n    AUDIO_PROPERTIES.forEach(function(prop) {\n      event.info[prop] = this.audioTrack[prop];\n    }, this);\n  }\n\n  if (this.pendingTracks.length === 1) {\n    event.type = this.pendingTracks[0].type;\n  } else {\n    event.type = 'combined';\n  }\n\n  this.emittedTracks += this.pendingTracks.length;\n\n  initSegment = mp4.initSegment(this.pendingTracks);\n\n  // Create a new typed array to hold the init segment\n  event.initSegment = new Uint8Array(initSegment.byteLength);\n\n  // Create an init segment containing a moov\n  // and track definitions\n  event.initSegment.set(initSegment);\n\n  // Create a new typed array to hold the moof+mdats\n  event.data = new Uint8Array(this.pendingBytes);\n\n  // Append each moof+mdat (one per track) together\n  for (i = 0; i < this.pendingBoxes.length; i++) {\n    event.data.set(this.pendingBoxes[i], offset);\n    offset += this.pendingBoxes[i].byteLength;\n  }\n\n  // Translate caption PTS times into second offsets to match the\n  // video timeline for the segment, and add track info\n  for (i = 0; i < this.pendingCaptions.length; i++) {\n    caption = this.pendingCaptions[i];\n\n    caption.startTime = caption.startPts;\n    if (!this.keepOriginalTimestamps) {\n      caption.startTime -= timelineStartPts;\n    }\n    caption.startTime /= 90e3;\n\n    caption.endTime = caption.endPts;\n    if (!this.keepOriginalTimestamps) {\n      caption.endTime -= timelineStartPts;\n    }\n    caption.endTime /= 90e3;\n\n    event.captionStreams[caption.stream] = true;\n    event.captions.push(caption);\n  }\n\n  // Translate ID3 frame PTS times into second offsets to match the\n  // video timeline for the segment\n  for (i = 0; i < this.pendingMetadata.length; i++) {\n    id3 = this.pendingMetadata[i];\n\n    id3.cueTime = id3.pts;\n    if (!this.keepOriginalTimestamps) {\n      id3.cueTime -= timelineStartPts;\n    }\n    id3.cueTime /= 90e3;\n\n    event.metadata.push(id3);\n  }\n\n  // We add this to every single emitted segment even though we only need\n  // it for the first\n  event.metadata.dispatchType = this.metadataStream.dispatchType;\n\n  // Reset stream state\n  this.pendingTracks.length = 0;\n  this.videoTrack = null;\n  this.pendingBoxes.length = 0;\n  this.pendingCaptions.length = 0;\n  this.pendingBytes = 0;\n  this.pendingMetadata.length = 0;\n\n  // Emit the built segment\n  this.trigger('data', event);\n\n  // Only emit `done` if all tracks have been flushed and emitted\n  if (this.emittedTracks >= this.numberOfTracks) {\n    this.trigger('done');\n    this.emittedTracks = 0;\n  }\n};\n/**\n * A Stream that expects MP2T binary data as input and produces\n * corresponding media segments, suitable for use with Media Source\n * Extension (MSE) implementations that support the ISO BMFF byte\n * stream format, like Chrome.\n */\nTransmuxer = function(options) {\n  var\n    self = this,\n    hasFlushed = true,\n    videoTrack,\n    audioTrack;\n\n  Transmuxer.prototype.init.call(this);\n\n  options = options || {};\n  this.baseMediaDecodeTime = options.baseMediaDecodeTime || 0;\n  this.transmuxPipeline_ = {};\n\n  this.setupAacPipeline = function() {\n    var pipeline = {};\n    this.transmuxPipeline_ = pipeline;\n\n    pipeline.type = 'aac';\n    pipeline.metadataStream = new m2ts.MetadataStream();\n\n    // set up the parsing pipeline\n    pipeline.aacStream = new AacStream();\n    pipeline.audioTimestampRolloverStream = new m2ts.TimestampRolloverStream('audio');\n    pipeline.timedMetadataTimestampRolloverStream = new m2ts.TimestampRolloverStream('timed-metadata');\n    pipeline.adtsStream = new AdtsStream();\n    pipeline.coalesceStream = new CoalesceStream(options, pipeline.metadataStream);\n    pipeline.headOfPipeline = pipeline.aacStream;\n\n    pipeline.aacStream\n      .pipe(pipeline.audioTimestampRolloverStream)\n      .pipe(pipeline.adtsStream);\n    pipeline.aacStream\n      .pipe(pipeline.timedMetadataTimestampRolloverStream)\n      .pipe(pipeline.metadataStream)\n      .pipe(pipeline.coalesceStream);\n\n    pipeline.metadataStream.on('timestamp', function(frame) {\n      pipeline.aacStream.setTimestamp(frame.timeStamp);\n    });\n\n    pipeline.aacStream.on('data', function(data) {\n      if (data.type === 'timed-metadata' && !pipeline.audioSegmentStream) {\n        audioTrack = audioTrack || {\n          timelineStartInfo: {\n            baseMediaDecodeTime: self.baseMediaDecodeTime\n          },\n          codec: 'adts',\n          type: 'audio'\n        };\n        // hook up the audio segment stream to the first track with aac data\n        pipeline.coalesceStream.numberOfTracks++;\n        pipeline.audioSegmentStream = new AudioSegmentStream(audioTrack, options);\n        // Set up the final part of the audio pipeline\n        pipeline.adtsStream\n          .pipe(pipeline.audioSegmentStream)\n          .pipe(pipeline.coalesceStream);\n      }\n    });\n\n    // Re-emit any data coming from the coalesce stream to the outside world\n    pipeline.coalesceStream.on('data', this.trigger.bind(this, 'data'));\n    // Let the consumer know we have finished flushing the entire pipeline\n    pipeline.coalesceStream.on('done', this.trigger.bind(this, 'done'));\n  };\n\n  this.setupTsPipeline = function() {\n    var pipeline = {};\n    this.transmuxPipeline_ = pipeline;\n\n    pipeline.type = 'ts';\n    pipeline.metadataStream = new m2ts.MetadataStream();\n\n    // set up the parsing pipeline\n    pipeline.packetStream = new m2ts.TransportPacketStream();\n    pipeline.parseStream = new m2ts.TransportParseStream();\n    pipeline.elementaryStream = new m2ts.ElementaryStream();\n    pipeline.videoTimestampRolloverStream = new m2ts.TimestampRolloverStream('video');\n    pipeline.audioTimestampRolloverStream = new m2ts.TimestampRolloverStream('audio');\n    pipeline.timedMetadataTimestampRolloverStream = new m2ts.TimestampRolloverStream('timed-metadata');\n    pipeline.adtsStream = new AdtsStream();\n    pipeline.h264Stream = new H264Stream();\n    pipeline.captionStream = new m2ts.CaptionStream();\n    pipeline.coalesceStream = new CoalesceStream(options, pipeline.metadataStream);\n    pipeline.headOfPipeline = pipeline.packetStream;\n\n    // disassemble MPEG2-TS packets into elementary streams\n    pipeline.packetStream\n      .pipe(pipeline.parseStream)\n      .pipe(pipeline.elementaryStream);\n\n    // !!THIS ORDER IS IMPORTANT!!\n    // demux the streams\n    pipeline.elementaryStream\n      .pipe(pipeline.videoTimestampRolloverStream)\n      .pipe(pipeline.h264Stream);\n    pipeline.elementaryStream\n      .pipe(pipeline.audioTimestampRolloverStream)\n      .pipe(pipeline.adtsStream);\n\n    pipeline.elementaryStream\n      .pipe(pipeline.timedMetadataTimestampRolloverStream)\n      .pipe(pipeline.metadataStream)\n      .pipe(pipeline.coalesceStream);\n\n    // Hook up CEA-608/708 caption stream\n    pipeline.h264Stream.pipe(pipeline.captionStream)\n      .pipe(pipeline.coalesceStream);\n\n    pipeline.elementaryStream.on('data', function(data) {\n      var i;\n\n      if (data.type === 'metadata') {\n        i = data.tracks.length;\n\n        // scan the tracks listed in the metadata\n        while (i--) {\n          if (!videoTrack && data.tracks[i].type === 'video') {\n            videoTrack = data.tracks[i];\n            videoTrack.timelineStartInfo.baseMediaDecodeTime = self.baseMediaDecodeTime;\n          } else if (!audioTrack && data.tracks[i].type === 'audio') {\n            audioTrack = data.tracks[i];\n            audioTrack.timelineStartInfo.baseMediaDecodeTime = self.baseMediaDecodeTime;\n          }\n        }\n\n        // hook up the video segment stream to the first track with h264 data\n        if (videoTrack && !pipeline.videoSegmentStream) {\n          pipeline.coalesceStream.numberOfTracks++;\n          pipeline.videoSegmentStream = new VideoSegmentStream(videoTrack, options);\n\n          pipeline.videoSegmentStream.on('timelineStartInfo', function(timelineStartInfo) {\n          // When video emits timelineStartInfo data after a flush, we forward that\n          // info to the AudioSegmentStream, if it exists, because video timeline\n          // data takes precedence.\n            if (audioTrack) {\n              audioTrack.timelineStartInfo = timelineStartInfo;\n              // On the first segment we trim AAC frames that exist before the\n              // very earliest DTS we have seen in video because Chrome will\n              // interpret any video track with a baseMediaDecodeTime that is\n              // non-zero as a gap.\n              pipeline.audioSegmentStream.setEarliestDts(timelineStartInfo.dts);\n            }\n          });\n\n          pipeline.videoSegmentStream.on('processedGopsInfo',\n            self.trigger.bind(self, 'gopInfo'));\n          pipeline.videoSegmentStream.on('segmentTimingInfo',\n            self.trigger.bind(self, 'videoSegmentTimingInfo'));\n\n          pipeline.videoSegmentStream.on('baseMediaDecodeTime', function(baseMediaDecodeTime) {\n            if (audioTrack) {\n              pipeline.audioSegmentStream.setVideoBaseMediaDecodeTime(baseMediaDecodeTime);\n            }\n          });\n\n          // Set up the final part of the video pipeline\n          pipeline.h264Stream\n            .pipe(pipeline.videoSegmentStream)\n            .pipe(pipeline.coalesceStream);\n        }\n\n        if (audioTrack && !pipeline.audioSegmentStream) {\n          // hook up the audio segment stream to the first track with aac data\n          pipeline.coalesceStream.numberOfTracks++;\n          pipeline.audioSegmentStream = new AudioSegmentStream(audioTrack, options);\n\n          // Set up the final part of the audio pipeline\n          pipeline.adtsStream\n            .pipe(pipeline.audioSegmentStream)\n            .pipe(pipeline.coalesceStream);\n        }\n      }\n    });\n\n    // Re-emit any data coming from the coalesce stream to the outside world\n    pipeline.coalesceStream.on('data', this.trigger.bind(this, 'data'));\n    // Let the consumer know we have finished flushing the entire pipeline\n    pipeline.coalesceStream.on('done', this.trigger.bind(this, 'done'));\n  };\n\n  // hook up the segment streams once track metadata is delivered\n  this.setBaseMediaDecodeTime = function(baseMediaDecodeTime) {\n    var pipeline = this.transmuxPipeline_;\n\n    if (!options.keepOriginalTimestamps) {\n      this.baseMediaDecodeTime = baseMediaDecodeTime;\n    }\n\n    if (audioTrack) {\n      audioTrack.timelineStartInfo.dts = undefined;\n      audioTrack.timelineStartInfo.pts = undefined;\n      trackDecodeInfo.clearDtsInfo(audioTrack);\n      if (!options.keepOriginalTimestamps) {\n        audioTrack.timelineStartInfo.baseMediaDecodeTime = baseMediaDecodeTime;\n      }\n      if (pipeline.audioTimestampRolloverStream) {\n        pipeline.audioTimestampRolloverStream.discontinuity();\n      }\n    }\n    if (videoTrack) {\n      if (pipeline.videoSegmentStream) {\n        pipeline.videoSegmentStream.gopCache_ = [];\n        pipeline.videoTimestampRolloverStream.discontinuity();\n      }\n      videoTrack.timelineStartInfo.dts = undefined;\n      videoTrack.timelineStartInfo.pts = undefined;\n      trackDecodeInfo.clearDtsInfo(videoTrack);\n      pipeline.captionStream.reset();\n      if (!options.keepOriginalTimestamps) {\n        videoTrack.timelineStartInfo.baseMediaDecodeTime = baseMediaDecodeTime;\n      }\n    }\n\n    if (pipeline.timedMetadataTimestampRolloverStream) {\n      pipeline.timedMetadataTimestampRolloverStream.discontinuity();\n    }\n  };\n\n  this.setAudioAppendStart = function(timestamp) {\n    if (audioTrack) {\n      this.transmuxPipeline_.audioSegmentStream.setAudioAppendStart(timestamp);\n    }\n  };\n\n  this.alignGopsWith = function(gopsToAlignWith) {\n    if (videoTrack && this.transmuxPipeline_.videoSegmentStream) {\n      this.transmuxPipeline_.videoSegmentStream.alignGopsWith(gopsToAlignWith);\n    }\n  };\n\n  // feed incoming data to the front of the parsing pipeline\n  this.push = function(data) {\n    if (hasFlushed) {\n      var isAac = isLikelyAacData(data);\n\n      if (isAac && this.transmuxPipeline_.type !== 'aac') {\n        this.setupAacPipeline();\n      } else if (!isAac && this.transmuxPipeline_.type !== 'ts') {\n        this.setupTsPipeline();\n      }\n      hasFlushed = false;\n    }\n    this.transmuxPipeline_.headOfPipeline.push(data);\n  };\n\n  // flush any buffered data\n  this.flush = function() {\n      hasFlushed = true;\n    // Start at the top of the pipeline and flush all pending work\n    this.transmuxPipeline_.headOfPipeline.flush();\n  };\n\n  // Caption data has to be reset when seeking outside buffered range\n  this.resetCaptions = function() {\n    if (this.transmuxPipeline_.captionStream) {\n      this.transmuxPipeline_.captionStream.reset();\n    }\n  };\n\n};\nTransmuxer.prototype = new Stream();\n\nmodule.exports = {\n  Transmuxer: Transmuxer,\n  VideoSegmentStream: VideoSegmentStream,\n  AudioSegmentStream: AudioSegmentStream,\n  AUDIO_PROPERTIES: AUDIO_PROPERTIES,\n  VIDEO_PROPERTIES: VIDEO_PROPERTIES,\n  // exported for testing\n  generateVideoSegmentTimingInfo: generateVideoSegmentTimingInfo\n};\n","/**\n * mux.js\n *\n * Copyright (c) 2015 Brightcove\n * All rights reserved.\n *\n * A stream-based mp2t to mp4 converter. This utility can be used to\n * deliver mp4s to a SourceBuffer on platforms that support native\n * Media Source Extensions.\n */\n'use strict';\nvar Stream = require('../utils/stream.js'),\n  CaptionStream = require('./caption-stream'),\n  StreamTypes = require('./stream-types'),\n  TimestampRolloverStream = require('./timestamp-rollover-stream').TimestampRolloverStream;\n\nvar m2tsStreamTypes = require('./stream-types.js');\n\n// object types\nvar TransportPacketStream, TransportParseStream, ElementaryStream;\n\n// constants\nvar\n  MP2T_PACKET_LENGTH = 188, // bytes\n  SYNC_BYTE = 0x47;\n\n/**\n * Splits an incoming stream of binary data into MPEG-2 Transport\n * Stream packets.\n */\nTransportPacketStream = function() {\n  var\n    buffer = new Uint8Array(MP2T_PACKET_LENGTH),\n    bytesInBuffer = 0;\n\n  TransportPacketStream.prototype.init.call(this);\n\n   // Deliver new bytes to the stream.\n\n  /**\n   * Split a stream of data into M2TS packets\n  **/\n  this.push = function(bytes) {\n    var\n      startIndex = 0,\n      endIndex = MP2T_PACKET_LENGTH,\n      everything;\n\n    // If there are bytes remaining from the last segment, prepend them to the\n    // bytes that were pushed in\n    if (bytesInBuffer) {\n      everything = new Uint8Array(bytes.byteLength + bytesInBuffer);\n      everything.set(buffer.subarray(0, bytesInBuffer));\n      everything.set(bytes, bytesInBuffer);\n      bytesInBuffer = 0;\n    } else {\n      everything = bytes;\n    }\n\n    // While we have enough data for a packet\n    while (endIndex < everything.byteLength) {\n      // Look for a pair of start and end sync bytes in the data..\n      if (everything[startIndex] === SYNC_BYTE && everything[endIndex] === SYNC_BYTE) {\n        // We found a packet so emit it and jump one whole packet forward in\n        // the stream\n        this.trigger('data', everything.subarray(startIndex, endIndex));\n        startIndex += MP2T_PACKET_LENGTH;\n        endIndex += MP2T_PACKET_LENGTH;\n        continue;\n      }\n      // If we get here, we have somehow become de-synchronized and we need to step\n      // forward one byte at a time until we find a pair of sync bytes that denote\n      // a packet\n      startIndex++;\n      endIndex++;\n    }\n\n    // If there was some data left over at the end of the segment that couldn't\n    // possibly be a whole packet, keep it because it might be the start of a packet\n    // that continues in the next segment\n    if (startIndex < everything.byteLength) {\n      buffer.set(everything.subarray(startIndex), 0);\n      bytesInBuffer = everything.byteLength - startIndex;\n    }\n  };\n\n  /**\n   * Passes identified M2TS packets to the TransportParseStream to be parsed\n  **/\n  this.flush = function() {\n    // If the buffer contains a whole packet when we are being flushed, emit it\n    // and empty the buffer. Otherwise hold onto the data because it may be\n    // important for decoding the next segment\n    if (bytesInBuffer === MP2T_PACKET_LENGTH && buffer[0] === SYNC_BYTE) {\n      this.trigger('data', buffer);\n      bytesInBuffer = 0;\n    }\n    this.trigger('done');\n  };\n};\nTransportPacketStream.prototype = new Stream();\n\n/**\n * Accepts an MP2T TransportPacketStream and emits data events with parsed\n * forms of the individual transport stream packets.\n */\nTransportParseStream = function() {\n  var parsePsi, parsePat, parsePmt, self;\n  TransportParseStream.prototype.init.call(this);\n  self = this;\n\n  this.packetsWaitingForPmt = [];\n  this.programMapTable = undefined;\n\n  parsePsi = function(payload, psi) {\n    var offset = 0;\n\n    // PSI packets may be split into multiple sections and those\n    // sections may be split into multiple packets. If a PSI\n    // section starts in this packet, the payload_unit_start_indicator\n    // will be true and the first byte of the payload will indicate\n    // the offset from the current position to the start of the\n    // section.\n    if (psi.payloadUnitStartIndicator) {\n      offset += payload[offset] + 1;\n    }\n\n    if (psi.type === 'pat') {\n      parsePat(payload.subarray(offset), psi);\n    } else {\n      parsePmt(payload.subarray(offset), psi);\n    }\n  };\n\n  parsePat = function(payload, pat) {\n    pat.section_number = payload[7]; // eslint-disable-line camelcase\n    pat.last_section_number = payload[8]; // eslint-disable-line camelcase\n\n    // skip the PSI header and parse the first PMT entry\n    self.pmtPid = (payload[10] & 0x1F) << 8 | payload[11];\n    pat.pmtPid = self.pmtPid;\n  };\n\n  /**\n   * Parse out the relevant fields of a Program Map Table (PMT).\n   * @param payload {Uint8Array} the PMT-specific portion of an MP2T\n   * packet. The first byte in this array should be the table_id\n   * field.\n   * @param pmt {object} the object that should be decorated with\n   * fields parsed from the PMT.\n   */\n  parsePmt = function(payload, pmt) {\n    var sectionLength, tableEnd, programInfoLength, offset;\n\n    // PMTs can be sent ahead of the time when they should actually\n    // take effect. We don't believe this should ever be the case\n    // for HLS but we'll ignore \"forward\" PMT declarations if we see\n    // them. Future PMT declarations have the current_next_indicator\n    // set to zero.\n    if (!(payload[5] & 0x01)) {\n      return;\n    }\n\n    // overwrite any existing program map table\n    self.programMapTable = {\n      video: null,\n      audio: null,\n      'timed-metadata': {}\n    };\n\n    // the mapping table ends at the end of the current section\n    sectionLength = (payload[1] & 0x0f) << 8 | payload[2];\n    tableEnd = 3 + sectionLength - 4;\n\n    // to determine where the table is, we have to figure out how\n    // long the program info descriptors are\n    programInfoLength = (payload[10] & 0x0f) << 8 | payload[11];\n\n    // advance the offset to the first entry in the mapping table\n    offset = 12 + programInfoLength;\n    while (offset < tableEnd) {\n      var streamType = payload[offset];\n      var pid = (payload[offset + 1] & 0x1F) << 8 | payload[offset + 2];\n\n      // only map a single elementary_pid for audio and video stream types\n      // TODO: should this be done for metadata too? for now maintain behavior of\n      //       multiple metadata streams\n      if (streamType === StreamTypes.H264_STREAM_TYPE &&\n          self.programMapTable.video === null) {\n        self.programMapTable.video = pid;\n      } else if (streamType === StreamTypes.ADTS_STREAM_TYPE &&\n                 self.programMapTable.audio === null) {\n        self.programMapTable.audio = pid;\n      } else if (streamType === StreamTypes.METADATA_STREAM_TYPE) {\n        // map pid to stream type for metadata streams\n        self.programMapTable['timed-metadata'][pid] = streamType;\n      }\n\n      // move to the next table entry\n      // skip past the elementary stream descriptors, if present\n      offset += ((payload[offset + 3] & 0x0F) << 8 | payload[offset + 4]) + 5;\n    }\n\n    // record the map on the packet as well\n    pmt.programMapTable = self.programMapTable;\n  };\n\n  /**\n   * Deliver a new MP2T packet to the next stream in the pipeline.\n   */\n  this.push = function(packet) {\n    var\n      result = {},\n      offset = 4;\n\n    result.payloadUnitStartIndicator = !!(packet[1] & 0x40);\n\n    // pid is a 13-bit field starting at the last bit of packet[1]\n    result.pid = packet[1] & 0x1f;\n    result.pid <<= 8;\n    result.pid |= packet[2];\n\n    // if an adaption field is present, its length is specified by the\n    // fifth byte of the TS packet header. The adaptation field is\n    // used to add stuffing to PES packets that don't fill a complete\n    // TS packet, and to specify some forms of timing and control data\n    // that we do not currently use.\n    if (((packet[3] & 0x30) >>> 4) > 0x01) {\n      offset += packet[offset] + 1;\n    }\n\n    // parse the rest of the packet based on the type\n    if (result.pid === 0) {\n      result.type = 'pat';\n      parsePsi(packet.subarray(offset), result);\n      this.trigger('data', result);\n    } else if (result.pid === this.pmtPid) {\n      result.type = 'pmt';\n      parsePsi(packet.subarray(offset), result);\n      this.trigger('data', result);\n\n      // if there are any packets waiting for a PMT to be found, process them now\n      while (this.packetsWaitingForPmt.length) {\n        this.processPes_.apply(this, this.packetsWaitingForPmt.shift());\n      }\n    } else if (this.programMapTable === undefined) {\n      // When we have not seen a PMT yet, defer further processing of\n      // PES packets until one has been parsed\n      this.packetsWaitingForPmt.push([packet, offset, result]);\n    } else {\n      this.processPes_(packet, offset, result);\n    }\n  };\n\n  this.processPes_ = function(packet, offset, result) {\n    // set the appropriate stream type\n    if (result.pid === this.programMapTable.video) {\n      result.streamType = StreamTypes.H264_STREAM_TYPE;\n    } else if (result.pid === this.programMapTable.audio) {\n      result.streamType = StreamTypes.ADTS_STREAM_TYPE;\n    } else {\n      // if not video or audio, it is timed-metadata or unknown\n      // if unknown, streamType will be undefined\n      result.streamType = this.programMapTable['timed-metadata'][result.pid];\n    }\n\n    result.type = 'pes';\n    result.data = packet.subarray(offset);\n\n    this.trigger('data', result);\n  };\n\n};\nTransportParseStream.prototype = new Stream();\nTransportParseStream.STREAM_TYPES  = {\n  h264: 0x1b,\n  adts: 0x0f\n};\n\n/**\n * Reconsistutes program elementary stream (PES) packets from parsed\n * transport stream packets. That is, if you pipe an\n * mp2t.TransportParseStream into a mp2t.ElementaryStream, the output\n * events will be events which capture the bytes for individual PES\n * packets plus relevant metadata that has been extracted from the\n * container.\n */\nElementaryStream = function() {\n  var\n    self = this,\n    // PES packet fragments\n    video = {\n      data: [],\n      size: 0\n    },\n    audio = {\n      data: [],\n      size: 0\n    },\n    timedMetadata = {\n      data: [],\n      size: 0\n    },\n    parsePes = function(payload, pes) {\n      var ptsDtsFlags;\n\n      // get the packet length, this will be 0 for video\n      pes.packetLength = 6 + ((payload[4] << 8) | payload[5]);\n\n      // find out if this packets starts a new keyframe\n      pes.dataAlignmentIndicator = (payload[6] & 0x04) !== 0;\n      // PES packets may be annotated with a PTS value, or a PTS value\n      // and a DTS value. Determine what combination of values is\n      // available to work with.\n      ptsDtsFlags = payload[7];\n\n      // PTS and DTS are normally stored as a 33-bit number.  Javascript\n      // performs all bitwise operations on 32-bit integers but javascript\n      // supports a much greater range (52-bits) of integer using standard\n      // mathematical operations.\n      // We construct a 31-bit value using bitwise operators over the 31\n      // most significant bits and then multiply by 4 (equal to a left-shift\n      // of 2) before we add the final 2 least significant bits of the\n      // timestamp (equal to an OR.)\n      if (ptsDtsFlags & 0xC0) {\n        // the PTS and DTS are not written out directly. For information\n        // on how they are encoded, see\n        // http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\n        pes.pts = (payload[9] & 0x0E) << 27 |\n          (payload[10] & 0xFF) << 20 |\n          (payload[11] & 0xFE) << 12 |\n          (payload[12] & 0xFF) <<  5 |\n          (payload[13] & 0xFE) >>>  3;\n        pes.pts *= 4; // Left shift by 2\n        pes.pts += (payload[13] & 0x06) >>> 1; // OR by the two LSBs\n        pes.dts = pes.pts;\n        if (ptsDtsFlags & 0x40) {\n          pes.dts = (payload[14] & 0x0E) << 27 |\n            (payload[15] & 0xFF) << 20 |\n            (payload[16] & 0xFE) << 12 |\n            (payload[17] & 0xFF) << 5 |\n            (payload[18] & 0xFE) >>> 3;\n          pes.dts *= 4; // Left shift by 2\n          pes.dts += (payload[18] & 0x06) >>> 1; // OR by the two LSBs\n        }\n      }\n      // the data section starts immediately after the PES header.\n      // pes_header_data_length specifies the number of header bytes\n      // that follow the last byte of the field.\n      pes.data = payload.subarray(9 + payload[8]);\n    },\n    /**\n      * Pass completely parsed PES packets to the next stream in the pipeline\n     **/\n    flushStream = function(stream, type, forceFlush) {\n      var\n        packetData = new Uint8Array(stream.size),\n        event = {\n          type: type\n        },\n        i = 0,\n        offset = 0,\n        packetFlushable = false,\n        fragment;\n\n      // do nothing if there is not enough buffered data for a complete\n      // PES header\n      if (!stream.data.length || stream.size < 9) {\n        return;\n      }\n      event.trackId = stream.data[0].pid;\n\n      // reassemble the packet\n      for (i = 0; i < stream.data.length; i++) {\n        fragment = stream.data[i];\n\n        packetData.set(fragment.data, offset);\n        offset += fragment.data.byteLength;\n      }\n\n      // parse assembled packet's PES header\n      parsePes(packetData, event);\n\n      // non-video PES packets MUST have a non-zero PES_packet_length\n      // check that there is enough stream data to fill the packet\n      packetFlushable = type === 'video' || event.packetLength <= stream.size;\n\n      // flush pending packets if the conditions are right\n      if (forceFlush || packetFlushable) {\n        stream.size = 0;\n        stream.data.length = 0;\n      }\n\n      // only emit packets that are complete. this is to avoid assembling\n      // incomplete PES packets due to poor segmentation\n      if (packetFlushable) {\n        self.trigger('data', event);\n      }\n    };\n\n  ElementaryStream.prototype.init.call(this);\n\n  /**\n   * Identifies M2TS packet types and parses PES packets using metadata\n   * parsed from the PMT\n   **/\n  this.push = function(data) {\n    ({\n      pat: function() {\n        // we have to wait for the PMT to arrive as well before we\n        // have any meaningful metadata\n      },\n      pes: function() {\n        var stream, streamType;\n\n        switch (data.streamType) {\n        case StreamTypes.H264_STREAM_TYPE:\n        case m2tsStreamTypes.H264_STREAM_TYPE:\n          stream = video;\n          streamType = 'video';\n          break;\n        case StreamTypes.ADTS_STREAM_TYPE:\n          stream = audio;\n          streamType = 'audio';\n          break;\n        case StreamTypes.METADATA_STREAM_TYPE:\n          stream = timedMetadata;\n          streamType = 'timed-metadata';\n          break;\n        default:\n          // ignore unknown stream types\n          return;\n        }\n\n        // if a new packet is starting, we can flush the completed\n        // packet\n        if (data.payloadUnitStartIndicator) {\n          flushStream(stream, streamType, true);\n        }\n\n        // buffer this fragment until we are sure we've received the\n        // complete payload\n        stream.data.push(data);\n        stream.size += data.data.byteLength;\n      },\n      pmt: function() {\n        var\n          event = {\n            type: 'metadata',\n            tracks: []\n          },\n          programMapTable = data.programMapTable;\n\n        // translate audio and video streams to tracks\n        if (programMapTable.video !== null) {\n          event.tracks.push({\n            timelineStartInfo: {\n              baseMediaDecodeTime: 0\n            },\n            id: +programMapTable.video,\n            codec: 'avc',\n            type: 'video'\n          });\n        }\n        if (programMapTable.audio !== null) {\n          event.tracks.push({\n            timelineStartInfo: {\n              baseMediaDecodeTime: 0\n            },\n            id: +programMapTable.audio,\n            codec: 'adts',\n            type: 'audio'\n          });\n        }\n\n        self.trigger('data', event);\n      }\n    })[data.type]();\n  };\n\n  /**\n   * Flush any remaining input. Video PES packets may be of variable\n   * length. Normally, the start of a new video packet can trigger the\n   * finalization of the previous packet. That is not possible if no\n   * more video is forthcoming, however. In that case, some other\n   * mechanism (like the end of the file) has to be employed. When it is\n   * clear that no additional data is forthcoming, calling this method\n   * will flush the buffered packets.\n   */\n  this.flush = function() {\n    // !!THIS ORDER IS IMPORTANT!!\n    // video first then audio\n    flushStream(video, 'video');\n    flushStream(audio, 'audio');\n    flushStream(timedMetadata, 'timed-metadata');\n    this.trigger('done');\n  };\n};\nElementaryStream.prototype = new Stream();\n\nvar m2ts = {\n  PAT_PID: 0x0000,\n  MP2T_PACKET_LENGTH: MP2T_PACKET_LENGTH,\n  TransportPacketStream: TransportPacketStream,\n  TransportParseStream: TransportParseStream,\n  ElementaryStream: ElementaryStream,\n  TimestampRolloverStream: TimestampRolloverStream,\n  CaptionStream: CaptionStream.CaptionStream,\n  Cea608Stream: CaptionStream.Cea608Stream,\n  MetadataStream: require('./metadata-stream')\n};\n\nfor (var type in StreamTypes) {\n  if (StreamTypes.hasOwnProperty(type)) {\n    m2ts[type] = StreamTypes[type];\n  }\n}\n\nmodule.exports = m2ts;\n","/**\n * mux.js\n *\n * Copyright (c) 2016 Brightcove\n * All rights reserved.\n *\n * Utilities to detect basic properties and metadata about Aac data.\n */\n'use strict';\n\nvar ADTS_SAMPLING_FREQUENCIES = [\n  96000,\n  88200,\n  64000,\n  48000,\n  44100,\n  32000,\n  24000,\n  22050,\n  16000,\n  12000,\n  11025,\n  8000,\n  7350\n];\n\nvar isLikelyAacData = function(data) {\n  if ((data[0] === 'I'.charCodeAt(0)) &&\n      (data[1] === 'D'.charCodeAt(0)) &&\n      (data[2] === '3'.charCodeAt(0))) {\n    return true;\n  }\n  return false;\n};\n\nvar parseSyncSafeInteger = function(data) {\n  return (data[0] << 21) |\n          (data[1] << 14) |\n          (data[2] << 7) |\n          (data[3]);\n};\n\n// return a percent-encoded representation of the specified byte range\n// @see http://en.wikipedia.org/wiki/Percent-encoding\nvar percentEncode = function(bytes, start, end) {\n  var i, result = '';\n  for (i = start; i < end; i++) {\n    result += '%' + ('00' + bytes[i].toString(16)).slice(-2);\n  }\n  return result;\n};\n\n// return the string representation of the specified byte range,\n// interpreted as ISO-8859-1.\nvar parseIso88591 = function(bytes, start, end) {\n  return unescape(percentEncode(bytes, start, end)); // jshint ignore:line\n};\n\nvar parseId3TagSize = function(header, byteIndex) {\n  var\n    returnSize = (header[byteIndex + 6] << 21) |\n                 (header[byteIndex + 7] << 14) |\n                 (header[byteIndex + 8] << 7) |\n                 (header[byteIndex + 9]),\n    flags = header[byteIndex + 5],\n    footerPresent = (flags & 16) >> 4;\n\n  if (footerPresent) {\n    return returnSize + 20;\n  }\n  return returnSize + 10;\n};\n\nvar parseAdtsSize = function(header, byteIndex) {\n  var\n    lowThree = (header[byteIndex + 5] & 0xE0) >> 5,\n    middle = header[byteIndex + 4] << 3,\n    highTwo = header[byteIndex + 3] & 0x3 << 11;\n\n  return (highTwo | middle) | lowThree;\n};\n\nvar parseType = function(header, byteIndex) {\n  if ((header[byteIndex] === 'I'.charCodeAt(0)) &&\n      (header[byteIndex + 1] === 'D'.charCodeAt(0)) &&\n      (header[byteIndex + 2] === '3'.charCodeAt(0))) {\n    return 'timed-metadata';\n  } else if ((header[byteIndex] & 0xff === 0xff) &&\n             ((header[byteIndex + 1] & 0xf0) === 0xf0)) {\n    return 'audio';\n  }\n  return null;\n};\n\nvar parseSampleRate = function(packet) {\n  var i = 0;\n\n  while (i + 5 < packet.length) {\n    if (packet[i] !== 0xFF || (packet[i + 1] & 0xF6) !== 0xF0) {\n      // If a valid header was not found,  jump one forward and attempt to\n      // find a valid ADTS header starting at the next byte\n      i++;\n      continue;\n    }\n    return ADTS_SAMPLING_FREQUENCIES[(packet[i + 2] & 0x3c) >>> 2];\n  }\n\n  return null;\n};\n\nvar parseAacTimestamp = function(packet) {\n  var frameStart, frameSize, frame, frameHeader;\n\n  // find the start of the first frame and the end of the tag\n  frameStart = 10;\n  if (packet[5] & 0x40) {\n    // advance the frame start past the extended header\n    frameStart += 4; // header size field\n    frameStart += parseSyncSafeInteger(packet.subarray(10, 14));\n  }\n\n  // parse one or more ID3 frames\n  // http://id3.org/id3v2.3.0#ID3v2_frame_overview\n  do {\n    // determine the number of bytes in this frame\n    frameSize = parseSyncSafeInteger(packet.subarray(frameStart + 4, frameStart + 8));\n    if (frameSize < 1) {\n      return null;\n    }\n    frameHeader = String.fromCharCode(packet[frameStart],\n                                      packet[frameStart + 1],\n                                      packet[frameStart + 2],\n                                      packet[frameStart + 3]);\n\n    if (frameHeader === 'PRIV') {\n      frame = packet.subarray(frameStart + 10, frameStart + frameSize + 10);\n\n      for (var i = 0; i < frame.byteLength; i++) {\n        if (frame[i] === 0) {\n          var owner = parseIso88591(frame, 0, i);\n          if (owner === 'com.apple.streaming.transportStreamTimestamp') {\n            var d = frame.subarray(i + 1);\n            var size = ((d[3] & 0x01)  << 30) |\n                       (d[4]  << 22) |\n                       (d[5] << 14) |\n                       (d[6] << 6) |\n                       (d[7] >>> 2);\n            size *= 4;\n            size += d[7] & 0x03;\n\n            return size;\n          }\n          break;\n        }\n      }\n    }\n\n    frameStart += 10; // advance past the frame header\n    frameStart += frameSize; // advance past the frame body\n  } while (frameStart < packet.byteLength);\n  return null;\n};\n\nmodule.exports = {\n  isLikelyAacData: isLikelyAacData,\n  parseId3TagSize: parseId3TagSize,\n  parseAdtsSize: parseAdtsSize,\n  parseType: parseType,\n  parseSampleRate: parseSampleRate,\n  parseAacTimestamp: parseAacTimestamp\n};\n","/**\n * An object that stores the bytes of an FLV tag and methods for\n * querying and manipulating that data.\n * @see http://download.macromedia.com/f4v/video_file_format_spec_v10_1.pdf\n */\n'use strict';\n\nvar FlvTag;\n\n// (type:uint, extraData:Boolean = false) extends ByteArray\nFlvTag = function(type, extraData) {\n  var\n    // Counter if this is a metadata tag, nal start marker if this is a video\n    // tag. unused if this is an audio tag\n    adHoc = 0, // :uint\n\n    // The default size is 16kb but this is not enough to hold iframe\n    // data and the resizing algorithm costs a bit so we create a larger\n    // starting buffer for video tags\n    bufferStartSize = 16384,\n\n    // checks whether the FLV tag has enough capacity to accept the proposed\n    // write and re-allocates the internal buffers if necessary\n    prepareWrite = function(flv, count) {\n      var\n        bytes,\n        minLength = flv.position + count;\n      if (minLength < flv.bytes.byteLength) {\n        // there's enough capacity so do nothing\n        return;\n      }\n\n      // allocate a new buffer and copy over the data that will not be modified\n      bytes = new Uint8Array(minLength * 2);\n      bytes.set(flv.bytes.subarray(0, flv.position), 0);\n      flv.bytes = bytes;\n      flv.view = new DataView(flv.bytes.buffer);\n    },\n\n    // commonly used metadata properties\n    widthBytes = FlvTag.widthBytes || new Uint8Array('width'.length),\n    heightBytes = FlvTag.heightBytes || new Uint8Array('height'.length),\n    videocodecidBytes = FlvTag.videocodecidBytes || new Uint8Array('videocodecid'.length),\n    i;\n\n  if (!FlvTag.widthBytes) {\n    // calculating the bytes of common metadata names ahead of time makes the\n    // corresponding writes faster because we don't have to loop over the\n    // characters\n    // re-test with test/perf.html if you're planning on changing this\n    for (i = 0; i < 'width'.length; i++) {\n      widthBytes[i] = 'width'.charCodeAt(i);\n    }\n    for (i = 0; i < 'height'.length; i++) {\n      heightBytes[i] = 'height'.charCodeAt(i);\n    }\n    for (i = 0; i < 'videocodecid'.length; i++) {\n      videocodecidBytes[i] = 'videocodecid'.charCodeAt(i);\n    }\n\n    FlvTag.widthBytes = widthBytes;\n    FlvTag.heightBytes = heightBytes;\n    FlvTag.videocodecidBytes = videocodecidBytes;\n  }\n\n  this.keyFrame = false; // :Boolean\n\n  switch (type) {\n  case FlvTag.VIDEO_TAG:\n    this.length = 16;\n    // Start the buffer at 256k\n    bufferStartSize *= 6;\n    break;\n  case FlvTag.AUDIO_TAG:\n    this.length = 13;\n    this.keyFrame = true;\n    break;\n  case FlvTag.METADATA_TAG:\n    this.length = 29;\n    this.keyFrame = true;\n    break;\n  default:\n    throw new Error('Unknown FLV tag type');\n  }\n\n  this.bytes = new Uint8Array(bufferStartSize);\n  this.view = new DataView(this.bytes.buffer);\n  this.bytes[0] = type;\n  this.position = this.length;\n  this.keyFrame = extraData; // Defaults to false\n\n  // presentation timestamp\n  this.pts = 0;\n  // decoder timestamp\n  this.dts = 0;\n\n  // ByteArray#writeBytes(bytes:ByteArray, offset:uint = 0, length:uint = 0)\n  this.writeBytes = function(bytes, offset, length) {\n    var\n      start = offset || 0,\n      end;\n    length = length || bytes.byteLength;\n    end = start + length;\n\n    prepareWrite(this, length);\n    this.bytes.set(bytes.subarray(start, end), this.position);\n\n    this.position += length;\n    this.length = Math.max(this.length, this.position);\n  };\n\n  // ByteArray#writeByte(value:int):void\n  this.writeByte = function(byte) {\n    prepareWrite(this, 1);\n    this.bytes[this.position] = byte;\n    this.position++;\n    this.length = Math.max(this.length, this.position);\n  };\n\n  // ByteArray#writeShort(value:int):void\n  this.writeShort = function(short) {\n    prepareWrite(this, 2);\n    this.view.setUint16(this.position, short);\n    this.position += 2;\n    this.length = Math.max(this.length, this.position);\n  };\n\n  // Negative index into array\n  // (pos:uint):int\n  this.negIndex = function(pos) {\n    return this.bytes[this.length - pos];\n  };\n\n  // The functions below ONLY work when this[0] == VIDEO_TAG.\n  // We are not going to check for that because we dont want the overhead\n  // (nal:ByteArray = null):int\n  this.nalUnitSize = function() {\n    if (adHoc === 0) {\n      return 0;\n    }\n\n    return this.length - (adHoc + 4);\n  };\n\n  this.startNalUnit = function() {\n    // remember position and add 4 bytes\n    if (adHoc > 0) {\n      throw new Error('Attempted to create new NAL wihout closing the old one');\n    }\n\n    // reserve 4 bytes for nal unit size\n    adHoc = this.length;\n    this.length += 4;\n    this.position = this.length;\n  };\n\n  // (nal:ByteArray = null):void\n  this.endNalUnit = function(nalContainer) {\n    var\n      nalStart, // :uint\n      nalLength; // :uint\n\n    // Rewind to the marker and write the size\n    if (this.length === adHoc + 4) {\n      // we started a nal unit, but didnt write one, so roll back the 4 byte size value\n      this.length -= 4;\n    } else if (adHoc > 0) {\n      nalStart = adHoc + 4;\n      nalLength = this.length - nalStart;\n\n      this.position = adHoc;\n      this.view.setUint32(this.position, nalLength);\n      this.position = this.length;\n\n      if (nalContainer) {\n        // Add the tag to the NAL unit\n        nalContainer.push(this.bytes.subarray(nalStart, nalStart + nalLength));\n      }\n    }\n\n    adHoc = 0;\n  };\n\n  /**\n   * Write out a 64-bit floating point valued metadata property. This method is\n   * called frequently during a typical parse and needs to be fast.\n   */\n  // (key:String, val:Number):void\n  this.writeMetaDataDouble = function(key, val) {\n    var i;\n    prepareWrite(this, 2 + key.length + 9);\n\n    // write size of property name\n    this.view.setUint16(this.position, key.length);\n    this.position += 2;\n\n    // this next part looks terrible but it improves parser throughput by\n    // 10kB/s in my testing\n\n    // write property name\n    if (key === 'width') {\n      this.bytes.set(widthBytes, this.position);\n      this.position += 5;\n    } else if (key === 'height') {\n      this.bytes.set(heightBytes, this.position);\n      this.position += 6;\n    } else if (key === 'videocodecid') {\n      this.bytes.set(videocodecidBytes, this.position);\n      this.position += 12;\n    } else {\n      for (i = 0; i < key.length; i++) {\n        this.bytes[this.position] = key.charCodeAt(i);\n        this.position++;\n      }\n    }\n\n    // skip null byte\n    this.position++;\n\n    // write property value\n    this.view.setFloat64(this.position, val);\n    this.position += 8;\n\n    // update flv tag length\n    this.length = Math.max(this.length, this.position);\n    ++adHoc;\n  };\n\n  // (key:String, val:Boolean):void\n  this.writeMetaDataBoolean = function(key, val) {\n    var i;\n    prepareWrite(this, 2);\n    this.view.setUint16(this.position, key.length);\n    this.position += 2;\n    for (i = 0; i < key.length; i++) {\n      // if key.charCodeAt(i) >= 255, handle error\n      prepareWrite(this, 1);\n      this.bytes[this.position] = key.charCodeAt(i);\n      this.position++;\n    }\n    prepareWrite(this, 2);\n    this.view.setUint8(this.position, 0x01);\n    this.position++;\n    this.view.setUint8(this.position, val ? 0x01 : 0x00);\n    this.position++;\n    this.length = Math.max(this.length, this.position);\n    ++adHoc;\n  };\n\n  // ():ByteArray\n  this.finalize = function() {\n    var\n      dtsDelta, // :int\n      len; // :int\n\n    switch (this.bytes[0]) {\n      // Video Data\n    case FlvTag.VIDEO_TAG:\n       // We only support AVC, 1 = key frame (for AVC, a seekable\n       // frame), 2 = inter frame (for AVC, a non-seekable frame)\n      this.bytes[11] = ((this.keyFrame || extraData) ? 0x10 : 0x20) | 0x07;\n      this.bytes[12] = extraData ?  0x00 : 0x01;\n\n      dtsDelta = this.pts - this.dts;\n      this.bytes[13] = (dtsDelta & 0x00FF0000) >>> 16;\n      this.bytes[14] = (dtsDelta & 0x0000FF00) >>>  8;\n      this.bytes[15] = (dtsDelta & 0x000000FF) >>>  0;\n      break;\n\n    case FlvTag.AUDIO_TAG:\n      this.bytes[11] = 0xAF; // 44 kHz, 16-bit stereo\n      this.bytes[12] = extraData ? 0x00 : 0x01;\n      break;\n\n    case FlvTag.METADATA_TAG:\n      this.position = 11;\n      this.view.setUint8(this.position, 0x02); // String type\n      this.position++;\n      this.view.setUint16(this.position, 0x0A); // 10 Bytes\n      this.position += 2;\n      // set \"onMetaData\"\n      this.bytes.set([0x6f, 0x6e, 0x4d, 0x65,\n                      0x74, 0x61, 0x44, 0x61,\n                      0x74, 0x61], this.position);\n      this.position += 10;\n      this.bytes[this.position] = 0x08; // Array type\n      this.position++;\n      this.view.setUint32(this.position, adHoc);\n      this.position = this.length;\n      this.bytes.set([0, 0, 9], this.position);\n      this.position += 3; // End Data Tag\n      this.length = this.position;\n      break;\n    }\n\n    len = this.length - 11;\n\n    // write the DataSize field\n    this.bytes[ 1] = (len & 0x00FF0000) >>> 16;\n    this.bytes[ 2] = (len & 0x0000FF00) >>>  8;\n    this.bytes[ 3] = (len & 0x000000FF) >>>  0;\n    // write the Timestamp\n    this.bytes[ 4] = (this.dts & 0x00FF0000) >>> 16;\n    this.bytes[ 5] = (this.dts & 0x0000FF00) >>>  8;\n    this.bytes[ 6] = (this.dts & 0x000000FF) >>>  0;\n    this.bytes[ 7] = (this.dts & 0xFF000000) >>> 24;\n    // write the StreamID\n    this.bytes[ 8] = 0;\n    this.bytes[ 9] = 0;\n    this.bytes[10] = 0;\n\n    // Sometimes we're at the end of the view and have one slot to write a\n    // uint32, so, prepareWrite of count 4, since, view is uint8\n    prepareWrite(this, 4);\n    this.view.setUint32(this.length, this.length);\n    this.length += 4;\n    this.position += 4;\n\n    // trim down the byte buffer to what is actually being used\n    this.bytes = this.bytes.subarray(0, this.length);\n    this.frameTime = FlvTag.frameTime(this.bytes);\n    // if bytes.bytelength isn't equal to this.length, handle error\n    return this;\n  };\n};\n\nFlvTag.AUDIO_TAG = 0x08; // == 8, :uint\nFlvTag.VIDEO_TAG = 0x09; // == 9, :uint\nFlvTag.METADATA_TAG = 0x12; // == 18, :uint\n\n// (tag:ByteArray):Boolean {\nFlvTag.isAudioFrame = function(tag) {\n  return FlvTag.AUDIO_TAG === tag[0];\n};\n\n// (tag:ByteArray):Boolean {\nFlvTag.isVideoFrame = function(tag) {\n  return FlvTag.VIDEO_TAG === tag[0];\n};\n\n// (tag:ByteArray):Boolean {\nFlvTag.isMetaData = function(tag) {\n  return FlvTag.METADATA_TAG === tag[0];\n};\n\n// (tag:ByteArray):Boolean {\nFlvTag.isKeyFrame = function(tag) {\n  if (FlvTag.isVideoFrame(tag)) {\n    return tag[11] === 0x17;\n  }\n\n  if (FlvTag.isAudioFrame(tag)) {\n    return true;\n  }\n\n  if (FlvTag.isMetaData(tag)) {\n    return true;\n  }\n\n  return false;\n};\n\n// (tag:ByteArray):uint {\nFlvTag.frameTime = function(tag) {\n  var pts = tag[ 4] << 16; // :uint\n  pts |= tag[ 5] <<  8;\n  pts |= tag[ 6] <<  0;\n  pts |= tag[ 7] << 24;\n  return pts;\n};\n\nmodule.exports = FlvTag;\n","'use strict';\n\n/**\n * Check if `obj` is an object.\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api private\n */\n\nfunction isObject(obj) {\n  return null !== obj && 'object' === typeof obj;\n}\n\nmodule.exports = isObject;\n","'use strict';\n/** @module route/nodes */\n\n\n/**\n * Create a node for use with the parser, giving it a constructor that takes\n * props, children, and returns an object with props, children, and a\n * displayName.\n * @param  {String} displayName The display name for the node\n * @return {{displayName: string, props: Object, children: Array}}\n */\nfunction createNode(displayName) {\n  return function(props, children) {\n    return {\n      displayName: displayName,\n      props: props,\n      children: children || []\n    };\n  };\n}\n\nmodule.exports = {\n  Root: createNode('Root'),\n  Concat: createNode('Concat'),\n  Literal: createNode('Literal'),\n  Splat: createNode('Splat'),\n  Param: createNode('Param'),\n  Optional: createNode('Optional')\n};\n","'use strict';\n/**\n * @module route/visitors/create_visitor\n */\n\nvar nodeTypes = Object.keys(require('../nodes'));\n\n/**\n * Helper for creating visitors. Take an object of node name to handler\n * mappings, returns an object with a \"visit\" method that can be called\n * @param  {Object.<string,function(node,context)>} handlers A mapping of node\n * type to visitor functions\n * @return {{visit: function(node,context)}}  A visitor object with a \"visit\"\n * method that can be called on a node with a context\n */\nfunction createVisitor(handlers) {\n  nodeTypes.forEach(function(nodeType) {\n    if( typeof handlers[nodeType] === 'undefined') {\n      throw new Error('No handler defined for ' + nodeType.displayName);\n    }\n\n  });\n\n  return {\n    /**\n     * Call the given handler for this node type\n     * @param  {Object} node    the AST node\n     * @param  {Object} context context to pass through to handlers\n     * @return {Object}\n     */\n    visit: function(node, context) {\n      return this.handlers[node.displayName].call(this,node, context);\n    },\n    handlers: handlers\n  };\n}\n\nmodule.exports = createVisitor;","/**\n * mux.js\n *\n * Copyright (c) 2015 Brightcove\n * All rights reserved.\n *\n * Functions that generate fragmented MP4s suitable for use with Media\n * Source Extensions.\n */\n'use strict';\n\nvar UINT32_MAX = Math.pow(2, 32) - 1;\n\nvar box, dinf, esds, ftyp, mdat, mfhd, minf, moof, moov, mvex, mvhd,\n    trak, tkhd, mdia, mdhd, hdlr, sdtp, stbl, stsd, traf, trex,\n    trun, types, MAJOR_BRAND, MINOR_VERSION, AVC1_BRAND, VIDEO_HDLR,\n    AUDIO_HDLR, HDLR_TYPES, VMHD, SMHD, DREF, STCO, STSC, STSZ, STTS;\n\n// pre-calculate constants\n(function() {\n  var i;\n  types = {\n    avc1: [], // codingname\n    avcC: [],\n    btrt: [],\n    dinf: [],\n    dref: [],\n    esds: [],\n    ftyp: [],\n    hdlr: [],\n    mdat: [],\n    mdhd: [],\n    mdia: [],\n    mfhd: [],\n    minf: [],\n    moof: [],\n    moov: [],\n    mp4a: [], // codingname\n    mvex: [],\n    mvhd: [],\n    sdtp: [],\n    smhd: [],\n    stbl: [],\n    stco: [],\n    stsc: [],\n    stsd: [],\n    stsz: [],\n    stts: [],\n    styp: [],\n    tfdt: [],\n    tfhd: [],\n    traf: [],\n    trak: [],\n    trun: [],\n    trex: [],\n    tkhd: [],\n    vmhd: []\n  };\n\n  // In environments where Uint8Array is undefined (e.g., IE8), skip set up so that we\n  // don't throw an error\n  if (typeof Uint8Array === 'undefined') {\n    return;\n  }\n\n  for (i in types) {\n    if (types.hasOwnProperty(i)) {\n      types[i] = [\n        i.charCodeAt(0),\n        i.charCodeAt(1),\n        i.charCodeAt(2),\n        i.charCodeAt(3)\n      ];\n    }\n  }\n\n  MAJOR_BRAND = new Uint8Array([\n    'i'.charCodeAt(0),\n    's'.charCodeAt(0),\n    'o'.charCodeAt(0),\n    'm'.charCodeAt(0)\n  ]);\n  AVC1_BRAND = new Uint8Array([\n    'a'.charCodeAt(0),\n    'v'.charCodeAt(0),\n    'c'.charCodeAt(0),\n    '1'.charCodeAt(0)\n  ]);\n  MINOR_VERSION = new Uint8Array([0, 0, 0, 1]);\n  VIDEO_HDLR = new Uint8Array([\n    0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00, // pre_defined\n    0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x56, 0x69, 0x64, 0x65,\n    0x6f, 0x48, 0x61, 0x6e,\n    0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'\n  ]);\n  AUDIO_HDLR = new Uint8Array([\n    0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00, // pre_defined\n    0x73, 0x6f, 0x75, 0x6e, // handler_type: 'soun'\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x53, 0x6f, 0x75, 0x6e,\n    0x64, 0x48, 0x61, 0x6e,\n    0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'\n  ]);\n  HDLR_TYPES = {\n    video: VIDEO_HDLR,\n    audio: AUDIO_HDLR\n  };\n  DREF = new Uint8Array([\n    0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x01, // entry_count\n    0x00, 0x00, 0x00, 0x0c, // entry_size\n    0x75, 0x72, 0x6c, 0x20, // 'url' type\n    0x00, // version 0\n    0x00, 0x00, 0x01 // entry_flags\n  ]);\n  SMHD = new Uint8Array([\n    0x00,             // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00,       // balance, 0 means centered\n    0x00, 0x00        // reserved\n  ]);\n  STCO = new Uint8Array([\n    0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00 // entry_count\n  ]);\n  STSC = STCO;\n  STSZ = new Uint8Array([\n    0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00, // sample_size\n    0x00, 0x00, 0x00, 0x00 // sample_count\n  ]);\n  STTS = STCO;\n  VMHD = new Uint8Array([\n    0x00, // version\n    0x00, 0x00, 0x01, // flags\n    0x00, 0x00, // graphicsmode\n    0x00, 0x00,\n    0x00, 0x00,\n    0x00, 0x00 // opcolor\n  ]);\n}());\n\nbox = function(type) {\n  var\n    payload = [],\n    size = 0,\n    i,\n    result,\n    view;\n\n  for (i = 1; i < arguments.length; i++) {\n    payload.push(arguments[i]);\n  }\n\n  i = payload.length;\n\n  // calculate the total size we need to allocate\n  while (i--) {\n    size += payload[i].byteLength;\n  }\n  result = new Uint8Array(size + 8);\n  view = new DataView(result.buffer, result.byteOffset, result.byteLength);\n  view.setUint32(0, result.byteLength);\n  result.set(type, 4);\n\n  // copy the payload into the result\n  for (i = 0, size = 8; i < payload.length; i++) {\n    result.set(payload[i], size);\n    size += payload[i].byteLength;\n  }\n  return result;\n};\n\ndinf = function() {\n  return box(types.dinf, box(types.dref, DREF));\n};\n\nesds = function(track) {\n  return box(types.esds, new Uint8Array([\n    0x00, // version\n    0x00, 0x00, 0x00, // flags\n\n    // ES_Descriptor\n    0x03, // tag, ES_DescrTag\n    0x19, // length\n    0x00, 0x00, // ES_ID\n    0x00, // streamDependenceFlag, URL_flag, reserved, streamPriority\n\n    // DecoderConfigDescriptor\n    0x04, // tag, DecoderConfigDescrTag\n    0x11, // length\n    0x40, // object type\n    0x15,  // streamType\n    0x00, 0x06, 0x00, // bufferSizeDB\n    0x00, 0x00, 0xda, 0xc0, // maxBitrate\n    0x00, 0x00, 0xda, 0xc0, // avgBitrate\n\n    // DecoderSpecificInfo\n    0x05, // tag, DecoderSpecificInfoTag\n    0x02, // length\n    // ISO/IEC 14496-3, AudioSpecificConfig\n    // for samplingFrequencyIndex see ISO/IEC 13818-7:2006, 8.1.3.2.2, Table 35\n    (track.audioobjecttype << 3) | (track.samplingfrequencyindex >>> 1),\n    (track.samplingfrequencyindex << 7) | (track.channelcount << 3),\n    0x06, 0x01, 0x02 // GASpecificConfig\n  ]));\n};\n\nftyp = function() {\n  return box(types.ftyp, MAJOR_BRAND, MINOR_VERSION, MAJOR_BRAND, AVC1_BRAND);\n};\n\nhdlr = function(type) {\n  return box(types.hdlr, HDLR_TYPES[type]);\n};\nmdat = function(data) {\n  return box(types.mdat, data);\n};\nmdhd = function(track) {\n  var result = new Uint8Array([\n    0x00,                   // version 0\n    0x00, 0x00, 0x00,       // flags\n    0x00, 0x00, 0x00, 0x02, // creation_time\n    0x00, 0x00, 0x00, 0x03, // modification_time\n    0x00, 0x01, 0x5f, 0x90, // timescale, 90,000 \"ticks\" per second\n\n    (track.duration >>> 24) & 0xFF,\n    (track.duration >>> 16) & 0xFF,\n    (track.duration >>>  8) & 0xFF,\n    track.duration & 0xFF,  // duration\n    0x55, 0xc4,             // 'und' language (undetermined)\n    0x00, 0x00\n  ]);\n\n  // Use the sample rate from the track metadata, when it is\n  // defined. The sample rate can be parsed out of an ADTS header, for\n  // instance.\n  if (track.samplerate) {\n    result[12] = (track.samplerate >>> 24) & 0xFF;\n    result[13] = (track.samplerate >>> 16) & 0xFF;\n    result[14] = (track.samplerate >>>  8) & 0xFF;\n    result[15] = (track.samplerate)        & 0xFF;\n  }\n\n  return box(types.mdhd, result);\n};\nmdia = function(track) {\n  return box(types.mdia, mdhd(track), hdlr(track.type), minf(track));\n};\nmfhd = function(sequenceNumber) {\n  return box(types.mfhd, new Uint8Array([\n    0x00,\n    0x00, 0x00, 0x00, // flags\n    (sequenceNumber & 0xFF000000) >> 24,\n    (sequenceNumber & 0xFF0000) >> 16,\n    (sequenceNumber & 0xFF00) >> 8,\n    sequenceNumber & 0xFF // sequence_number\n  ]));\n};\nminf = function(track) {\n  return box(types.minf,\n             track.type === 'video' ? box(types.vmhd, VMHD) : box(types.smhd, SMHD),\n             dinf(),\n             stbl(track));\n};\nmoof = function(sequenceNumber, tracks) {\n  var\n    trackFragments = [],\n    i = tracks.length;\n  // build traf boxes for each track fragment\n  while (i--) {\n    trackFragments[i] = traf(tracks[i]);\n  }\n  return box.apply(null, [\n    types.moof,\n    mfhd(sequenceNumber)\n  ].concat(trackFragments));\n};\n/**\n * Returns a movie box.\n * @param tracks {array} the tracks associated with this movie\n * @see ISO/IEC 14496-12:2012(E), section 8.2.1\n */\nmoov = function(tracks) {\n  var\n    i = tracks.length,\n    boxes = [];\n\n  while (i--) {\n    boxes[i] = trak(tracks[i]);\n  }\n\n  return box.apply(null, [types.moov, mvhd(0xffffffff)].concat(boxes).concat(mvex(tracks)));\n};\nmvex = function(tracks) {\n  var\n    i = tracks.length,\n    boxes = [];\n\n  while (i--) {\n    boxes[i] = trex(tracks[i]);\n  }\n  return box.apply(null, [types.mvex].concat(boxes));\n};\nmvhd = function(duration) {\n  var\n    bytes = new Uint8Array([\n      0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x01, // creation_time\n      0x00, 0x00, 0x00, 0x02, // modification_time\n      0x00, 0x01, 0x5f, 0x90, // timescale, 90,000 \"ticks\" per second\n      (duration & 0xFF000000) >> 24,\n      (duration & 0xFF0000) >> 16,\n      (duration & 0xFF00) >> 8,\n      duration & 0xFF, // duration\n      0x00, 0x01, 0x00, 0x00, // 1.0 rate\n      0x01, 0x00, // 1.0 volume\n      0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x01, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x40, 0x00, 0x00, 0x00, // transformation: unity matrix\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, // pre_defined\n      0xff, 0xff, 0xff, 0xff // next_track_ID\n    ]);\n  return box(types.mvhd, bytes);\n};\n\nsdtp = function(track) {\n  var\n    samples = track.samples || [],\n    bytes = new Uint8Array(4 + samples.length),\n    flags,\n    i;\n\n  // leave the full box header (4 bytes) all zero\n\n  // write the sample table\n  for (i = 0; i < samples.length; i++) {\n    flags = samples[i].flags;\n\n    bytes[i + 4] = (flags.dependsOn << 4) |\n      (flags.isDependedOn << 2) |\n      (flags.hasRedundancy);\n  }\n\n  return box(types.sdtp,\n             bytes);\n};\n\nstbl = function(track) {\n  return box(types.stbl,\n             stsd(track),\n             box(types.stts, STTS),\n             box(types.stsc, STSC),\n             box(types.stsz, STSZ),\n             box(types.stco, STCO));\n};\n\n(function() {\n  var videoSample, audioSample;\n\n  stsd = function(track) {\n\n    return box(types.stsd, new Uint8Array([\n      0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x01\n    ]), track.type === 'video' ? videoSample(track) : audioSample(track));\n  };\n\n  videoSample = function(track) {\n    var\n      sps = track.sps || [],\n      pps = track.pps || [],\n      sequenceParameterSets = [],\n      pictureParameterSets = [],\n      i;\n\n    // assemble the SPSs\n    for (i = 0; i < sps.length; i++) {\n      sequenceParameterSets.push((sps[i].byteLength & 0xFF00) >>> 8);\n      sequenceParameterSets.push((sps[i].byteLength & 0xFF)); // sequenceParameterSetLength\n      sequenceParameterSets = sequenceParameterSets.concat(Array.prototype.slice.call(sps[i])); // SPS\n    }\n\n    // assemble the PPSs\n    for (i = 0; i < pps.length; i++) {\n      pictureParameterSets.push((pps[i].byteLength & 0xFF00) >>> 8);\n      pictureParameterSets.push((pps[i].byteLength & 0xFF));\n      pictureParameterSets = pictureParameterSets.concat(Array.prototype.slice.call(pps[i]));\n    }\n\n    return box(types.avc1, new Uint8Array([\n      0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // data_reference_index\n      0x00, 0x00, // pre_defined\n      0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, // pre_defined\n      (track.width & 0xff00) >> 8,\n      track.width & 0xff, // width\n      (track.height & 0xff00) >> 8,\n      track.height & 0xff, // height\n      0x00, 0x48, 0x00, 0x00, // horizresolution\n      0x00, 0x48, 0x00, 0x00, // vertresolution\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // frame_count\n      0x13,\n      0x76, 0x69, 0x64, 0x65,\n      0x6f, 0x6a, 0x73, 0x2d,\n      0x63, 0x6f, 0x6e, 0x74,\n      0x72, 0x69, 0x62, 0x2d,\n      0x68, 0x6c, 0x73, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, // compressorname\n      0x00, 0x18, // depth = 24\n      0x11, 0x11 // pre_defined = -1\n    ]), box(types.avcC, new Uint8Array([\n      0x01, // configurationVersion\n      track.profileIdc, // AVCProfileIndication\n      track.profileCompatibility, // profile_compatibility\n      track.levelIdc, // AVCLevelIndication\n      0xff // lengthSizeMinusOne, hard-coded to 4 bytes\n    ].concat([\n      sps.length // numOfSequenceParameterSets\n    ]).concat(sequenceParameterSets).concat([\n      pps.length // numOfPictureParameterSets\n    ]).concat(pictureParameterSets))), // \"PPS\"\n            box(types.btrt, new Uint8Array([\n              0x00, 0x1c, 0x9c, 0x80, // bufferSizeDB\n              0x00, 0x2d, 0xc6, 0xc0, // maxBitrate\n              0x00, 0x2d, 0xc6, 0xc0\n            ])) // avgBitrate\n              );\n  };\n\n  audioSample = function(track) {\n    return box(types.mp4a, new Uint8Array([\n\n      // SampleEntry, ISO/IEC 14496-12\n      0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // data_reference_index\n\n      // AudioSampleEntry, ISO/IEC 14496-12\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00, // reserved\n      (track.channelcount & 0xff00) >> 8,\n      (track.channelcount & 0xff), // channelcount\n\n      (track.samplesize & 0xff00) >> 8,\n      (track.samplesize & 0xff), // samplesize\n      0x00, 0x00, // pre_defined\n      0x00, 0x00, // reserved\n\n      (track.samplerate & 0xff00) >> 8,\n      (track.samplerate & 0xff),\n      0x00, 0x00 // samplerate, 16.16\n\n      // MP4AudioSampleEntry, ISO/IEC 14496-14\n    ]), esds(track));\n  };\n}());\n\ntkhd = function(track) {\n  var result = new Uint8Array([\n    0x00, // version 0\n    0x00, 0x00, 0x07, // flags\n    0x00, 0x00, 0x00, 0x00, // creation_time\n    0x00, 0x00, 0x00, 0x00, // modification_time\n    (track.id & 0xFF000000) >> 24,\n    (track.id & 0xFF0000) >> 16,\n    (track.id & 0xFF00) >> 8,\n    track.id & 0xFF, // track_ID\n    0x00, 0x00, 0x00, 0x00, // reserved\n    (track.duration & 0xFF000000) >> 24,\n    (track.duration & 0xFF0000) >> 16,\n    (track.duration & 0xFF00) >> 8,\n    track.duration & 0xFF, // duration\n    0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, // reserved\n    0x00, 0x00, // layer\n    0x00, 0x00, // alternate_group\n    0x01, 0x00, // non-audio track volume\n    0x00, 0x00, // reserved\n    0x00, 0x01, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00,\n    0x00, 0x01, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00,\n    0x40, 0x00, 0x00, 0x00, // transformation: unity matrix\n    (track.width & 0xFF00) >> 8,\n    track.width & 0xFF,\n    0x00, 0x00, // width\n    (track.height & 0xFF00) >> 8,\n    track.height & 0xFF,\n    0x00, 0x00 // height\n  ]);\n\n  return box(types.tkhd, result);\n};\n\n/**\n * Generate a track fragment (traf) box. A traf box collects metadata\n * about tracks in a movie fragment (moof) box.\n */\ntraf = function(track) {\n  var trackFragmentHeader, trackFragmentDecodeTime, trackFragmentRun,\n      sampleDependencyTable, dataOffset,\n      upperWordBaseMediaDecodeTime, lowerWordBaseMediaDecodeTime;\n\n  trackFragmentHeader = box(types.tfhd, new Uint8Array([\n    0x00, // version 0\n    0x00, 0x00, 0x3a, // flags\n    (track.id & 0xFF000000) >> 24,\n    (track.id & 0xFF0000) >> 16,\n    (track.id & 0xFF00) >> 8,\n    (track.id & 0xFF), // track_ID\n    0x00, 0x00, 0x00, 0x01, // sample_description_index\n    0x00, 0x00, 0x00, 0x00, // default_sample_duration\n    0x00, 0x00, 0x00, 0x00, // default_sample_size\n    0x00, 0x00, 0x00, 0x00  // default_sample_flags\n  ]));\n\n  upperWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime / (UINT32_MAX + 1));\n  lowerWordBaseMediaDecodeTime = Math.floor(track.baseMediaDecodeTime % (UINT32_MAX + 1));\n\n  trackFragmentDecodeTime = box(types.tfdt, new Uint8Array([\n    0x01, // version 1\n    0x00, 0x00, 0x00, // flags\n    // baseMediaDecodeTime\n    (upperWordBaseMediaDecodeTime >>> 24) & 0xFF,\n    (upperWordBaseMediaDecodeTime >>> 16) & 0xFF,\n    (upperWordBaseMediaDecodeTime >>>  8) & 0xFF,\n    upperWordBaseMediaDecodeTime & 0xFF,\n    (lowerWordBaseMediaDecodeTime >>> 24) & 0xFF,\n    (lowerWordBaseMediaDecodeTime >>> 16) & 0xFF,\n    (lowerWordBaseMediaDecodeTime >>>  8) & 0xFF,\n    lowerWordBaseMediaDecodeTime & 0xFF\n  ]));\n\n  // the data offset specifies the number of bytes from the start of\n  // the containing moof to the first payload byte of the associated\n  // mdat\n  dataOffset = (32 + // tfhd\n                20 + // tfdt\n                8 +  // traf header\n                16 + // mfhd\n                8 +  // moof header\n                8);  // mdat header\n\n  // audio tracks require less metadata\n  if (track.type === 'audio') {\n    trackFragmentRun = trun(track, dataOffset);\n    return box(types.traf,\n               trackFragmentHeader,\n               trackFragmentDecodeTime,\n               trackFragmentRun);\n  }\n\n  // video tracks should contain an independent and disposable samples\n  // box (sdtp)\n  // generate one and adjust offsets to match\n  sampleDependencyTable = sdtp(track);\n  trackFragmentRun = trun(track,\n                          sampleDependencyTable.length + dataOffset);\n  return box(types.traf,\n             trackFragmentHeader,\n             trackFragmentDecodeTime,\n             trackFragmentRun,\n             sampleDependencyTable);\n};\n\n/**\n * Generate a track box.\n * @param track {object} a track definition\n * @return {Uint8Array} the track box\n */\ntrak = function(track) {\n  track.duration = track.duration || 0xffffffff;\n  return box(types.trak,\n             tkhd(track),\n             mdia(track));\n};\n\ntrex = function(track) {\n  var result = new Uint8Array([\n    0x00, // version 0\n    0x00, 0x00, 0x00, // flags\n    (track.id & 0xFF000000) >> 24,\n    (track.id & 0xFF0000) >> 16,\n    (track.id & 0xFF00) >> 8,\n    (track.id & 0xFF), // track_ID\n    0x00, 0x00, 0x00, 0x01, // default_sample_description_index\n    0x00, 0x00, 0x00, 0x00, // default_sample_duration\n    0x00, 0x00, 0x00, 0x00, // default_sample_size\n    0x00, 0x01, 0x00, 0x01 // default_sample_flags\n  ]);\n  // the last two bytes of default_sample_flags is the sample\n  // degradation priority, a hint about the importance of this sample\n  // relative to others. Lower the degradation priority for all sample\n  // types other than video.\n  if (track.type !== 'video') {\n    result[result.length - 1] = 0x00;\n  }\n\n  return box(types.trex, result);\n};\n\n(function() {\n  var audioTrun, videoTrun, trunHeader;\n\n  // This method assumes all samples are uniform. That is, if a\n  // duration is present for the first sample, it will be present for\n  // all subsequent samples.\n  // see ISO/IEC 14496-12:2012, Section 8.8.8.1\n  trunHeader = function(samples, offset) {\n    var durationPresent = 0, sizePresent = 0,\n        flagsPresent = 0, compositionTimeOffset = 0;\n\n    // trun flag constants\n    if (samples.length) {\n      if (samples[0].duration !== undefined) {\n        durationPresent = 0x1;\n      }\n      if (samples[0].size !== undefined) {\n        sizePresent = 0x2;\n      }\n      if (samples[0].flags !== undefined) {\n        flagsPresent = 0x4;\n      }\n      if (samples[0].compositionTimeOffset !== undefined) {\n        compositionTimeOffset = 0x8;\n      }\n    }\n\n    return [\n      0x00, // version 0\n      0x00,\n      durationPresent | sizePresent | flagsPresent | compositionTimeOffset,\n      0x01, // flags\n      (samples.length & 0xFF000000) >>> 24,\n      (samples.length & 0xFF0000) >>> 16,\n      (samples.length & 0xFF00) >>> 8,\n      samples.length & 0xFF, // sample_count\n      (offset & 0xFF000000) >>> 24,\n      (offset & 0xFF0000) >>> 16,\n      (offset & 0xFF00) >>> 8,\n      offset & 0xFF // data_offset\n    ];\n  };\n\n  videoTrun = function(track, offset) {\n    var bytes, samples, sample, i;\n\n    samples = track.samples || [];\n    offset += 8 + 12 + (16 * samples.length);\n\n    bytes = trunHeader(samples, offset);\n\n    for (i = 0; i < samples.length; i++) {\n      sample = samples[i];\n      bytes = bytes.concat([\n        (sample.duration & 0xFF000000) >>> 24,\n        (sample.duration & 0xFF0000) >>> 16,\n        (sample.duration & 0xFF00) >>> 8,\n        sample.duration & 0xFF, // sample_duration\n        (sample.size & 0xFF000000) >>> 24,\n        (sample.size & 0xFF0000) >>> 16,\n        (sample.size & 0xFF00) >>> 8,\n        sample.size & 0xFF, // sample_size\n        (sample.flags.isLeading << 2) | sample.flags.dependsOn,\n        (sample.flags.isDependedOn << 6) |\n          (sample.flags.hasRedundancy << 4) |\n          (sample.flags.paddingValue << 1) |\n          sample.flags.isNonSyncSample,\n        sample.flags.degradationPriority & 0xF0 << 8,\n        sample.flags.degradationPriority & 0x0F, // sample_flags\n        (sample.compositionTimeOffset & 0xFF000000) >>> 24,\n        (sample.compositionTimeOffset & 0xFF0000) >>> 16,\n        (sample.compositionTimeOffset & 0xFF00) >>> 8,\n        sample.compositionTimeOffset & 0xFF // sample_composition_time_offset\n      ]);\n    }\n    return box(types.trun, new Uint8Array(bytes));\n  };\n\n  audioTrun = function(track, offset) {\n    var bytes, samples, sample, i;\n\n    samples = track.samples || [];\n    offset += 8 + 12 + (8 * samples.length);\n\n    bytes = trunHeader(samples, offset);\n\n    for (i = 0; i < samples.length; i++) {\n      sample = samples[i];\n      bytes = bytes.concat([\n        (sample.duration & 0xFF000000) >>> 24,\n        (sample.duration & 0xFF0000) >>> 16,\n        (sample.duration & 0xFF00) >>> 8,\n        sample.duration & 0xFF, // sample_duration\n        (sample.size & 0xFF000000) >>> 24,\n        (sample.size & 0xFF0000) >>> 16,\n        (sample.size & 0xFF00) >>> 8,\n        sample.size & 0xFF]); // sample_size\n    }\n\n    return box(types.trun, new Uint8Array(bytes));\n  };\n\n  trun = function(track, offset) {\n    if (track.type === 'audio') {\n      return audioTrun(track, offset);\n    }\n\n    return videoTrun(track, offset);\n  };\n}());\n\nmodule.exports = {\n  ftyp: ftyp,\n  mdat: mdat,\n  moof: moof,\n  moov: moov,\n  initSegment: function(tracks) {\n    var\n      fileType = ftyp(),\n      movie = moov(tracks),\n      result;\n\n    result = new Uint8Array(fileType.byteLength + movie.byteLength);\n    result.set(fileType);\n    result.set(movie, fileType.byteLength);\n    return result;\n  }\n};\n","/**\n * mux.js\n *\n * Copyright (c) 2015 Brightcove\n * All rights reserved.\n *\n * Reads in-band caption information from a video elementary\n * stream. Captions must follow the CEA-708 standard for injection\n * into an MPEG-2 transport streams.\n * @see https://en.wikipedia.org/wiki/CEA-708\n * @see https://www.gpo.gov/fdsys/pkg/CFR-2007-title47-vol1/pdf/CFR-2007-title47-vol1-sec15-119.pdf\n */\n\n'use strict';\n\n// -----------------\n// Link To Transport\n// -----------------\n\nvar Stream = require('../utils/stream');\nvar cea708Parser = require('../tools/caption-packet-parser');\n\nvar CaptionStream = function() {\n\n  CaptionStream.prototype.init.call(this);\n\n  this.captionPackets_ = [];\n\n  this.ccStreams_ = [\n    new Cea608Stream(0, 0), // eslint-disable-line no-use-before-define\n    new Cea608Stream(0, 1), // eslint-disable-line no-use-before-define\n    new Cea608Stream(1, 0), // eslint-disable-line no-use-before-define\n    new Cea608Stream(1, 1) // eslint-disable-line no-use-before-define\n  ];\n\n  this.reset();\n\n  // forward data and done events from CCs to this CaptionStream\n  this.ccStreams_.forEach(function(cc) {\n    cc.on('data', this.trigger.bind(this, 'data'));\n    cc.on('done', this.trigger.bind(this, 'done'));\n  }, this);\n\n};\n\nCaptionStream.prototype = new Stream();\nCaptionStream.prototype.push = function(event) {\n  var sei, userData, newCaptionPackets;\n\n  // only examine SEI NALs\n  if (event.nalUnitType !== 'sei_rbsp') {\n    return;\n  }\n\n  // parse the sei\n  sei = cea708Parser.parseSei(event.escapedRBSP);\n\n  // ignore everything but user_data_registered_itu_t_t35\n  if (sei.payloadType !== cea708Parser.USER_DATA_REGISTERED_ITU_T_T35) {\n    return;\n  }\n\n  // parse out the user data payload\n  userData = cea708Parser.parseUserData(sei);\n\n  // ignore unrecognized userData\n  if (!userData) {\n    return;\n  }\n\n  // Sometimes, the same segment # will be downloaded twice. To stop the\n  // caption data from being processed twice, we track the latest dts we've\n  // received and ignore everything with a dts before that. However, since\n  // data for a specific dts can be split across packets on either side of\n  // a segment boundary, we need to make sure we *don't* ignore the packets\n  // from the *next* segment that have dts === this.latestDts_. By constantly\n  // tracking the number of packets received with dts === this.latestDts_, we\n  // know how many should be ignored once we start receiving duplicates.\n  if (event.dts < this.latestDts_) {\n    // We've started getting older data, so set the flag.\n    this.ignoreNextEqualDts_ = true;\n    return;\n  } else if ((event.dts === this.latestDts_) && (this.ignoreNextEqualDts_)) {\n    this.numSameDts_--;\n    if (!this.numSameDts_) {\n      // We've received the last duplicate packet, time to start processing again\n      this.ignoreNextEqualDts_ = false;\n    }\n    return;\n  }\n\n  // parse out CC data packets and save them for later\n  newCaptionPackets = cea708Parser.parseCaptionPackets(event.pts, userData);\n  this.captionPackets_ = this.captionPackets_.concat(newCaptionPackets);\n  if (this.latestDts_ !== event.dts) {\n    this.numSameDts_ = 0;\n  }\n  this.numSameDts_++;\n  this.latestDts_ = event.dts;\n};\n\nCaptionStream.prototype.flush = function() {\n  // make sure we actually parsed captions before proceeding\n  if (!this.captionPackets_.length) {\n    this.ccStreams_.forEach(function(cc) {\n      cc.flush();\n    }, this);\n    return;\n  }\n\n  // In Chrome, the Array#sort function is not stable so add a\n  // presortIndex that we can use to ensure we get a stable-sort\n  this.captionPackets_.forEach(function(elem, idx) {\n    elem.presortIndex = idx;\n  });\n\n  // sort caption byte-pairs based on their PTS values\n  this.captionPackets_.sort(function(a, b) {\n    if (a.pts === b.pts) {\n      return a.presortIndex - b.presortIndex;\n    }\n    return a.pts - b.pts;\n  });\n\n  this.captionPackets_.forEach(function(packet) {\n    if (packet.type < 2) {\n      // Dispatch packet to the right Cea608Stream\n      this.dispatchCea608Packet(packet);\n    }\n    // this is where an 'else' would go for a dispatching packets\n    // to a theoretical Cea708Stream that handles SERVICEn data\n  }, this);\n\n  this.captionPackets_.length = 0;\n  this.ccStreams_.forEach(function(cc) {\n    cc.flush();\n  }, this);\n  return;\n};\n\nCaptionStream.prototype.reset = function() {\n  this.latestDts_ = null;\n  this.ignoreNextEqualDts_ = false;\n  this.numSameDts_ = 0;\n  this.activeCea608Channel_ = [null, null];\n  this.ccStreams_.forEach(function(ccStream) {\n    ccStream.reset();\n  });\n};\n\nCaptionStream.prototype.dispatchCea608Packet = function(packet) {\n  // NOTE: packet.type is the CEA608 field\n  if (this.setsChannel1Active(packet)) {\n    this.activeCea608Channel_[packet.type] = 0;\n  } else if (this.setsChannel2Active(packet)) {\n    this.activeCea608Channel_[packet.type] = 1;\n  }\n  if (this.activeCea608Channel_[packet.type] === null) {\n    // If we haven't received anything to set the active channel, discard the\n    // data; we don't want jumbled captions\n    return;\n  }\n  this.ccStreams_[(packet.type << 1) + this.activeCea608Channel_[packet.type]].push(packet);\n};\n\nCaptionStream.prototype.setsChannel1Active = function(packet) {\n  return ((packet.ccData & 0x7800) === 0x1000);\n};\nCaptionStream.prototype.setsChannel2Active = function(packet) {\n  return ((packet.ccData & 0x7800) === 0x1800);\n};\n\n// ----------------------\n// Session to Application\n// ----------------------\n\n// This hash maps non-ASCII, special, and extended character codes to their\n// proper Unicode equivalent. The first keys that are only a single byte\n// are the non-standard ASCII characters, which simply map the CEA608 byte\n// to the standard ASCII/Unicode. The two-byte keys that follow are the CEA608\n// character codes, but have their MSB bitmasked with 0x03 so that a lookup\n// can be performed regardless of the field and data channel on which the\n// character code was received.\nvar CHARACTER_TRANSLATION = {\n  0x2a: 0xe1,     // \n  0x5c: 0xe9,     // \n  0x5e: 0xed,     // \n  0x5f: 0xf3,     // \n  0x60: 0xfa,     // \n  0x7b: 0xe7,     // \n  0x7c: 0xf7,     // \n  0x7d: 0xd1,     // \n  0x7e: 0xf1,     // \n  0x7f: 0x2588,   // \n  0x0130: 0xae,   // \n  0x0131: 0xb0,   // \n  0x0132: 0xbd,   // \n  0x0133: 0xbf,   // \n  0x0134: 0x2122, // \n  0x0135: 0xa2,   // \n  0x0136: 0xa3,   // \n  0x0137: 0x266a, // \n  0x0138: 0xe0,   // \n  0x0139: 0xa0,   //\n  0x013a: 0xe8,   // \n  0x013b: 0xe2,   // \n  0x013c: 0xea,   // \n  0x013d: 0xee,   // \n  0x013e: 0xf4,   // \n  0x013f: 0xfb,   // \n  0x0220: 0xc1,   // \n  0x0221: 0xc9,   // \n  0x0222: 0xd3,   // \n  0x0223: 0xda,   // \n  0x0224: 0xdc,   // \n  0x0225: 0xfc,   // \n  0x0226: 0x2018, // \n  0x0227: 0xa1,   // \n  0x0228: 0x2a,   // *\n  0x0229: 0x27,   // '\n  0x022a: 0x2014, // \n  0x022b: 0xa9,   // \n  0x022c: 0x2120, // \n  0x022d: 0x2022, // \n  0x022e: 0x201c, // \n  0x022f: 0x201d, // \n  0x0230: 0xc0,   // \n  0x0231: 0xc2,   // \n  0x0232: 0xc7,   // \n  0x0233: 0xc8,   // \n  0x0234: 0xca,   // \n  0x0235: 0xcb,   // \n  0x0236: 0xeb,   // \n  0x0237: 0xce,   // \n  0x0238: 0xcf,   // \n  0x0239: 0xef,   // \n  0x023a: 0xd4,   // \n  0x023b: 0xd9,   // \n  0x023c: 0xf9,   // \n  0x023d: 0xdb,   // \n  0x023e: 0xab,   // \n  0x023f: 0xbb,   // \n  0x0320: 0xc3,   // \n  0x0321: 0xe3,   // \n  0x0322: 0xcd,   // \n  0x0323: 0xcc,   // \n  0x0324: 0xec,   // \n  0x0325: 0xd2,   // \n  0x0326: 0xf2,   // \n  0x0327: 0xd5,   // \n  0x0328: 0xf5,   // \n  0x0329: 0x7b,   // {\n  0x032a: 0x7d,   // }\n  0x032b: 0x5c,   // \\\n  0x032c: 0x5e,   // ^\n  0x032d: 0x5f,   // _\n  0x032e: 0x7c,   // |\n  0x032f: 0x7e,   // ~\n  0x0330: 0xc4,   // \n  0x0331: 0xe4,   // \n  0x0332: 0xd6,   // \n  0x0333: 0xf6,   // \n  0x0334: 0xdf,   // \n  0x0335: 0xa5,   // \n  0x0336: 0xa4,   // \n  0x0337: 0x2502, // \n  0x0338: 0xc5,   // \n  0x0339: 0xe5,   // \n  0x033a: 0xd8,   // \n  0x033b: 0xf8,   // \n  0x033c: 0x250c, // \n  0x033d: 0x2510, // \n  0x033e: 0x2514, // \n  0x033f: 0x2518  // \n};\n\nvar getCharFromCode = function(code) {\n  if (code === null) {\n    return '';\n  }\n  code = CHARACTER_TRANSLATION[code] || code;\n  return String.fromCharCode(code);\n};\n\n// the index of the last row in a CEA-608 display buffer\nvar BOTTOM_ROW = 14;\n\n// This array is used for mapping PACs -> row #, since there's no way of\n// getting it through bit logic.\nvar ROWS = [0x1100, 0x1120, 0x1200, 0x1220, 0x1500, 0x1520, 0x1600, 0x1620,\n            0x1700, 0x1720, 0x1000, 0x1300, 0x1320, 0x1400, 0x1420];\n\n// CEA-608 captions are rendered onto a 34x15 matrix of character\n// cells. The \"bottom\" row is the last element in the outer array.\nvar createDisplayBuffer = function() {\n  var result = [], i = BOTTOM_ROW + 1;\n  while (i--) {\n    result.push('');\n  }\n  return result;\n};\n\nvar Cea608Stream = function(field, dataChannel) {\n  Cea608Stream.prototype.init.call(this);\n\n  this.field_ = field || 0;\n  this.dataChannel_ = dataChannel || 0;\n\n  this.name_ = 'CC' + (((this.field_ << 1) | this.dataChannel_) + 1);\n\n  this.setConstants();\n  this.reset();\n\n  this.push = function(packet) {\n    var data, swap, char0, char1, text;\n    // remove the parity bits\n    data = packet.ccData & 0x7f7f;\n\n    // ignore duplicate control codes; the spec demands they're sent twice\n    if (data === this.lastControlCode_) {\n      this.lastControlCode_ = null;\n      return;\n    }\n\n    // Store control codes\n    if ((data & 0xf000) === 0x1000) {\n      this.lastControlCode_ = data;\n    } else if (data !== this.PADDING_) {\n      this.lastControlCode_ = null;\n    }\n\n    char0 = data >>> 8;\n    char1 = data & 0xff;\n\n    if (data === this.PADDING_) {\n      return;\n\n    } else if (data === this.RESUME_CAPTION_LOADING_) {\n      this.mode_ = 'popOn';\n\n    } else if (data === this.END_OF_CAPTION_) {\n      // If an EOC is received while in paint-on mode, the displayed caption\n      // text should be swapped to non-displayed memory as if it was a pop-on\n      // caption. Because of that, we should explicitly switch back to pop-on\n      // mode\n      this.mode_ = 'popOn';\n      this.clearFormatting(packet.pts);\n      // if a caption was being displayed, it's gone now\n      this.flushDisplayed(packet.pts);\n\n      // flip memory\n      swap = this.displayed_;\n      this.displayed_ = this.nonDisplayed_;\n      this.nonDisplayed_ = swap;\n\n      // start measuring the time to display the caption\n      this.startPts_ = packet.pts;\n\n    } else if (data === this.ROLL_UP_2_ROWS_) {\n      this.rollUpRows_ = 2;\n      this.setRollUp(packet.pts);\n    } else if (data === this.ROLL_UP_3_ROWS_) {\n      this.rollUpRows_ = 3;\n      this.setRollUp(packet.pts);\n    } else if (data === this.ROLL_UP_4_ROWS_) {\n      this.rollUpRows_ = 4;\n      this.setRollUp(packet.pts);\n    } else if (data === this.CARRIAGE_RETURN_) {\n      this.clearFormatting(packet.pts);\n      this.flushDisplayed(packet.pts);\n      this.shiftRowsUp_();\n      this.startPts_ = packet.pts;\n\n    } else if (data === this.BACKSPACE_) {\n      if (this.mode_ === 'popOn') {\n        this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1);\n      } else {\n        this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1);\n      }\n    } else if (data === this.ERASE_DISPLAYED_MEMORY_) {\n      this.flushDisplayed(packet.pts);\n      this.displayed_ = createDisplayBuffer();\n    } else if (data === this.ERASE_NON_DISPLAYED_MEMORY_) {\n      this.nonDisplayed_ = createDisplayBuffer();\n\n    } else if (data === this.RESUME_DIRECT_CAPTIONING_) {\n      if (this.mode_ !== 'paintOn') {\n        // NOTE: This should be removed when proper caption positioning is\n        // implemented\n        this.flushDisplayed(packet.pts);\n        this.displayed_ = createDisplayBuffer();\n      }\n      this.mode_ = 'paintOn';\n      this.startPts_ = packet.pts;\n\n    // Append special characters to caption text\n    } else if (this.isSpecialCharacter(char0, char1)) {\n      // Bitmask char0 so that we can apply character transformations\n      // regardless of field and data channel.\n      // Then byte-shift to the left and OR with char1 so we can pass the\n      // entire character code to `getCharFromCode`.\n      char0 = (char0 & 0x03) << 8;\n      text = getCharFromCode(char0 | char1);\n      this[this.mode_](packet.pts, text);\n      this.column_++;\n\n    // Append extended characters to caption text\n    } else if (this.isExtCharacter(char0, char1)) {\n      // Extended characters always follow their \"non-extended\" equivalents.\n      // IE if a \"\" is desired, you'll always receive \"e\"; non-compliant\n      // decoders are supposed to drop the \"\", while compliant decoders\n      // backspace the \"e\" and insert \"\".\n\n      // Delete the previous character\n      if (this.mode_ === 'popOn') {\n        this.nonDisplayed_[this.row_] = this.nonDisplayed_[this.row_].slice(0, -1);\n      } else {\n        this.displayed_[this.row_] = this.displayed_[this.row_].slice(0, -1);\n      }\n\n      // Bitmask char0 so that we can apply character transformations\n      // regardless of field and data channel.\n      // Then byte-shift to the left and OR with char1 so we can pass the\n      // entire character code to `getCharFromCode`.\n      char0 = (char0 & 0x03) << 8;\n      text = getCharFromCode(char0 | char1);\n      this[this.mode_](packet.pts, text);\n      this.column_++;\n\n    // Process mid-row codes\n    } else if (this.isMidRowCode(char0, char1)) {\n      // Attributes are not additive, so clear all formatting\n      this.clearFormatting(packet.pts);\n\n      // According to the standard, mid-row codes\n      // should be replaced with spaces, so add one now\n      this[this.mode_](packet.pts, ' ');\n      this.column_++;\n\n      if ((char1 & 0xe) === 0xe) {\n        this.addFormatting(packet.pts, ['i']);\n      }\n\n      if ((char1 & 0x1) === 0x1) {\n        this.addFormatting(packet.pts, ['u']);\n      }\n\n    // Detect offset control codes and adjust cursor\n    } else if (this.isOffsetControlCode(char0, char1)) {\n      // Cursor position is set by indent PAC (see below) in 4-column\n      // increments, with an additional offset code of 1-3 to reach any\n      // of the 32 columns specified by CEA-608. So all we need to do\n      // here is increment the column cursor by the given offset.\n      this.column_ += (char1 & 0x03);\n\n    // Detect PACs (Preamble Address Codes)\n    } else if (this.isPAC(char0, char1)) {\n\n      // There's no logic for PAC -> row mapping, so we have to just\n      // find the row code in an array and use its index :(\n      var row = ROWS.indexOf(data & 0x1f20);\n\n      // Configure the caption window if we're in roll-up mode\n      if (this.mode_ === 'rollUp') {\n        // This implies that the base row is incorrectly set.\n        // As per the recommendation in CEA-608(Base Row Implementation), defer to the number\n        // of roll-up rows set.\n        if (row - this.rollUpRows_ + 1 < 0) {\n          row = this.rollUpRows_ - 1;\n        }\n\n        this.setRollUp(packet.pts, row);\n      }\n\n      if (row !== this.row_) {\n        // formatting is only persistent for current row\n        this.clearFormatting(packet.pts);\n        this.row_ = row;\n      }\n      // All PACs can apply underline, so detect and apply\n      // (All odd-numbered second bytes set underline)\n      if ((char1 & 0x1) && (this.formatting_.indexOf('u') === -1)) {\n          this.addFormatting(packet.pts, ['u']);\n      }\n\n      if ((data & 0x10) === 0x10) {\n        // We've got an indent level code. Each successive even number\n        // increments the column cursor by 4, so we can get the desired\n        // column position by bit-shifting to the right (to get n/2)\n        // and multiplying by 4.\n        this.column_ = ((data & 0xe) >> 1) * 4;\n      }\n\n      if (this.isColorPAC(char1)) {\n        // it's a color code, though we only support white, which\n        // can be either normal or italicized. white italics can be\n        // either 0x4e or 0x6e depending on the row, so we just\n        // bitwise-and with 0xe to see if italics should be turned on\n        if ((char1 & 0xe) === 0xe) {\n          this.addFormatting(packet.pts, ['i']);\n        }\n      }\n\n    // We have a normal character in char0, and possibly one in char1\n    } else if (this.isNormalChar(char0)) {\n      if (char1 === 0x00) {\n        char1 = null;\n      }\n      text = getCharFromCode(char0);\n      text += getCharFromCode(char1);\n      this[this.mode_](packet.pts, text);\n      this.column_ += text.length;\n\n    } // finish data processing\n\n  };\n};\nCea608Stream.prototype = new Stream();\n// Trigger a cue point that captures the current state of the\n// display buffer\nCea608Stream.prototype.flushDisplayed = function(pts) {\n  var content = this.displayed_\n    // remove spaces from the start and end of the string\n    .map(function(row) {\n      try {\n        return row.trim();\n      } catch (e) {\n        // Ordinarily, this shouldn't happen. However, caption\n        // parsing errors should not throw exceptions and\n        // break playback.\n        // eslint-disable-next-line no-console\n        console.error('Skipping malformed caption.');\n        return '';\n      }\n    })\n    // combine all text rows to display in one cue\n    .join('\\n')\n    // and remove blank rows from the start and end, but not the middle\n    .replace(/^\\n+|\\n+$/g, '');\n\n  if (content.length) {\n    this.trigger('data', {\n      startPts: this.startPts_,\n      endPts: pts,\n      text: content,\n      stream: this.name_\n    });\n  }\n};\n\n/**\n * Zero out the data, used for startup and on seek\n */\nCea608Stream.prototype.reset = function() {\n  this.mode_ = 'popOn';\n  // When in roll-up mode, the index of the last row that will\n  // actually display captions. If a caption is shifted to a row\n  // with a lower index than this, it is cleared from the display\n  // buffer\n  this.topRow_ = 0;\n  this.startPts_ = 0;\n  this.displayed_ = createDisplayBuffer();\n  this.nonDisplayed_ = createDisplayBuffer();\n  this.lastControlCode_ = null;\n\n  // Track row and column for proper line-breaking and spacing\n  this.column_ = 0;\n  this.row_ = BOTTOM_ROW;\n  this.rollUpRows_ = 2;\n\n  // This variable holds currently-applied formatting\n  this.formatting_ = [];\n};\n\n/**\n * Sets up control code and related constants for this instance\n */\nCea608Stream.prototype.setConstants = function() {\n  // The following attributes have these uses:\n  // ext_ :    char0 for mid-row codes, and the base for extended\n  //           chars (ext_+0, ext_+1, and ext_+2 are char0s for\n  //           extended codes)\n  // control_: char0 for control codes, except byte-shifted to the\n  //           left so that we can do this.control_ | CONTROL_CODE\n  // offset_:  char0 for tab offset codes\n  //\n  // It's also worth noting that control codes, and _only_ control codes,\n  // differ between field 1 and field2. Field 2 control codes are always\n  // their field 1 value plus 1. That's why there's the \"| field\" on the\n  // control value.\n  if (this.dataChannel_ === 0) {\n    this.BASE_     = 0x10;\n    this.EXT_      = 0x11;\n    this.CONTROL_  = (0x14 | this.field_) << 8;\n    this.OFFSET_   = 0x17;\n  } else if (this.dataChannel_ === 1) {\n    this.BASE_     = 0x18;\n    this.EXT_      = 0x19;\n    this.CONTROL_  = (0x1c | this.field_) << 8;\n    this.OFFSET_   = 0x1f;\n  }\n\n  // Constants for the LSByte command codes recognized by Cea608Stream. This\n  // list is not exhaustive. For a more comprehensive listing and semantics see\n  // http://www.gpo.gov/fdsys/pkg/CFR-2010-title47-vol1/pdf/CFR-2010-title47-vol1-sec15-119.pdf\n  // Padding\n  this.PADDING_                    = 0x0000;\n  // Pop-on Mode\n  this.RESUME_CAPTION_LOADING_     = this.CONTROL_ | 0x20;\n  this.END_OF_CAPTION_             = this.CONTROL_ | 0x2f;\n  // Roll-up Mode\n  this.ROLL_UP_2_ROWS_             = this.CONTROL_ | 0x25;\n  this.ROLL_UP_3_ROWS_             = this.CONTROL_ | 0x26;\n  this.ROLL_UP_4_ROWS_             = this.CONTROL_ | 0x27;\n  this.CARRIAGE_RETURN_            = this.CONTROL_ | 0x2d;\n  // paint-on mode\n  this.RESUME_DIRECT_CAPTIONING_   = this.CONTROL_ | 0x29;\n  // Erasure\n  this.BACKSPACE_                  = this.CONTROL_ | 0x21;\n  this.ERASE_DISPLAYED_MEMORY_     = this.CONTROL_ | 0x2c;\n  this.ERASE_NON_DISPLAYED_MEMORY_ = this.CONTROL_ | 0x2e;\n};\n\n/**\n * Detects if the 2-byte packet data is a special character\n *\n * Special characters have a second byte in the range 0x30 to 0x3f,\n * with the first byte being 0x11 (for data channel 1) or 0x19 (for\n * data channel 2).\n *\n * @param  {Integer} char0 The first byte\n * @param  {Integer} char1 The second byte\n * @return {Boolean}       Whether the 2 bytes are an special character\n */\nCea608Stream.prototype.isSpecialCharacter = function(char0, char1) {\n  return (char0 === this.EXT_ && char1 >= 0x30 && char1 <= 0x3f);\n};\n\n/**\n * Detects if the 2-byte packet data is an extended character\n *\n * Extended characters have a second byte in the range 0x20 to 0x3f,\n * with the first byte being 0x12 or 0x13 (for data channel 1) or\n * 0x1a or 0x1b (for data channel 2).\n *\n * @param  {Integer} char0 The first byte\n * @param  {Integer} char1 The second byte\n * @return {Boolean}       Whether the 2 bytes are an extended character\n */\nCea608Stream.prototype.isExtCharacter = function(char0, char1) {\n  return ((char0 === (this.EXT_ + 1) || char0 === (this.EXT_ + 2)) &&\n    (char1 >= 0x20 && char1 <= 0x3f));\n};\n\n/**\n * Detects if the 2-byte packet is a mid-row code\n *\n * Mid-row codes have a second byte in the range 0x20 to 0x2f, with\n * the first byte being 0x11 (for data channel 1) or 0x19 (for data\n * channel 2).\n *\n * @param  {Integer} char0 The first byte\n * @param  {Integer} char1 The second byte\n * @return {Boolean}       Whether the 2 bytes are a mid-row code\n */\nCea608Stream.prototype.isMidRowCode = function(char0, char1) {\n  return (char0 === this.EXT_ && (char1 >= 0x20 && char1 <= 0x2f));\n};\n\n/**\n * Detects if the 2-byte packet is an offset control code\n *\n * Offset control codes have a second byte in the range 0x21 to 0x23,\n * with the first byte being 0x17 (for data channel 1) or 0x1f (for\n * data channel 2).\n *\n * @param  {Integer} char0 The first byte\n * @param  {Integer} char1 The second byte\n * @return {Boolean}       Whether the 2 bytes are an offset control code\n */\nCea608Stream.prototype.isOffsetControlCode = function(char0, char1) {\n  return (char0 === this.OFFSET_ && (char1 >= 0x21 && char1 <= 0x23));\n};\n\n/**\n * Detects if the 2-byte packet is a Preamble Address Code\n *\n * PACs have a first byte in the range 0x10 to 0x17 (for data channel 1)\n * or 0x18 to 0x1f (for data channel 2), with the second byte in the\n * range 0x40 to 0x7f.\n *\n * @param  {Integer} char0 The first byte\n * @param  {Integer} char1 The second byte\n * @return {Boolean}       Whether the 2 bytes are a PAC\n */\nCea608Stream.prototype.isPAC = function(char0, char1) {\n  return (char0 >= this.BASE_ && char0 < (this.BASE_ + 8) &&\n    (char1 >= 0x40 && char1 <= 0x7f));\n};\n\n/**\n * Detects if a packet's second byte is in the range of a PAC color code\n *\n * PAC color codes have the second byte be in the range 0x40 to 0x4f, or\n * 0x60 to 0x6f.\n *\n * @param  {Integer} char1 The second byte\n * @return {Boolean}       Whether the byte is a color PAC\n */\nCea608Stream.prototype.isColorPAC = function(char1) {\n  return ((char1 >= 0x40 && char1 <= 0x4f) || (char1 >= 0x60 && char1 <= 0x7f));\n};\n\n/**\n * Detects if a single byte is in the range of a normal character\n *\n * Normal text bytes are in the range 0x20 to 0x7f.\n *\n * @param  {Integer} char  The byte\n * @return {Boolean}       Whether the byte is a normal character\n */\nCea608Stream.prototype.isNormalChar = function(char) {\n  return (char >= 0x20 && char <= 0x7f);\n};\n\n/**\n * Configures roll-up\n *\n * @param  {Integer} pts         Current PTS\n * @param  {Integer} newBaseRow  Used by PACs to slide the current window to\n *                               a new position\n */\nCea608Stream.prototype.setRollUp = function(pts, newBaseRow) {\n  // Reset the base row to the bottom row when switching modes\n  if (this.mode_ !== 'rollUp') {\n    this.row_ = BOTTOM_ROW;\n    this.mode_ = 'rollUp';\n    // Spec says to wipe memories when switching to roll-up\n    this.flushDisplayed(pts);\n    this.nonDisplayed_ = createDisplayBuffer();\n    this.displayed_ = createDisplayBuffer();\n  }\n\n  if (newBaseRow !== undefined && newBaseRow !== this.row_) {\n    // move currently displayed captions (up or down) to the new base row\n    for (var i = 0; i < this.rollUpRows_; i++) {\n      this.displayed_[newBaseRow - i] = this.displayed_[this.row_ - i];\n      this.displayed_[this.row_ - i] = '';\n    }\n  }\n\n  if (newBaseRow === undefined) {\n    newBaseRow = this.row_;\n  }\n\n  this.topRow_ = newBaseRow - this.rollUpRows_ + 1;\n};\n\n// Adds the opening HTML tag for the passed character to the caption text,\n// and keeps track of it for later closing\nCea608Stream.prototype.addFormatting = function(pts, format) {\n  this.formatting_ = this.formatting_.concat(format);\n  var text = format.reduce(function(text, format) {\n    return text + '<' + format + '>';\n  }, '');\n  this[this.mode_](pts, text);\n};\n\n// Adds HTML closing tags for current formatting to caption text and\n// clears remembered formatting\nCea608Stream.prototype.clearFormatting = function(pts) {\n  if (!this.formatting_.length) {\n    return;\n  }\n  var text = this.formatting_.reverse().reduce(function(text, format) {\n    return text + '</' + format + '>';\n  }, '');\n  this.formatting_ = [];\n  this[this.mode_](pts, text);\n};\n\n// Mode Implementations\nCea608Stream.prototype.popOn = function(pts, text) {\n  var baseRow = this.nonDisplayed_[this.row_];\n\n  // buffer characters\n  baseRow += text;\n  this.nonDisplayed_[this.row_] = baseRow;\n};\n\nCea608Stream.prototype.rollUp = function(pts, text) {\n  var baseRow = this.displayed_[this.row_];\n\n  baseRow += text;\n  this.displayed_[this.row_] = baseRow;\n\n};\n\nCea608Stream.prototype.shiftRowsUp_ = function() {\n  var i;\n  // clear out inactive rows\n  for (i = 0; i < this.topRow_; i++) {\n    this.displayed_[i] = '';\n  }\n  for (i = this.row_ + 1; i < BOTTOM_ROW + 1; i++) {\n    this.displayed_[i] = '';\n  }\n  // shift displayed rows up\n  for (i = this.topRow_; i < this.row_; i++) {\n    this.displayed_[i] = this.displayed_[i + 1];\n  }\n  // clear out the bottom row\n  this.displayed_[this.row_] = '';\n};\n\nCea608Stream.prototype.paintOn = function(pts, text) {\n  var baseRow = this.displayed_[this.row_];\n\n  baseRow += text;\n  this.displayed_[this.row_] = baseRow;\n};\n\n// exports\nmodule.exports = {\n  CaptionStream: CaptionStream,\n  Cea608Stream: Cea608Stream\n};\n","/**\n * mux.js\n *\n * Copyright (c) 2015 Brightcove\n * All rights reserved.\n *\n * Reads in-band caption information from a video elementary\n * stream. Captions must follow the CEA-708 standard for injection\n * into an MPEG-2 transport streams.\n * @see https://en.wikipedia.org/wiki/CEA-708\n * @see https://www.gpo.gov/fdsys/pkg/CFR-2007-title47-vol1/pdf/CFR-2007-title47-vol1-sec15-119.pdf\n */\n\n'use strict';\n\n// Supplemental enhancement information (SEI) NAL units have a\n// payload type field to indicate how they are to be\n// interpreted. CEAS-708 caption content is always transmitted with\n// payload type 0x04.\nvar USER_DATA_REGISTERED_ITU_T_T35 = 4,\n    RBSP_TRAILING_BITS = 128;\n\n/**\n  * Parse a supplemental enhancement information (SEI) NAL unit.\n  * Stops parsing once a message of type ITU T T35 has been found.\n  *\n  * @param bytes {Uint8Array} the bytes of a SEI NAL unit\n  * @return {object} the parsed SEI payload\n  * @see Rec. ITU-T H.264, 7.3.2.3.1\n  */\nvar parseSei = function(bytes) {\n  var\n    i = 0,\n    result = {\n      payloadType: -1,\n      payloadSize: 0\n    },\n    payloadType = 0,\n    payloadSize = 0;\n\n  // go through the sei_rbsp parsing each each individual sei_message\n  while (i < bytes.byteLength) {\n    // stop once we have hit the end of the sei_rbsp\n    if (bytes[i] === RBSP_TRAILING_BITS) {\n      break;\n    }\n\n    // Parse payload type\n    while (bytes[i] === 0xFF) {\n      payloadType += 255;\n      i++;\n    }\n    payloadType += bytes[i++];\n\n    // Parse payload size\n    while (bytes[i] === 0xFF) {\n      payloadSize += 255;\n      i++;\n    }\n    payloadSize += bytes[i++];\n\n    // this sei_message is a 608/708 caption so save it and break\n    // there can only ever be one caption message in a frame's sei\n    if (!result.payload && payloadType === USER_DATA_REGISTERED_ITU_T_T35) {\n      result.payloadType = payloadType;\n      result.payloadSize = payloadSize;\n      result.payload = bytes.subarray(i, i + payloadSize);\n      break;\n    }\n\n    // skip the payload and parse the next message\n    i += payloadSize;\n    payloadType = 0;\n    payloadSize = 0;\n  }\n\n  return result;\n};\n\n// see ANSI/SCTE 128-1 (2013), section 8.1\nvar parseUserData = function(sei) {\n  // itu_t_t35_contry_code must be 181 (United States) for\n  // captions\n  if (sei.payload[0] !== 181) {\n    return null;\n  }\n\n  // itu_t_t35_provider_code should be 49 (ATSC) for captions\n  if (((sei.payload[1] << 8) | sei.payload[2]) !== 49) {\n    return null;\n  }\n\n  // the user_identifier should be \"GA94\" to indicate ATSC1 data\n  if (String.fromCharCode(sei.payload[3],\n                          sei.payload[4],\n                          sei.payload[5],\n                          sei.payload[6]) !== 'GA94') {\n    return null;\n  }\n\n  // finally, user_data_type_code should be 0x03 for caption data\n  if (sei.payload[7] !== 0x03) {\n    return null;\n  }\n\n  // return the user_data_type_structure and strip the trailing\n  // marker bits\n  return sei.payload.subarray(8, sei.payload.length - 1);\n};\n\n// see CEA-708-D, section 4.4\nvar parseCaptionPackets = function(pts, userData) {\n  var results = [], i, count, offset, data;\n\n  // if this is just filler, return immediately\n  if (!(userData[0] & 0x40)) {\n    return results;\n  }\n\n  // parse out the cc_data_1 and cc_data_2 fields\n  count = userData[0] & 0x1f;\n  for (i = 0; i < count; i++) {\n    offset = i * 3;\n    data = {\n      type: userData[offset + 2] & 0x03,\n      pts: pts\n    };\n\n    // capture cc data when cc_valid is 1\n    if (userData[offset + 2] & 0x04) {\n      data.ccData = (userData[offset + 3] << 8) | userData[offset + 4];\n      results.push(data);\n    }\n  }\n  return results;\n};\n\nvar discardEmulationPreventionBytes = function(data) {\n    var\n      length = data.byteLength,\n      emulationPreventionBytesPositions = [],\n      i = 1,\n      newLength, newData;\n\n    // Find all `Emulation Prevention Bytes`\n    while (i < length - 2) {\n      if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\n        emulationPreventionBytesPositions.push(i + 2);\n        i += 2;\n      } else {\n        i++;\n      }\n    }\n\n    // If no Emulation Prevention Bytes were found just return the original\n    // array\n    if (emulationPreventionBytesPositions.length === 0) {\n      return data;\n    }\n\n    // Create a new array to hold the NAL unit data\n    newLength = length - emulationPreventionBytesPositions.length;\n    newData = new Uint8Array(newLength);\n    var sourceIndex = 0;\n\n    for (i = 0; i < newLength; sourceIndex++, i++) {\n      if (sourceIndex === emulationPreventionBytesPositions[0]) {\n        // Skip this byte\n        sourceIndex++;\n        // Remove this position index\n        emulationPreventionBytesPositions.shift();\n      }\n      newData[i] = data[sourceIndex];\n    }\n\n    return newData;\n};\n\n// exports\nmodule.exports = {\n  parseSei: parseSei,\n  parseUserData: parseUserData,\n  parseCaptionPackets: parseCaptionPackets,\n  discardEmulationPreventionBytes: discardEmulationPreventionBytes,\n  USER_DATA_REGISTERED_ITU_T_T35: USER_DATA_REGISTERED_ITU_T_T35\n};\n","/**\n * mux.js\n *\n * Copyright (c) 2016 Brightcove\n * All rights reserved.\n *\n * Accepts program elementary stream (PES) data events and corrects\n * decode and presentation time stamps to account for a rollover\n * of the 33 bit value.\n */\n\n'use strict';\n\nvar Stream = require('../utils/stream');\n\nvar MAX_TS = 8589934592;\n\nvar RO_THRESH = 4294967296;\n\nvar handleRollover = function(value, reference) {\n  var direction = 1;\n\n  if (value > reference) {\n    // If the current timestamp value is greater than our reference timestamp and we detect a\n    // timestamp rollover, this means the roll over is happening in the opposite direction.\n    // Example scenario: Enter a long stream/video just after a rollover occurred. The reference\n    // point will be set to a small number, e.g. 1. The user then seeks backwards over the\n    // rollover point. In loading this segment, the timestamp values will be very large,\n    // e.g. 2^33 - 1. Since this comes before the data we loaded previously, we want to adjust\n    // the time stamp to be `value - 2^33`.\n    direction = -1;\n  }\n\n  // Note: A seek forwards or back that is greater than the RO_THRESH (2^32, ~13 hours) will\n  // cause an incorrect adjustment.\n  while (Math.abs(reference - value) > RO_THRESH) {\n    value += (direction * MAX_TS);\n  }\n\n  return value;\n};\n\nvar TimestampRolloverStream = function(type) {\n  var lastDTS, referenceDTS;\n\n  TimestampRolloverStream.prototype.init.call(this);\n\n  this.type_ = type;\n\n  this.push = function(data) {\n    if (data.type !== this.type_) {\n      return;\n    }\n\n    if (referenceDTS === undefined) {\n      referenceDTS = data.dts;\n    }\n\n    data.dts = handleRollover(data.dts, referenceDTS);\n    data.pts = handleRollover(data.pts, referenceDTS);\n\n    lastDTS = data.dts;\n\n    this.trigger('data', data);\n  };\n\n  this.flush = function() {\n    referenceDTS = lastDTS;\n    this.trigger('done');\n  };\n\n  this.discontinuity = function() {\n    referenceDTS = void 0;\n    lastDTS = void 0;\n  };\n\n};\n\nTimestampRolloverStream.prototype = new Stream();\n\nmodule.exports = {\n  TimestampRolloverStream: TimestampRolloverStream,\n  handleRollover: handleRollover\n};\n","/**\n * mux.js\n *\n * Copyright (c) 2015 Brightcove\n * All rights reserved.\n *\n * Parse the internal MP4 structure into an equivalent javascript\n * object.\n */\n'use strict';\n\nvar\n  inspectMp4,\n  textifyMp4,\n\n  parseType = require('../mp4/probe').parseType,\n  parseMp4Date = function(seconds) {\n    return new Date(seconds * 1000 - 2082844800000);\n  },\n  parseSampleFlags = function(flags) {\n    return {\n      isLeading: (flags[0] & 0x0c) >>> 2,\n      dependsOn: flags[0] & 0x03,\n      isDependedOn: (flags[1] & 0xc0) >>> 6,\n      hasRedundancy: (flags[1] & 0x30) >>> 4,\n      paddingValue: (flags[1] & 0x0e) >>> 1,\n      isNonSyncSample: flags[1] & 0x01,\n      degradationPriority: (flags[2] << 8) | flags[3]\n    };\n  },\n  nalParse = function(avcStream) {\n    var\n      avcView = new DataView(avcStream.buffer, avcStream.byteOffset, avcStream.byteLength),\n      result = [],\n      i,\n      length;\n    for (i = 0; i + 4 < avcStream.length; i += length) {\n      length = avcView.getUint32(i);\n      i += 4;\n\n      // bail if this doesn't appear to be an H264 stream\n      if (length <= 0) {\n        result.push('<span style=\\'color:red;\\'>MALFORMED DATA</span>');\n        continue;\n      }\n\n      switch (avcStream[i] & 0x1F) {\n      case 0x01:\n        result.push('slice_layer_without_partitioning_rbsp');\n        break;\n      case 0x05:\n        result.push('slice_layer_without_partitioning_rbsp_idr');\n        break;\n      case 0x06:\n        result.push('sei_rbsp');\n        break;\n      case 0x07:\n        result.push('seq_parameter_set_rbsp');\n        break;\n      case 0x08:\n        result.push('pic_parameter_set_rbsp');\n        break;\n      case 0x09:\n        result.push('access_unit_delimiter_rbsp');\n        break;\n      default:\n        result.push('UNKNOWN NAL - ' + avcStream[i] & 0x1F);\n        break;\n      }\n    }\n    return result;\n  },\n\n  // registry of handlers for individual mp4 box types\n  parse = {\n    // codingname, not a first-class box type. stsd entries share the\n    // same format as real boxes so the parsing infrastructure can be\n    // shared\n    avc1: function(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n      return {\n        dataReferenceIndex: view.getUint16(6),\n        width: view.getUint16(24),\n        height: view.getUint16(26),\n        horizresolution: view.getUint16(28) + (view.getUint16(30) / 16),\n        vertresolution: view.getUint16(32) + (view.getUint16(34) / 16),\n        frameCount: view.getUint16(40),\n        depth: view.getUint16(74),\n        config: inspectMp4(data.subarray(78, data.byteLength))\n      };\n    },\n    avcC: function(data) {\n      var\n        view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n          configurationVersion: data[0],\n          avcProfileIndication: data[1],\n          profileCompatibility: data[2],\n          avcLevelIndication: data[3],\n          lengthSizeMinusOne: data[4] & 0x03,\n          sps: [],\n          pps: []\n        },\n        numOfSequenceParameterSets = data[5] & 0x1f,\n        numOfPictureParameterSets,\n        nalSize,\n        offset,\n        i;\n\n      // iterate past any SPSs\n      offset = 6;\n      for (i = 0; i < numOfSequenceParameterSets; i++) {\n        nalSize = view.getUint16(offset);\n        offset += 2;\n        result.sps.push(new Uint8Array(data.subarray(offset, offset + nalSize)));\n        offset += nalSize;\n      }\n      // iterate past any PPSs\n      numOfPictureParameterSets = data[offset];\n      offset++;\n      for (i = 0; i < numOfPictureParameterSets; i++) {\n        nalSize = view.getUint16(offset);\n        offset += 2;\n        result.pps.push(new Uint8Array(data.subarray(offset, offset + nalSize)));\n        offset += nalSize;\n      }\n      return result;\n    },\n    btrt: function(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n      return {\n        bufferSizeDB: view.getUint32(0),\n        maxBitrate: view.getUint32(4),\n        avgBitrate: view.getUint32(8)\n      };\n    },\n    esds: function(data) {\n      return {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        esId: (data[6] << 8) | data[7],\n        streamPriority: data[8] & 0x1f,\n        decoderConfig: {\n          objectProfileIndication: data[11],\n          streamType: (data[12] >>> 2) & 0x3f,\n          bufferSize: (data[13] << 16) | (data[14] << 8) | data[15],\n          maxBitrate: (data[16] << 24) |\n            (data[17] << 16) |\n            (data[18] <<  8) |\n            data[19],\n          avgBitrate: (data[20] << 24) |\n            (data[21] << 16) |\n            (data[22] <<  8) |\n            data[23],\n          decoderConfigDescriptor: {\n            tag: data[24],\n            length: data[25],\n            audioObjectType: (data[26] >>> 3) & 0x1f,\n            samplingFrequencyIndex: ((data[26] & 0x07) << 1) |\n              ((data[27] >>> 7) & 0x01),\n            channelConfiguration: (data[27] >>> 3) & 0x0f\n          }\n        }\n      };\n    },\n    ftyp: function(data) {\n      var\n        view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n          majorBrand: parseType(data.subarray(0, 4)),\n          minorVersion: view.getUint32(4),\n          compatibleBrands: []\n        },\n        i = 8;\n      while (i < data.byteLength) {\n        result.compatibleBrands.push(parseType(data.subarray(i, i + 4)));\n        i += 4;\n      }\n      return result;\n    },\n    dinf: function(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    dref: function(data) {\n      return {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        dataReferences: inspectMp4(data.subarray(8))\n      };\n    },\n    hdlr: function(data) {\n      var\n        view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n          version: view.getUint8(0),\n          flags: new Uint8Array(data.subarray(1, 4)),\n          handlerType: parseType(data.subarray(8, 12)),\n          name: ''\n        },\n        i = 8;\n\n      // parse out the name field\n      for (i = 24; i < data.byteLength; i++) {\n        if (data[i] === 0x00) {\n          // the name field is null-terminated\n          i++;\n          break;\n        }\n        result.name += String.fromCharCode(data[i]);\n      }\n      // decode UTF-8 to javascript's internal representation\n      // see http://ecmanaut.blogspot.com/2006/07/encoding-decoding-utf8-in-javascript.html\n      result.name = decodeURIComponent(escape(result.name));\n\n      return result;\n    },\n    mdat: function(data) {\n      return {\n        byteLength: data.byteLength,\n        nals: nalParse(data)\n      };\n    },\n    mdhd: function(data) {\n      var\n        view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        i = 4,\n        language,\n        result = {\n          version: view.getUint8(0),\n          flags: new Uint8Array(data.subarray(1, 4)),\n          language: ''\n        };\n      if (result.version === 1) {\n        i += 4;\n        result.creationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes\n        i += 8;\n        result.modificationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes\n        i += 4;\n        result.timescale = view.getUint32(i);\n        i += 8;\n        result.duration = view.getUint32(i); // truncating top 4 bytes\n      } else {\n        result.creationTime = parseMp4Date(view.getUint32(i));\n        i += 4;\n        result.modificationTime = parseMp4Date(view.getUint32(i));\n        i += 4;\n        result.timescale = view.getUint32(i);\n        i += 4;\n        result.duration = view.getUint32(i);\n      }\n      i += 4;\n      // language is stored as an ISO-639-2/T code in an array of three 5-bit fields\n      // each field is the packed difference between its ASCII value and 0x60\n      language = view.getUint16(i);\n      result.language += String.fromCharCode((language >> 10) + 0x60);\n      result.language += String.fromCharCode(((language & 0x03e0) >> 5) + 0x60);\n      result.language += String.fromCharCode((language & 0x1f) + 0x60);\n\n      return result;\n    },\n    mdia: function(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    mfhd: function(data) {\n      return {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        sequenceNumber: (data[4] << 24) |\n          (data[5] << 16) |\n          (data[6] << 8) |\n          (data[7])\n      };\n    },\n    minf: function(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    // codingname, not a first-class box type. stsd entries share the\n    // same format as real boxes so the parsing infrastructure can be\n    // shared\n    mp4a: function(data) {\n      var\n        view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n          // 6 bytes reserved\n          dataReferenceIndex: view.getUint16(6),\n          // 4 + 4 bytes reserved\n          channelcount: view.getUint16(16),\n          samplesize: view.getUint16(18),\n          // 2 bytes pre_defined\n          // 2 bytes reserved\n          samplerate: view.getUint16(24) + (view.getUint16(26) / 65536)\n        };\n\n      // if there are more bytes to process, assume this is an ISO/IEC\n      // 14496-14 MP4AudioSampleEntry and parse the ESDBox\n      if (data.byteLength > 28) {\n        result.streamDescriptor = inspectMp4(data.subarray(28))[0];\n      }\n      return result;\n    },\n    moof: function(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    moov: function(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    mvex: function(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    mvhd: function(data) {\n      var\n        view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        i = 4,\n        result = {\n          version: view.getUint8(0),\n          flags: new Uint8Array(data.subarray(1, 4))\n        };\n\n      if (result.version === 1) {\n        i += 4;\n        result.creationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes\n        i += 8;\n        result.modificationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes\n        i += 4;\n        result.timescale = view.getUint32(i);\n        i += 8;\n        result.duration = view.getUint32(i); // truncating top 4 bytes\n      } else {\n        result.creationTime = parseMp4Date(view.getUint32(i));\n        i += 4;\n        result.modificationTime = parseMp4Date(view.getUint32(i));\n        i += 4;\n        result.timescale = view.getUint32(i);\n        i += 4;\n        result.duration = view.getUint32(i);\n      }\n      i += 4;\n\n      // convert fixed-point, base 16 back to a number\n      result.rate = view.getUint16(i) + (view.getUint16(i + 2) / 16);\n      i += 4;\n      result.volume = view.getUint8(i) + (view.getUint8(i + 1) / 8);\n      i += 2;\n      i += 2;\n      i += 2 * 4;\n      result.matrix = new Uint32Array(data.subarray(i, i + (9 * 4)));\n      i += 9 * 4;\n      i += 6 * 4;\n      result.nextTrackId = view.getUint32(i);\n      return result;\n    },\n    pdin: function(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n      return {\n        version: view.getUint8(0),\n        flags: new Uint8Array(data.subarray(1, 4)),\n        rate: view.getUint32(4),\n        initialDelay: view.getUint32(8)\n      };\n    },\n    sdtp: function(data) {\n      var\n        result = {\n          version: data[0],\n          flags: new Uint8Array(data.subarray(1, 4)),\n          samples: []\n        }, i;\n\n      for (i = 4; i < data.byteLength; i++) {\n        result.samples.push({\n          dependsOn: (data[i] & 0x30) >> 4,\n          isDependedOn: (data[i] & 0x0c) >> 2,\n          hasRedundancy: data[i] & 0x03\n        });\n      }\n      return result;\n    },\n    sidx: function(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n          result = {\n            version: data[0],\n            flags: new Uint8Array(data.subarray(1, 4)),\n            references: [],\n            referenceId: view.getUint32(4),\n            timescale: view.getUint32(8),\n            earliestPresentationTime: view.getUint32(12),\n            firstOffset: view.getUint32(16)\n          },\n          referenceCount = view.getUint16(22),\n          i;\n\n      for (i = 24; referenceCount; i += 12, referenceCount--) {\n        result.references.push({\n          referenceType: (data[i] & 0x80) >>> 7,\n          referencedSize: view.getUint32(i) & 0x7FFFFFFF,\n          subsegmentDuration: view.getUint32(i + 4),\n          startsWithSap: !!(data[i + 8] & 0x80),\n          sapType: (data[i + 8] & 0x70) >>> 4,\n          sapDeltaTime: view.getUint32(i + 8) & 0x0FFFFFFF\n        });\n      }\n\n      return result;\n    },\n    smhd: function(data) {\n      return {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        balance: data[4] + (data[5] / 256)\n      };\n    },\n    stbl: function(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    stco: function(data) {\n      var\n        view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n          version: data[0],\n          flags: new Uint8Array(data.subarray(1, 4)),\n          chunkOffsets: []\n        },\n        entryCount = view.getUint32(4),\n        i;\n      for (i = 8; entryCount; i += 4, entryCount--) {\n        result.chunkOffsets.push(view.getUint32(i));\n      }\n      return result;\n    },\n    stsc: function(data) {\n      var\n        view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        entryCount = view.getUint32(4),\n        result = {\n          version: data[0],\n          flags: new Uint8Array(data.subarray(1, 4)),\n          sampleToChunks: []\n        },\n        i;\n      for (i = 8; entryCount; i += 12, entryCount--) {\n        result.sampleToChunks.push({\n          firstChunk: view.getUint32(i),\n          samplesPerChunk: view.getUint32(i + 4),\n          sampleDescriptionIndex: view.getUint32(i + 8)\n        });\n      }\n      return result;\n    },\n    stsd: function(data) {\n      return {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        sampleDescriptions: inspectMp4(data.subarray(8))\n      };\n    },\n    stsz: function(data) {\n      var\n        view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n          version: data[0],\n          flags: new Uint8Array(data.subarray(1, 4)),\n          sampleSize: view.getUint32(4),\n          entries: []\n        },\n        i;\n      for (i = 12; i < data.byteLength; i += 4) {\n        result.entries.push(view.getUint32(i));\n      }\n      return result;\n    },\n    stts: function(data) {\n      var\n        view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n          version: data[0],\n          flags: new Uint8Array(data.subarray(1, 4)),\n          timeToSamples: []\n        },\n        entryCount = view.getUint32(4),\n        i;\n\n      for (i = 8; entryCount; i += 8, entryCount--) {\n        result.timeToSamples.push({\n          sampleCount: view.getUint32(i),\n          sampleDelta: view.getUint32(i + 4)\n        });\n      }\n      return result;\n    },\n    styp: function(data) {\n      return parse.ftyp(data);\n    },\n    tfdt: function(data) {\n      var result = {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        baseMediaDecodeTime: data[4] << 24 | data[5] << 16 | data[6] << 8 | data[7]\n      };\n      if (result.version === 1) {\n        result.baseMediaDecodeTime *= Math.pow(2, 32);\n        result.baseMediaDecodeTime += data[8] << 24 | data[9] << 16 | data[10] << 8 | data[11];\n      }\n      return result;\n    },\n    tfhd: function(data) {\n      var\n        view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        result = {\n          version: data[0],\n          flags: new Uint8Array(data.subarray(1, 4)),\n          trackId: view.getUint32(4)\n        },\n        baseDataOffsetPresent = result.flags[2] & 0x01,\n        sampleDescriptionIndexPresent = result.flags[2] & 0x02,\n        defaultSampleDurationPresent = result.flags[2] & 0x08,\n        defaultSampleSizePresent = result.flags[2] & 0x10,\n        defaultSampleFlagsPresent = result.flags[2] & 0x20,\n        durationIsEmpty = result.flags[0] & 0x010000,\n        defaultBaseIsMoof =  result.flags[0] & 0x020000,\n        i;\n\n      i = 8;\n      if (baseDataOffsetPresent) {\n        i += 4; // truncate top 4 bytes\n        // FIXME: should we read the full 64 bits?\n        result.baseDataOffset = view.getUint32(12);\n        i += 4;\n      }\n      if (sampleDescriptionIndexPresent) {\n        result.sampleDescriptionIndex = view.getUint32(i);\n        i += 4;\n      }\n      if (defaultSampleDurationPresent) {\n        result.defaultSampleDuration = view.getUint32(i);\n        i += 4;\n      }\n      if (defaultSampleSizePresent) {\n        result.defaultSampleSize = view.getUint32(i);\n        i += 4;\n      }\n      if (defaultSampleFlagsPresent) {\n        result.defaultSampleFlags = view.getUint32(i);\n      }\n      if (durationIsEmpty) {\n        result.durationIsEmpty = true;\n      }\n      if (!baseDataOffsetPresent && defaultBaseIsMoof) {\n        result.baseDataOffsetIsMoof = true;\n      }\n      return result;\n    },\n    tkhd: function(data) {\n      var\n        view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        i = 4,\n        result = {\n          version: view.getUint8(0),\n          flags: new Uint8Array(data.subarray(1, 4))\n        };\n      if (result.version === 1) {\n        i += 4;\n        result.creationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes\n        i += 8;\n        result.modificationTime = parseMp4Date(view.getUint32(i)); // truncating top 4 bytes\n        i += 4;\n        result.trackId = view.getUint32(i);\n        i += 4;\n        i += 8;\n        result.duration = view.getUint32(i); // truncating top 4 bytes\n      } else {\n        result.creationTime = parseMp4Date(view.getUint32(i));\n        i += 4;\n        result.modificationTime = parseMp4Date(view.getUint32(i));\n        i += 4;\n        result.trackId = view.getUint32(i);\n        i += 4;\n        i += 4;\n        result.duration = view.getUint32(i);\n      }\n      i += 4;\n      i += 2 * 4;\n      result.layer = view.getUint16(i);\n      i += 2;\n      result.alternateGroup = view.getUint16(i);\n      i += 2;\n      // convert fixed-point, base 16 back to a number\n      result.volume = view.getUint8(i) + (view.getUint8(i + 1) / 8);\n      i += 2;\n      i += 2;\n      result.matrix = new Uint32Array(data.subarray(i, i + (9 * 4)));\n      i += 9 * 4;\n      result.width = view.getUint16(i) + (view.getUint16(i + 2) / 16);\n      i += 4;\n      result.height = view.getUint16(i) + (view.getUint16(i + 2) / 16);\n      return result;\n    },\n    traf: function(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    trak: function(data) {\n      return {\n        boxes: inspectMp4(data)\n      };\n    },\n    trex: function(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n      return {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        trackId: view.getUint32(4),\n        defaultSampleDescriptionIndex: view.getUint32(8),\n        defaultSampleDuration: view.getUint32(12),\n        defaultSampleSize: view.getUint32(16),\n        sampleDependsOn: data[20] & 0x03,\n        sampleIsDependedOn: (data[21] & 0xc0) >> 6,\n        sampleHasRedundancy: (data[21] & 0x30) >> 4,\n        samplePaddingValue: (data[21] & 0x0e) >> 1,\n        sampleIsDifferenceSample: !!(data[21] & 0x01),\n        sampleDegradationPriority: view.getUint16(22)\n      };\n    },\n    trun: function(data) {\n      var\n        result = {\n          version: data[0],\n          flags: new Uint8Array(data.subarray(1, 4)),\n          samples: []\n        },\n        view = new DataView(data.buffer, data.byteOffset, data.byteLength),\n        // Flag interpretation\n        dataOffsetPresent = result.flags[2] & 0x01, // compare with 2nd byte of 0x1\n        firstSampleFlagsPresent = result.flags[2] & 0x04, // compare with 2nd byte of 0x4\n        sampleDurationPresent = result.flags[1] & 0x01, // compare with 2nd byte of 0x100\n        sampleSizePresent = result.flags[1] & 0x02, // compare with 2nd byte of 0x200\n        sampleFlagsPresent = result.flags[1] & 0x04, // compare with 2nd byte of 0x400\n        sampleCompositionTimeOffsetPresent = result.flags[1] & 0x08, // compare with 2nd byte of 0x800\n        sampleCount = view.getUint32(4),\n        offset = 8,\n        sample;\n\n      if (dataOffsetPresent) {\n        // 32 bit signed integer\n        result.dataOffset = view.getInt32(offset);\n        offset += 4;\n      }\n\n      // Overrides the flags for the first sample only. The order of\n      // optional values will be: duration, size, compositionTimeOffset\n      if (firstSampleFlagsPresent && sampleCount) {\n        sample = {\n          flags: parseSampleFlags(data.subarray(offset, offset + 4))\n        };\n        offset += 4;\n        if (sampleDurationPresent) {\n          sample.duration = view.getUint32(offset);\n          offset += 4;\n        }\n        if (sampleSizePresent) {\n          sample.size = view.getUint32(offset);\n          offset += 4;\n        }\n        if (sampleCompositionTimeOffsetPresent) {\n          // Note: this should be a signed int if version is 1\n          sample.compositionTimeOffset = view.getUint32(offset);\n          offset += 4;\n        }\n        result.samples.push(sample);\n        sampleCount--;\n      }\n\n      while (sampleCount--) {\n        sample = {};\n        if (sampleDurationPresent) {\n          sample.duration = view.getUint32(offset);\n          offset += 4;\n        }\n        if (sampleSizePresent) {\n          sample.size = view.getUint32(offset);\n          offset += 4;\n        }\n        if (sampleFlagsPresent) {\n          sample.flags = parseSampleFlags(data.subarray(offset, offset + 4));\n          offset += 4;\n        }\n        if (sampleCompositionTimeOffsetPresent) {\n          // Note: this should be a signed int if version is 1\n          sample.compositionTimeOffset = view.getUint32(offset);\n          offset += 4;\n        }\n        result.samples.push(sample);\n      }\n      return result;\n    },\n    'url ': function(data) {\n      return {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4))\n      };\n    },\n    vmhd: function(data) {\n      var view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n      return {\n        version: data[0],\n        flags: new Uint8Array(data.subarray(1, 4)),\n        graphicsmode: view.getUint16(4),\n        opcolor: new Uint16Array([view.getUint16(6),\n                                  view.getUint16(8),\n                                  view.getUint16(10)])\n      };\n    }\n  };\n\n\n/**\n * Return a javascript array of box objects parsed from an ISO base\n * media file.\n * @param data {Uint8Array} the binary data of the media to be inspected\n * @return {array} a javascript array of potentially nested box objects\n */\ninspectMp4 = function(data) {\n  var\n    i = 0,\n    result = [],\n    view,\n    size,\n    type,\n    end,\n    box;\n\n  // Convert data from Uint8Array to ArrayBuffer, to follow Dataview API\n  var ab = new ArrayBuffer(data.length);\n  var v = new Uint8Array(ab);\n  for (var z = 0; z < data.length; ++z) {\n      v[z] = data[z];\n  }\n  view = new DataView(ab);\n\n  while (i < data.byteLength) {\n    // parse box data\n    size = view.getUint32(i);\n    type =  parseType(data.subarray(i + 4, i + 8));\n    end = size > 1 ? i + size : data.byteLength;\n\n    // parse type-specific data\n    box = (parse[type] || function(data) {\n      return {\n        data: data\n      };\n    })(data.subarray(i + 8, end));\n    box.size = size;\n    box.type = type;\n\n    // store this box and move to the next\n    result.push(box);\n    i = end;\n  }\n  return result;\n};\n\n/**\n * Returns a textual representation of the javascript represtentation\n * of an MP4 file. You can use it as an alternative to\n * JSON.stringify() to compare inspected MP4s.\n * @param inspectedMp4 {array} the parsed array of boxes in an MP4\n * file\n * @param depth {number} (optional) the number of ancestor boxes of\n * the elements of inspectedMp4. Assumed to be zero if unspecified.\n * @return {string} a text representation of the parsed MP4\n */\ntextifyMp4 = function(inspectedMp4, depth) {\n  var indent;\n  depth = depth || 0;\n  indent = new Array(depth * 2 + 1).join(' ');\n\n  // iterate over all the boxes\n  return inspectedMp4.map(function(box, index) {\n\n    // list the box type first at the current indentation level\n    return indent + box.type + '\\n' +\n\n      // the type is already included and handle child boxes separately\n      Object.keys(box).filter(function(key) {\n        return key !== 'type' && key !== 'boxes';\n\n      // output all the box properties\n      }).map(function(key) {\n        var prefix = indent + '  ' + key + ': ',\n            value = box[key];\n\n        // print out raw bytes as hexademical\n        if (value instanceof Uint8Array || value instanceof Uint32Array) {\n          var bytes = Array.prototype.slice.call(new Uint8Array(value.buffer, value.byteOffset, value.byteLength))\n              .map(function(byte) {\n                return ' ' + ('00' + byte.toString(16)).slice(-2);\n              }).join('').match(/.{1,24}/g);\n          if (!bytes) {\n            return prefix + '<>';\n          }\n          if (bytes.length === 1) {\n            return prefix + '<' + bytes.join('').slice(1) + '>';\n          }\n          return prefix + '<\\n' + bytes.map(function(line) {\n            return indent + '  ' + line;\n          }).join('\\n') + '\\n' + indent + '  >';\n        }\n\n        // stringify generic objects\n        return prefix +\n            JSON.stringify(value, null, 2)\n              .split('\\n').map(function(line, index) {\n                if (index === 0) {\n                  return line;\n                }\n                return indent + '  ' + line;\n              }).join('\\n');\n      }).join('\\n') +\n\n    // recursively textify the child boxes\n    (box.boxes ? '\\n' + textifyMp4(box.boxes, depth + 1) : '');\n  }).join('\\n');\n};\n\nmodule.exports = {\n  inspect: inspectMp4,\n  textify: textifyMp4,\n  parseTfdt: parse.tfdt,\n  parseHdlr: parse.hdlr,\n  parseTfhd: parse.tfhd,\n  parseTrun: parse.trun,\n  parseSidx: parse.sidx\n};\n","/**\n * Root reference for iframes.\n */\n\nlet root;\nif (typeof window !== 'undefined') { // Browser window\n  root = window;\n} else if (typeof self !== 'undefined') { // Web Worker\n  root = self;\n} else { // Other environments\n  console.warn(\"Using browser-only version of superagent in non-browser environment\");\n  root = this;\n}\n\nconst Emitter = require('component-emitter');\nconst RequestBase = require('./request-base');\nconst isObject = require('./is-object');\nconst ResponseBase = require('./response-base');\nconst Agent = require('./agent-base');\n\n/**\n * Noop.\n */\n\nfunction noop(){};\n\n/**\n * Expose `request`.\n */\n\nconst request = exports = module.exports = function(method, url) {\n  // callback\n  if ('function' == typeof url) {\n    return new exports.Request('GET', method).end(url);\n  }\n\n  // url first\n  if (1 == arguments.length) {\n    return new exports.Request('GET', method);\n  }\n\n  return new exports.Request(method, url);\n};\n\nexports.Request = Request;\n\n/**\n * Determine XHR.\n */\n\nrequest.getXHR = () => {\n  if (root.XMLHttpRequest\n      && (!root.location || 'file:' != root.location.protocol\n          || !root.ActiveXObject)) {\n    return new XMLHttpRequest;\n  } else {\n    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}\n  }\n  throw Error(\"Browser-only version of superagent could not find XHR\");\n};\n\n/**\n * Removes leading and trailing whitespace, added to support IE.\n *\n * @param {String} s\n * @return {String}\n * @api private\n */\n\nconst trim = ''.trim\n  ? s => s.trim()\n  : s => s.replace(/(^\\s*|\\s*$)/g, '');\n\n/**\n * Serialize the given `obj`.\n *\n * @param {Object} obj\n * @return {String}\n * @api private\n */\n\nfunction serialize(obj) {\n  if (!isObject(obj)) return obj;\n  const pairs = [];\n  for (const key in obj) {\n    pushEncodedKeyValuePair(pairs, key, obj[key]);\n  }\n  return pairs.join('&');\n}\n\n/**\n * Helps 'serialize' with serializing arrays.\n * Mutates the pairs array.\n *\n * @param {Array} pairs\n * @param {String} key\n * @param {Mixed} val\n */\n\nfunction pushEncodedKeyValuePair(pairs, key, val) {\n  if (val != null) {\n    if (Array.isArray(val)) {\n      val.forEach(v => {\n        pushEncodedKeyValuePair(pairs, key, v);\n      });\n    } else if (isObject(val)) {\n      for(const subkey in val) {\n        pushEncodedKeyValuePair(pairs, `${key}[${subkey}]`, val[subkey]);\n      }\n    } else {\n      pairs.push(encodeURIComponent(key)\n        + '=' + encodeURIComponent(val));\n    }\n  } else if (val === null) {\n    pairs.push(encodeURIComponent(key));\n  }\n}\n\n/**\n * Expose serialization method.\n */\n\nrequest.serializeObject = serialize;\n\n/**\n  * Parse the given x-www-form-urlencoded `str`.\n  *\n  * @param {String} str\n  * @return {Object}\n  * @api private\n  */\n\nfunction parseString(str) {\n  const obj = {};\n  const pairs = str.split('&');\n  let pair;\n  let pos;\n\n  for (let i = 0, len = pairs.length; i < len; ++i) {\n    pair = pairs[i];\n    pos = pair.indexOf('=');\n    if (pos == -1) {\n      obj[decodeURIComponent(pair)] = '';\n    } else {\n      obj[decodeURIComponent(pair.slice(0, pos))] =\n        decodeURIComponent(pair.slice(pos + 1));\n    }\n  }\n\n  return obj;\n}\n\n/**\n * Expose parser.\n */\n\nrequest.parseString = parseString;\n\n/**\n * Default MIME type map.\n *\n *     superagent.types.xml = 'application/xml';\n *\n */\n\nrequest.types = {\n  html: 'text/html',\n  json: 'application/json',\n  xml: 'text/xml',\n  urlencoded: 'application/x-www-form-urlencoded',\n  'form': 'application/x-www-form-urlencoded',\n  'form-data': 'application/x-www-form-urlencoded'\n};\n\n/**\n * Default serialization map.\n *\n *     superagent.serialize['application/xml'] = function(obj){\n *       return 'generated xml here';\n *     };\n *\n */\n\nrequest.serialize = {\n  'application/x-www-form-urlencoded': serialize,\n  'application/json': JSON.stringify\n};\n\n/**\n  * Default parsers.\n  *\n  *     superagent.parse['application/xml'] = function(str){\n  *       return { object parsed from str };\n  *     };\n  *\n  */\n\nrequest.parse = {\n  'application/x-www-form-urlencoded': parseString,\n  'application/json': JSON.parse\n};\n\n/**\n * Parse the given header `str` into\n * an object containing the mapped fields.\n *\n * @param {String} str\n * @return {Object}\n * @api private\n */\n\nfunction parseHeader(str) {\n  const lines = str.split(/\\r?\\n/);\n  const fields = {};\n  let index;\n  let line;\n  let field;\n  let val;\n\n  for (let i = 0, len = lines.length; i < len; ++i) {\n    line = lines[i];\n    index = line.indexOf(':');\n    if (index === -1) { // could be empty line, just skip it\n      continue;\n    }\n    field = line.slice(0, index).toLowerCase();\n    val = trim(line.slice(index + 1));\n    fields[field] = val;\n  }\n\n  return fields;\n}\n\n/**\n * Check if `mime` is json or has +json structured syntax suffix.\n *\n * @param {String} mime\n * @return {Boolean}\n * @api private\n */\n\nfunction isJSON(mime) {\n  // should match /json or +json\n  // but not /json-seq\n  return /[\\/+]json($|[^-\\w])/.test(mime);\n}\n\n/**\n * Initialize a new `Response` with the given `xhr`.\n *\n *  - set flags (.ok, .error, etc)\n *  - parse header\n *\n * Examples:\n *\n *  Aliasing `superagent` as `request` is nice:\n *\n *      request = superagent;\n *\n *  We can use the promise-like API, or pass callbacks:\n *\n *      request.get('/').end(function(res){});\n *      request.get('/', function(res){});\n *\n *  Sending data can be chained:\n *\n *      request\n *        .post('/user')\n *        .send({ name: 'tj' })\n *        .end(function(res){});\n *\n *  Or passed to `.send()`:\n *\n *      request\n *        .post('/user')\n *        .send({ name: 'tj' }, function(res){});\n *\n *  Or passed to `.post()`:\n *\n *      request\n *        .post('/user', { name: 'tj' })\n *        .end(function(res){});\n *\n * Or further reduced to a single call for simple cases:\n *\n *      request\n *        .post('/user', { name: 'tj' }, function(res){});\n *\n * @param {XMLHTTPRequest} xhr\n * @param {Object} options\n * @api private\n */\n\nfunction Response(req) {\n  this.req = req;\n  this.xhr = this.req.xhr;\n  // responseText is accessible only if responseType is '' or 'text' and on older browsers\n  this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')\n     ? this.xhr.responseText\n     : null;\n  this.statusText = this.req.xhr.statusText;\n  let status = this.xhr.status;\n  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request\n  if (status === 1223) {\n    status = 204;\n  }\n  this._setStatusProperties(status);\n  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());\n  // getAllResponseHeaders sometimes falsely returns \"\" for CORS requests, but\n  // getResponseHeader still works. so we get content-type even if getting\n  // other headers fails.\n  this.header['content-type'] = this.xhr.getResponseHeader('content-type');\n  this._setHeaderProperties(this.header);\n\n  if (null === this.text && req._responseType) {\n    this.body = this.xhr.response;\n  } else {\n    this.body = this.req.method != 'HEAD'\n      ? this._parseBody(this.text ? this.text : this.xhr.response)\n      : null;\n  }\n}\n\nResponseBase(Response.prototype);\n\n/**\n * Parse the given body `str`.\n *\n * Used for auto-parsing of bodies. Parsers\n * are defined on the `superagent.parse` object.\n *\n * @param {String} str\n * @return {Mixed}\n * @api private\n */\n\nResponse.prototype._parseBody = function(str) {\n  let parse = request.parse[this.type];\n  if (this.req._parser) {\n    return this.req._parser(this, str);\n  }\n  if (!parse && isJSON(this.type)) {\n    parse = request.parse['application/json'];\n  }\n  return parse && str && (str.length || str instanceof Object)\n    ? parse(str)\n    : null;\n};\n\n/**\n * Return an `Error` representative of this response.\n *\n * @return {Error}\n * @api public\n */\n\nResponse.prototype.toError = function(){\n  const req = this.req;\n  const method = req.method;\n  const url = req.url;\n\n  const msg = `cannot ${method} ${url} (${this.status})`;\n  const err = new Error(msg);\n  err.status = this.status;\n  err.method = method;\n  err.url = url;\n\n  return err;\n};\n\n/**\n * Expose `Response`.\n */\n\nrequest.Response = Response;\n\n/**\n * Initialize a new `Request` with the given `method` and `url`.\n *\n * @param {String} method\n * @param {String} url\n * @api public\n */\n\nfunction Request(method, url) {\n  const self = this;\n  this._query = this._query || [];\n  this.method = method;\n  this.url = url;\n  this.header = {}; // preserves header name case\n  this._header = {}; // coerces header names to lowercase\n  this.on('end', () => {\n    let err = null;\n    let res = null;\n\n    try {\n      res = new Response(self);\n    } catch(e) {\n      err = new Error('Parser is unable to parse the response');\n      err.parse = true;\n      err.original = e;\n      // issue #675: return the raw response if the response parsing fails\n      if (self.xhr) {\n        // ie9 doesn't have 'response' property\n        err.rawResponse = typeof self.xhr.responseType == 'undefined' ? self.xhr.responseText : self.xhr.response;\n        // issue #876: return the http status code if the response parsing fails\n        err.status = self.xhr.status ? self.xhr.status : null;\n        err.statusCode = err.status; // backwards-compat only\n      } else {\n        err.rawResponse = null;\n        err.status = null;\n      }\n\n      return self.callback(err);\n    }\n\n    self.emit('response', res);\n\n    let new_err;\n    try {\n      if (!self._isResponseOK(res)) {\n        new_err = new Error(res.statusText || 'Unsuccessful HTTP response');\n      }\n    } catch(custom_err) {\n      new_err = custom_err; // ok() callback can throw\n    }\n\n    // #1000 don't catch errors from the callback to avoid double calling it\n    if (new_err) {\n      new_err.original = err;\n      new_err.response = res;\n      new_err.status = res.status;\n      self.callback(new_err, res);\n    } else {\n      self.callback(null, res);\n    }\n  });\n}\n\n/**\n * Mixin `Emitter` and `RequestBase`.\n */\n\nEmitter(Request.prototype);\nRequestBase(Request.prototype);\n\n/**\n * Set Content-Type to `type`, mapping values from `request.types`.\n *\n * Examples:\n *\n *      superagent.types.xml = 'application/xml';\n *\n *      request.post('/')\n *        .type('xml')\n *        .send(xmlstring)\n *        .end(callback);\n *\n *      request.post('/')\n *        .type('application/xml')\n *        .send(xmlstring)\n *        .end(callback);\n *\n * @param {String} type\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.type = function(type){\n  this.set('Content-Type', request.types[type] || type);\n  return this;\n};\n\n/**\n * Set Accept to `type`, mapping values from `request.types`.\n *\n * Examples:\n *\n *      superagent.types.json = 'application/json';\n *\n *      request.get('/agent')\n *        .accept('json')\n *        .end(callback);\n *\n *      request.get('/agent')\n *        .accept('application/json')\n *        .end(callback);\n *\n * @param {String} accept\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.accept = function(type){\n  this.set('Accept', request.types[type] || type);\n  return this;\n};\n\n/**\n * Set Authorization field value with `user` and `pass`.\n *\n * @param {String} user\n * @param {String} [pass] optional in case of using 'bearer' as type\n * @param {Object} options with 'type' property 'auto', 'basic' or 'bearer' (default 'basic')\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.auth = function(user, pass, options){\n  if (1 === arguments.length) pass = '';\n  if (typeof pass === 'object' && pass !== null) { // pass is optional and can be replaced with options\n    options = pass;\n    pass = '';\n  }\n  if (!options) {\n    options = {\n      type: 'function' === typeof btoa ? 'basic' : 'auto',\n    };\n  }\n\n  const encoder = string => {\n    if ('function' === typeof btoa) {\n      return btoa(string);\n    }\n    throw new Error('Cannot use basic auth, btoa is not a function');\n  };\n\n  return this._auth(user, pass, options, encoder);\n};\n\n/**\n * Add query-string `val`.\n *\n * Examples:\n *\n *   request.get('/shoes')\n *     .query('size=10')\n *     .query({ color: 'blue' })\n *\n * @param {Object|String} val\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.query = function(val){\n  if ('string' != typeof val) val = serialize(val);\n  if (val) this._query.push(val);\n  return this;\n};\n\n/**\n * Queue the given `file` as an attachment to the specified `field`,\n * with optional `options` (or filename).\n *\n * ``` js\n * request.post('/upload')\n *   .attach('content', new Blob(['<a id=\"a\"><b id=\"b\">hey!</b></a>'], { type: \"text/html\"}))\n *   .end(callback);\n * ```\n *\n * @param {String} field\n * @param {Blob|File} file\n * @param {String|Object} options\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.attach = function(field, file, options){\n  if (file) {\n    if (this._data) {\n      throw Error(\"superagent can't mix .send() and .attach()\");\n    }\n\n    this._getFormData().append(field, file, options || file.name);\n  }\n  return this;\n};\n\nRequest.prototype._getFormData = function(){\n  if (!this._formData) {\n    this._formData = new root.FormData();\n  }\n  return this._formData;\n};\n\n/**\n * Invoke the callback with `err` and `res`\n * and handle arity check.\n *\n * @param {Error} err\n * @param {Response} res\n * @api private\n */\n\nRequest.prototype.callback = function(err, res){\n  if (this._shouldRetry(err, res)) {\n    return this._retry();\n  }\n\n  const fn = this._callback;\n  this.clearTimeout();\n\n  if (err) {\n    if (this._maxRetries) err.retries = this._retries - 1;\n    this.emit('error', err);\n  }\n\n  fn(err, res);\n};\n\n/**\n * Invoke callback with x-domain error.\n *\n * @api private\n */\n\nRequest.prototype.crossDomainError = function(){\n  const err = new Error('Request has been terminated\\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');\n  err.crossDomain = true;\n\n  err.status = this.status;\n  err.method = this.method;\n  err.url = this.url;\n\n  this.callback(err);\n};\n\n// This only warns, because the request is still likely to work\nRequest.prototype.buffer = Request.prototype.ca = Request.prototype.agent = function(){\n  console.warn(\"This is not supported in browser version of superagent\");\n  return this;\n};\n\n// This throws, because it can't send/receive data as expected\nRequest.prototype.pipe = Request.prototype.write = () => {\n  throw Error(\"Streaming is not supported in browser version of superagent\");\n};\n\n/**\n * Check if `obj` is a host object,\n * we don't want to serialize these :)\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api private\n */\nRequest.prototype._isHost = function _isHost(obj) {\n  // Native objects stringify to [object File], [object Blob], [object FormData], etc.\n  return obj && 'object' === typeof obj && !Array.isArray(obj) && Object.prototype.toString.call(obj) !== '[object Object]';\n}\n\n/**\n * Initiate request, invoking callback `fn(res)`\n * with an instanceof `Response`.\n *\n * @param {Function} fn\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.end = function(fn){\n  if (this._endCalled) {\n    console.warn(\"Warning: .end() was called twice. This is not supported in superagent\");\n  }\n  this._endCalled = true;\n\n  // store callback\n  this._callback = fn || noop;\n\n  // querystring\n  this._finalizeQueryString();\n\n  this._end();\n};\n\nRequest.prototype._end = function() {\n  if (this._aborted) return this.callback(Error(\"The request has been aborted even before .end() was called\"));\n\n  const self = this;\n  const xhr = (this.xhr = request.getXHR());\n  let data = this._formData || this._data;\n\n  this._setTimeouts();\n\n  // state change\n  xhr.onreadystatechange = () => {\n    const readyState = xhr.readyState;\n    if (readyState >= 2 && self._responseTimeoutTimer) {\n      clearTimeout(self._responseTimeoutTimer);\n    }\n    if (4 != readyState) {\n      return;\n    }\n\n    // In IE9, reads to any property (e.g. status) off of an aborted XHR will\n    // result in the error \"Could not complete the operation due to error c00c023f\"\n    let status;\n    try { status = xhr.status } catch(e) { status = 0; }\n\n    if (!status) {\n      if (self.timedout || self._aborted) return;\n      return self.crossDomainError();\n    }\n    self.emit('end');\n  };\n\n  // progress\n  const handleProgress = (direction, e) => {\n    if (e.total > 0) {\n      e.percent = e.loaded / e.total * 100;\n    }\n    e.direction = direction;\n    self.emit('progress', e);\n  };\n  if (this.hasListeners('progress')) {\n    try {\n      xhr.onprogress = handleProgress.bind(null, 'download');\n      if (xhr.upload) {\n        xhr.upload.onprogress = handleProgress.bind(null, 'upload');\n      }\n    } catch(e) {\n      // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.\n      // Reported here:\n      // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context\n    }\n  }\n\n  // initiate request\n  try {\n    if (this.username && this.password) {\n      xhr.open(this.method, this.url, true, this.username, this.password);\n    } else {\n      xhr.open(this.method, this.url, true);\n    }\n  } catch (err) {\n    // see #1149\n    return this.callback(err);\n  }\n\n  // CORS\n  if (this._withCredentials) xhr.withCredentials = true;\n\n  // body\n  if (!this._formData && 'GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !this._isHost(data)) {\n    // serialize stuff\n    const contentType = this._header['content-type'];\n    let serialize = this._serializer || request.serialize[contentType ? contentType.split(';')[0] : ''];\n    if (!serialize && isJSON(contentType)) {\n      serialize = request.serialize['application/json'];\n    }\n    if (serialize) data = serialize(data);\n  }\n\n  // set header fields\n  for (const field in this.header) {\n    if (null == this.header[field]) continue;\n\n    if (this.header.hasOwnProperty(field))\n      xhr.setRequestHeader(field, this.header[field]);\n  }\n\n  if (this._responseType) {\n    xhr.responseType = this._responseType;\n  }\n\n  // send stuff\n  this.emit('request', this);\n\n  // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)\n  // We need null here if data is undefined\n  xhr.send(typeof data !== 'undefined' ? data : null);\n};\n\nrequest.agent = () => new Agent();\n\n[\"GET\", \"POST\", \"OPTIONS\", \"PATCH\", \"PUT\", \"DELETE\"].forEach(method => {\n  Agent.prototype[method.toLowerCase()] = function(url, fn) {\n    const req = new request.Request(method, url);\n    this._setDefaults(req);\n    if (fn) {\n      req.end(fn);\n    }\n    return req;\n  };\n});\n\nAgent.prototype.del = Agent.prototype['delete'];\n\n/**\n * GET `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} [data] or fn\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nrequest.get = (url, data, fn) => {\n  const req = request('GET', url);\n  if ('function' == typeof data) (fn = data), (data = null);\n  if (data) req.query(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * HEAD `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} [data] or fn\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nrequest.head = (url, data, fn) => {\n  const req = request('HEAD', url);\n  if ('function' == typeof data) (fn = data), (data = null);\n  if (data) req.query(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * OPTIONS query to `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} [data] or fn\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nrequest.options = (url, data, fn) => {\n  const req = request('OPTIONS', url);\n  if ('function' == typeof data) (fn = data), (data = null);\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * DELETE `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed} [data]\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nfunction del(url, data, fn) {\n  const req = request('DELETE', url);\n  if ('function' == typeof data) (fn = data), (data = null);\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n}\n\nrequest['del'] = del;\nrequest['delete'] = del;\n\n/**\n * PATCH `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed} [data]\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nrequest.patch = (url, data, fn) => {\n  const req = request('PATCH', url);\n  if ('function' == typeof data) (fn = data), (data = null);\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * POST `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed} [data]\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nrequest.post = (url, data, fn) => {\n  const req = request('POST', url);\n  if ('function' == typeof data) (fn = data), (data = null);\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * PUT `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} [data] or fn\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nrequest.put = (url, data, fn) => {\n  const req = request('PUT', url);\n  if ('function' == typeof data) (fn = data), (data = null);\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n","\r\n/**\r\n * Expose `Emitter`.\r\n */\r\n\r\nif (typeof module !== 'undefined') {\r\n  module.exports = Emitter;\r\n}\r\n\r\n/**\r\n * Initialize a new `Emitter`.\r\n *\r\n * @api public\r\n */\r\n\r\nfunction Emitter(obj) {\r\n  if (obj) return mixin(obj);\r\n};\r\n\r\n/**\r\n * Mixin the emitter properties.\r\n *\r\n * @param {Object} obj\r\n * @return {Object}\r\n * @api private\r\n */\r\n\r\nfunction mixin(obj) {\r\n  for (var key in Emitter.prototype) {\r\n    obj[key] = Emitter.prototype[key];\r\n  }\r\n  return obj;\r\n}\r\n\r\n/**\r\n * Listen on the given `event` with `fn`.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.on =\r\nEmitter.prototype.addEventListener = function(event, fn){\r\n  this._callbacks = this._callbacks || {};\r\n  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])\r\n    .push(fn);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Adds an `event` listener that will be invoked a single\r\n * time then automatically removed.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.once = function(event, fn){\r\n  function on() {\r\n    this.off(event, on);\r\n    fn.apply(this, arguments);\r\n  }\r\n\r\n  on.fn = fn;\r\n  this.on(event, on);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Remove the given callback for `event` or all\r\n * registered callbacks.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.off =\r\nEmitter.prototype.removeListener =\r\nEmitter.prototype.removeAllListeners =\r\nEmitter.prototype.removeEventListener = function(event, fn){\r\n  this._callbacks = this._callbacks || {};\r\n\r\n  // all\r\n  if (0 == arguments.length) {\r\n    this._callbacks = {};\r\n    return this;\r\n  }\r\n\r\n  // specific event\r\n  var callbacks = this._callbacks['$' + event];\r\n  if (!callbacks) return this;\r\n\r\n  // remove all handlers\r\n  if (1 == arguments.length) {\r\n    delete this._callbacks['$' + event];\r\n    return this;\r\n  }\r\n\r\n  // remove specific handler\r\n  var cb;\r\n  for (var i = 0; i < callbacks.length; i++) {\r\n    cb = callbacks[i];\r\n    if (cb === fn || cb.fn === fn) {\r\n      callbacks.splice(i, 1);\r\n      break;\r\n    }\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Emit `event` with the given args.\r\n *\r\n * @param {String} event\r\n * @param {Mixed} ...\r\n * @return {Emitter}\r\n */\r\n\r\nEmitter.prototype.emit = function(event){\r\n  this._callbacks = this._callbacks || {};\r\n  var args = [].slice.call(arguments, 1)\r\n    , callbacks = this._callbacks['$' + event];\r\n\r\n  if (callbacks) {\r\n    callbacks = callbacks.slice(0);\r\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\r\n      callbacks[i].apply(this, args);\r\n    }\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Return array of callbacks for `event`.\r\n *\r\n * @param {String} event\r\n * @return {Array}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.listeners = function(event){\r\n  this._callbacks = this._callbacks || {};\r\n  return this._callbacks['$' + event] || [];\r\n};\r\n\r\n/**\r\n * Check if this emitter has `event` handlers.\r\n *\r\n * @param {String} event\r\n * @return {Boolean}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.hasListeners = function(event){\r\n  return !! this.listeners(event).length;\r\n};\r\n","'use strict';\n\n/**\n * Module of mixed-in functions shared between node and client code\n */\nconst isObject = require('./is-object');\n\n/**\n * Expose `RequestBase`.\n */\n\nmodule.exports = RequestBase;\n\n/**\n * Initialize a new `RequestBase`.\n *\n * @api public\n */\n\nfunction RequestBase(obj) {\n  if (obj) return mixin(obj);\n}\n\n/**\n * Mixin the prototype properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (const key in RequestBase.prototype) {\n    obj[key] = RequestBase.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Clear previous timeout.\n *\n * @return {Request} for chaining\n * @api public\n */\n\nRequestBase.prototype.clearTimeout = function _clearTimeout(){\n  clearTimeout(this._timer);\n  clearTimeout(this._responseTimeoutTimer);\n  delete this._timer;\n  delete this._responseTimeoutTimer;\n  return this;\n};\n\n/**\n * Override default response body parser\n *\n * This function will be called to convert incoming data into request.body\n *\n * @param {Function}\n * @api public\n */\n\nRequestBase.prototype.parse = function parse(fn){\n  this._parser = fn;\n  return this;\n};\n\n/**\n * Set format of binary response body.\n * In browser valid formats are 'blob' and 'arraybuffer',\n * which return Blob and ArrayBuffer, respectively.\n *\n * In Node all values result in Buffer.\n *\n * Examples:\n *\n *      req.get('/')\n *        .responseType('blob')\n *        .end(callback);\n *\n * @param {String} val\n * @return {Request} for chaining\n * @api public\n */\n\nRequestBase.prototype.responseType = function(val){\n  this._responseType = val;\n  return this;\n};\n\n/**\n * Override default request body serializer\n *\n * This function will be called to convert data set via .send or .attach into payload to send\n *\n * @param {Function}\n * @api public\n */\n\nRequestBase.prototype.serialize = function serialize(fn){\n  this._serializer = fn;\n  return this;\n};\n\n/**\n * Set timeouts.\n *\n * - response timeout is time between sending request and receiving the first byte of the response. Includes DNS and connection time.\n * - deadline is the time from start of the request to receiving response body in full. If the deadline is too short large files may not load at all on slow connections.\n *\n * Value of 0 or false means no timeout.\n *\n * @param {Number|Object} ms or {response, deadline}\n * @return {Request} for chaining\n * @api public\n */\n\nRequestBase.prototype.timeout = function timeout(options){\n  if (!options || 'object' !== typeof options) {\n    this._timeout = options;\n    this._responseTimeout = 0;\n    return this;\n  }\n\n  for(const option in options) {\n    switch(option) {\n      case 'deadline':\n        this._timeout = options.deadline;\n        break;\n      case 'response':\n        this._responseTimeout = options.response;\n        break;\n      default:\n        console.warn(\"Unknown timeout option\", option);\n    }\n  }\n  return this;\n};\n\n/**\n * Set number of retry attempts on error.\n *\n * Failed requests will be retried 'count' times if timeout or err.code >= 500.\n *\n * @param {Number} count\n * @param {Function} [fn]\n * @return {Request} for chaining\n * @api public\n */\n\nRequestBase.prototype.retry = function retry(count, fn){\n  // Default to 1 if no count passed or true\n  if (arguments.length === 0 || count === true) count = 1;\n  if (count <= 0) count = 0;\n  this._maxRetries = count;\n  this._retries = 0;\n  this._retryCallback = fn;\n  return this;\n};\n\nconst ERROR_CODES = [\n  'ECONNRESET',\n  'ETIMEDOUT',\n  'EADDRINFO',\n  'ESOCKETTIMEDOUT'\n];\n\n/**\n * Determine if a request should be retried.\n * (Borrowed from segmentio/superagent-retry)\n *\n * @param {Error} err\n * @param {Response} [res]\n * @returns {Boolean}\n */\nRequestBase.prototype._shouldRetry = function(err, res) {\n  if (!this._maxRetries || this._retries++ >= this._maxRetries) {\n    return false;\n  }\n  if (this._retryCallback) {\n    try {\n      const override = this._retryCallback(err, res);\n      if (override === true) return true;\n      if (override === false) return false;\n      // undefined falls back to defaults\n    } catch(e) {\n      console.error(e);\n    }\n  }\n  if (res && res.status && res.status >= 500 && res.status != 501) return true;\n  if (err) {\n    if (err.code && ~ERROR_CODES.indexOf(err.code)) return true;\n    // Superagent timeout\n    if (err.timeout && err.code == 'ECONNABORTED') return true;\n    if (err.crossDomain) return true;\n  }\n  return false;\n};\n\n/**\n * Retry request\n *\n * @return {Request} for chaining\n * @api private\n */\n\nRequestBase.prototype._retry = function() {\n\n  this.clearTimeout();\n\n  // node\n  if (this.req) {\n    this.req = null;\n    this.req = this.request();\n  }\n\n  this._aborted = false;\n  this.timedout = false;\n\n  return this._end();\n};\n\n/**\n * Promise support\n *\n * @param {Function} resolve\n * @param {Function} [reject]\n * @return {Request}\n */\n\nRequestBase.prototype.then = function then(resolve, reject) {\n  if (!this._fullfilledPromise) {\n    const self = this;\n    if (this._endCalled) {\n      console.warn(\"Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises\");\n    }\n    this._fullfilledPromise = new Promise((innerResolve, innerReject) => {\n      self.on('error', innerReject);\n      self.on('abort', () => {\n        const err = new Error('Aborted');\n        err.code = \"ABORTED\";\n        err.status = this.status;\n        err.method = this.method;\n        err.url = this.url;\n        innerReject(err);\n      });\n      self.end((err, res) => {\n        if (err) innerReject(err);\n        else innerResolve(res);\n      });\n    });\n  }\n  return this._fullfilledPromise.then(resolve, reject);\n};\n\nRequestBase.prototype['catch'] = function(cb) {\n  return this.then(undefined, cb);\n};\n\n/**\n * Allow for extension\n */\n\nRequestBase.prototype.use = function use(fn) {\n  fn(this);\n  return this;\n};\n\nRequestBase.prototype.ok = function(cb) {\n  if ('function' !== typeof cb) throw Error(\"Callback required\");\n  this._okCallback = cb;\n  return this;\n};\n\nRequestBase.prototype._isResponseOK = function(res) {\n  if (!res) {\n    return false;\n  }\n\n  if (this._okCallback) {\n    return this._okCallback(res);\n  }\n\n  return res.status >= 200 && res.status < 300;\n};\n\n/**\n * Get request header `field`.\n * Case-insensitive.\n *\n * @param {String} field\n * @return {String}\n * @api public\n */\n\nRequestBase.prototype.get = function(field){\n  return this._header[field.toLowerCase()];\n};\n\n/**\n * Get case-insensitive header `field` value.\n * This is a deprecated internal API. Use `.get(field)` instead.\n *\n * (getHeader is no longer used internally by the superagent code base)\n *\n * @param {String} field\n * @return {String}\n * @api private\n * @deprecated\n */\n\nRequestBase.prototype.getHeader = RequestBase.prototype.get;\n\n/**\n * Set header `field` to `val`, or multiple fields with one object.\n * Case-insensitive.\n *\n * Examples:\n *\n *      req.get('/')\n *        .set('Accept', 'application/json')\n *        .set('X-API-Key', 'foobar')\n *        .end(callback);\n *\n *      req.get('/')\n *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })\n *        .end(callback);\n *\n * @param {String|Object} field\n * @param {String} val\n * @return {Request} for chaining\n * @api public\n */\n\nRequestBase.prototype.set = function(field, val){\n  if (isObject(field)) {\n    for (const key in field) {\n      this.set(key, field[key]);\n    }\n    return this;\n  }\n  this._header[field.toLowerCase()] = val;\n  this.header[field] = val;\n  return this;\n};\n\n/**\n * Remove header `field`.\n * Case-insensitive.\n *\n * Example:\n *\n *      req.get('/')\n *        .unset('User-Agent')\n *        .end(callback);\n *\n * @param {String} field\n */\nRequestBase.prototype.unset = function(field){\n  delete this._header[field.toLowerCase()];\n  delete this.header[field];\n  return this;\n};\n\n/**\n * Write the field `name` and `val`, or multiple fields with one object\n * for \"multipart/form-data\" request bodies.\n *\n * ``` js\n * request.post('/upload')\n *   .field('foo', 'bar')\n *   .end(callback);\n *\n * request.post('/upload')\n *   .field({ foo: 'bar', baz: 'qux' })\n *   .end(callback);\n * ```\n *\n * @param {String|Object} name\n * @param {String|Blob|File|Buffer|fs.ReadStream} val\n * @return {Request} for chaining\n * @api public\n */\nRequestBase.prototype.field = function(name, val) {\n  // name should be either a string or an object.\n  if (null === name || undefined === name) {\n    throw new Error('.field(name, val) name can not be empty');\n  }\n\n  if (this._data) {\n    throw new Error(\".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()\");\n  }\n\n  if (isObject(name)) {\n    for (const key in name) {\n      this.field(key, name[key]);\n    }\n    return this;\n  }\n\n  if (Array.isArray(val)) {\n    for (const i in val) {\n      this.field(name, val[i]);\n    }\n    return this;\n  }\n\n  // val should be defined now\n  if (null === val || undefined === val) {\n    throw new Error('.field(name, val) val can not be empty');\n  }\n  if ('boolean' === typeof val) {\n    val = '' + val;\n  }\n  this._getFormData().append(name, val);\n  return this;\n};\n\n/**\n * Abort the request, and clear potential timeout.\n *\n * @return {Request}\n * @api public\n */\nRequestBase.prototype.abort = function(){\n  if (this._aborted) {\n    return this;\n  }\n  this._aborted = true;\n  this.xhr && this.xhr.abort(); // browser\n  this.req && this.req.abort(); // node\n  this.clearTimeout();\n  this.emit('abort');\n  return this;\n};\n\nRequestBase.prototype._auth = function(user, pass, options, base64Encoder) {\n  switch (options.type) {\n    case 'basic':\n      this.set('Authorization', `Basic ${base64Encoder(`${user}:${pass}`)}`);\n      break;\n\n    case 'auto':\n      this.username = user;\n      this.password = pass;\n      break;\n\n    case 'bearer': // usage would be .auth(accessToken, { type: 'bearer' })\n      this.set('Authorization', `Bearer ${user}`);\n      break;\n  }\n  return this;\n};\n\n/**\n * Enable transmission of cookies with x-domain requests.\n *\n * Note that for this to work the origin must not be\n * using \"Access-Control-Allow-Origin\" with a wildcard,\n * and also must set \"Access-Control-Allow-Credentials\"\n * to \"true\".\n *\n * @api public\n */\n\nRequestBase.prototype.withCredentials = function(on) {\n  // This is browser-only functionality. Node side is no-op.\n  if (on == undefined) on = true;\n  this._withCredentials = on;\n  return this;\n};\n\n/**\n * Set the max redirects to `n`. Does noting in browser XHR implementation.\n *\n * @param {Number} n\n * @return {Request} for chaining\n * @api public\n */\n\nRequestBase.prototype.redirects = function(n){\n  this._maxRedirects = n;\n  return this;\n};\n\n/**\n * Maximum size of buffered response body, in bytes. Counts uncompressed size.\n * Default 200MB.\n *\n * @param {Number} n\n * @return {Request} for chaining\n */\nRequestBase.prototype.maxResponseSize = function(n){\n  if ('number' !== typeof n) {\n    throw TypeError(\"Invalid argument\");\n  }\n  this._maxResponseSize = n;\n  return this;\n};\n\n/**\n * Convert to a plain javascript object (not JSON string) of scalar properties.\n * Note as this method is designed to return a useful non-this value,\n * it cannot be chained.\n *\n * @return {Object} describing method, url, and data of this request\n * @api public\n */\n\nRequestBase.prototype.toJSON = function() {\n  return {\n    method: this.method,\n    url: this.url,\n    data: this._data,\n    headers: this._header,\n  };\n};\n\n/**\n * Send `data` as the request body, defaulting the `.type()` to \"json\" when\n * an object is given.\n *\n * Examples:\n *\n *       // manual json\n *       request.post('/user')\n *         .type('json')\n *         .send('{\"name\":\"tj\"}')\n *         .end(callback)\n *\n *       // auto json\n *       request.post('/user')\n *         .send({ name: 'tj' })\n *         .end(callback)\n *\n *       // manual x-www-form-urlencoded\n *       request.post('/user')\n *         .type('form')\n *         .send('name=tj')\n *         .end(callback)\n *\n *       // auto x-www-form-urlencoded\n *       request.post('/user')\n *         .type('form')\n *         .send({ name: 'tj' })\n *         .end(callback)\n *\n *       // defaults to x-www-form-urlencoded\n *      request.post('/user')\n *        .send('name=tobi')\n *        .send('species=ferret')\n *        .end(callback)\n *\n * @param {String|Object} data\n * @return {Request} for chaining\n * @api public\n */\n\nRequestBase.prototype.send = function(data){\n  const isObj = isObject(data);\n  let type = this._header['content-type'];\n\n  if (this._formData) {\n    throw new Error(\".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()\");\n  }\n\n  if (isObj && !this._data) {\n    if (Array.isArray(data)) {\n      this._data = [];\n    } else if (!this._isHost(data)) {\n      this._data = {};\n    }\n  } else if (data && this._data && this._isHost(this._data)) {\n    throw Error(\"Can't merge these send calls\");\n  }\n\n  // merge\n  if (isObj && isObject(this._data)) {\n    for (const key in data) {\n      this._data[key] = data[key];\n    }\n  } else if ('string' == typeof data) {\n    // default to x-www-form-urlencoded\n    if (!type) this.type('form');\n    type = this._header['content-type'];\n    if ('application/x-www-form-urlencoded' == type) {\n      this._data = this._data\n        ? `${this._data}&${data}`\n        : data;\n    } else {\n      this._data = (this._data || '') + data;\n    }\n  } else {\n    this._data = data;\n  }\n\n  if (!isObj || this._isHost(data)) {\n    return this;\n  }\n\n  // default to json\n  if (!type) this.type('json');\n  return this;\n};\n\n/**\n * Sort `querystring` by the sort function\n *\n *\n * Examples:\n *\n *       // default order\n *       request.get('/user')\n *         .query('name=Nick')\n *         .query('search=Manny')\n *         .sortQuery()\n *         .end(callback)\n *\n *       // customized sort function\n *       request.get('/user')\n *         .query('name=Nick')\n *         .query('search=Manny')\n *         .sortQuery(function(a, b){\n *           return a.length - b.length;\n *         })\n *         .end(callback)\n *\n *\n * @param {Function} sort\n * @return {Request} for chaining\n * @api public\n */\n\nRequestBase.prototype.sortQuery = function(sort) {\n  // _sort default to true but otherwise can be a function or boolean\n  this._sort = typeof sort === 'undefined' ? true : sort;\n  return this;\n};\n\n/**\n * Compose querystring to append to req.url\n *\n * @api private\n */\nRequestBase.prototype._finalizeQueryString = function(){\n  const query = this._query.join('&');\n  if (query) {\n    this.url += (this.url.indexOf('?') >= 0 ? '&' : '?') + query;\n  }\n  this._query.length = 0; // Makes the call idempotent\n\n  if (this._sort) {\n    const index = this.url.indexOf('?');\n    if (index >= 0) {\n      const queryArr = this.url.substring(index + 1).split('&');\n      if ('function' === typeof this._sort) {\n        queryArr.sort(this._sort);\n      } else {\n        queryArr.sort();\n      }\n      this.url = this.url.substring(0, index) + '?' + queryArr.join('&');\n    }\n  }\n};\n\n// For backwards compat only\nRequestBase.prototype._appendQueryString = () => {console.trace(\"Unsupported\");}\n\n/**\n * Invoke callback with timeout error.\n *\n * @api private\n */\n\nRequestBase.prototype._timeoutError = function(reason, timeout, errno){\n  if (this._aborted) {\n    return;\n  }\n  const err = new Error(`${reason + timeout}ms exceeded`);\n  err.timeout = timeout;\n  err.code = 'ECONNABORTED';\n  err.errno = errno;\n  this.timedout = true;\n  this.abort();\n  this.callback(err);\n};\n\nRequestBase.prototype._setTimeouts = function() {\n  const self = this;\n\n  // deadline\n  if (this._timeout && !this._timer) {\n    this._timer = setTimeout(() => {\n      self._timeoutError('Timeout of ', self._timeout, 'ETIME');\n    }, this._timeout);\n  }\n  // response timeout\n  if (this._responseTimeout && !this._responseTimeoutTimer) {\n    this._responseTimeoutTimer = setTimeout(() => {\n      self._timeoutError('Response timeout of ', self._responseTimeout, 'ETIMEDOUT');\n    }, this._responseTimeout);\n  }\n};\n","'use strict';\n\n/**\n * Module dependencies.\n */\n\nconst utils = require('./utils');\n\n/**\n * Expose `ResponseBase`.\n */\n\nmodule.exports = ResponseBase;\n\n/**\n * Initialize a new `ResponseBase`.\n *\n * @api public\n */\n\nfunction ResponseBase(obj) {\n  if (obj) return mixin(obj);\n}\n\n/**\n * Mixin the prototype properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (const key in ResponseBase.prototype) {\n    obj[key] = ResponseBase.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Get case-insensitive `field` value.\n *\n * @param {String} field\n * @return {String}\n * @api public\n */\n\nResponseBase.prototype.get = function(field) {\n  return this.header[field.toLowerCase()];\n};\n\n/**\n * Set header related properties:\n *\n *   - `.type` the content type without params\n *\n * A response of \"Content-Type: text/plain; charset=utf-8\"\n * will provide you with a `.type` of \"text/plain\".\n *\n * @param {Object} header\n * @api private\n */\n\nResponseBase.prototype._setHeaderProperties = function(header){\n    // TODO: moar!\n    // TODO: make this a util\n\n    // content-type\n    const ct = header['content-type'] || '';\n    this.type = utils.type(ct);\n\n    // params\n    const params = utils.params(ct);\n    for (const key in params) this[key] = params[key];\n\n    this.links = {};\n\n    // links\n    try {\n        if (header.link) {\n            this.links = utils.parseLinks(header.link);\n        }\n    } catch (err) {\n        // ignore\n    }\n};\n\n/**\n * Set flags such as `.ok` based on `status`.\n *\n * For example a 2xx response will give you a `.ok` of __true__\n * whereas 5xx will be __false__ and `.error` will be __true__. The\n * `.clientError` and `.serverError` are also available to be more\n * specific, and `.statusType` is the class of error ranging from 1..5\n * sometimes useful for mapping respond colors etc.\n *\n * \"sugar\" properties are also defined for common cases. Currently providing:\n *\n *   - .noContent\n *   - .badRequest\n *   - .unauthorized\n *   - .notAcceptable\n *   - .notFound\n *\n * @param {Number} status\n * @api private\n */\n\nResponseBase.prototype._setStatusProperties = function(status){\n    const type = status / 100 | 0;\n\n    // status / class\n    this.status = this.statusCode = status;\n    this.statusType = type;\n\n    // basics\n    this.info = 1 == type;\n    this.ok = 2 == type;\n    this.redirect = 3 == type;\n    this.clientError = 4 == type;\n    this.serverError = 5 == type;\n    this.error = (4 == type || 5 == type)\n        ? this.toError()\n        : false;\n\n    // sugar\n    this.created = 201 == status;\n    this.accepted = 202 == status;\n    this.noContent = 204 == status;\n    this.badRequest = 400 == status;\n    this.unauthorized = 401 == status;\n    this.notAcceptable = 406 == status;\n    this.forbidden = 403 == status;\n    this.notFound = 404 == status;\n    this.unprocessableEntity = 422 == status;\n};\n","'use strict';\n\n/**\n * Return the mime type for the given `str`.\n *\n * @param {String} str\n * @return {String}\n * @api private\n */\n\nexports.type = str => str.split(/ *; */).shift();\n\n/**\n * Return header field parameters.\n *\n * @param {String} str\n * @return {Object}\n * @api private\n */\n\nexports.params = str => str.split(/ *; */).reduce((obj, str) => {\n  const parts = str.split(/ *= */);\n  const key = parts.shift();\n  const val = parts.shift();\n\n  if (key && val) obj[key] = val;\n  return obj;\n}, {});\n\n/**\n * Parse Link header fields.\n *\n * @param {String} str\n * @return {Object}\n * @api private\n */\n\nexports.parseLinks = str => str.split(/ *, */).reduce((obj, str) => {\n  const parts = str.split(/ *; */);\n  const url = parts[0].slice(1, -1);\n  const rel = parts[1].split(/ *= */)[1].slice(1, -1);\n  obj[rel] = url;\n  return obj;\n}, {});\n\n/**\n * Strip content related fields from `header`.\n *\n * @param {Object} header\n * @return {Object} header\n * @api private\n */\n\nexports.cleanHeader = (header, changesOrigin) => {\n  delete header['content-type'];\n  delete header['content-length'];\n  delete header['transfer-encoding'];\n  delete header['host'];\n  // secuirty\n  if (changesOrigin) {\n    delete header['authorization'];\n    delete header['cookie'];\n  }\n  return header;\n};\n","function Agent() {\n  this._defaults = [];\n}\n\n[\"use\", \"on\", \"once\", \"set\", \"query\", \"type\", \"accept\", \"auth\", \"withCredentials\", \"sortQuery\", \"retry\", \"ok\", \"redirects\",\n \"timeout\", \"buffer\", \"serialize\", \"parse\", \"ca\", \"key\", \"pfx\", \"cert\"].forEach(fn => {\n  /** Default setting for all requests from this agent */\n  Agent.prototype[fn] = function(...args) {\n    this._defaults.push({fn, args});\n    return this;\n  }\n});\n\nAgent.prototype._setDefaults = function(req) {\n    this._defaults.forEach(def => {\n      req[def.fn].apply(req, def.args);\n    });\n};\n\nmodule.exports = Agent;\n","/**\n * @module Passage\n */\n'use strict';\n\nvar Route = require('./lib/route');\n\n\nmodule.exports = Route;","'use strict';\nvar Parser = require('./route/parser'),\n    RegexpVisitor = require('./route/visitors/regexp'),\n    ReverseVisitor = require('./route/visitors/reverse');\n\nRoute.prototype = Object.create(null)\n\n/**\n * Match a path against this route, returning the matched parameters if\n * it matches, false if not.\n * @example\n * var route = new Route('/this/is/my/route')\n * route.match('/this/is/my/route') // -> {}\n * @example\n * var route = new Route('/:one/:two')\n * route.match('/foo/bar/') // -> {one: 'foo', two: 'bar'}\n * @param  {string} path the path to match this route against\n * @return {(Object.<string,string>|false)} A map of the matched route\n * parameters, or false if matching failed\n */\nRoute.prototype.match = function(path) {\n  var re = RegexpVisitor.visit(this.ast),\n      matched = re.match(path);\n\n  return matched ? matched : false;\n\n};\n\n/**\n * Reverse a route specification to a path, returning false if it can't be\n * fulfilled\n * @example\n * var route = new Route('/:one/:two')\n * route.reverse({one: 'foo', two: 'bar'}) -> '/foo/bar'\n * @param  {Object} params The parameters to fill in\n * @return {(String|false)} The filled in path\n */\nRoute.prototype.reverse = function(params) {\n  return ReverseVisitor.visit(this.ast, params);\n};\n\n/**\n * Represents a route\n * @example\n * var route = Route('/:foo/:bar');\n * @example\n * var route = Route('/:foo/:bar');\n * @param {string} spec -  the string specification of the route.\n *     use :param for single portion captures, *param for splat style captures,\n *     and () for optional route branches\n * @constructor\n */\nfunction Route(spec) {\n  var route;\n  if (this) {\n    // constructor called with new\n    route = this;\n  } else {\n    // constructor called as a function\n    route = Object.create(Route.prototype);\n  }\n  if( typeof spec === 'undefined' ) {\n    throw new Error('A route spec is required');\n  }\n  route.spec = spec;\n  route.ast = Parser.parse(spec);\n  return route;\n}\n\nmodule.exports = Route;","/**\n * @module route/parser\n */\n'use strict';\n\n/** Wrap the compiled parser with the context to create node objects */\nvar parser = require('./compiled-grammar').parser;\nparser.yy = require('./nodes');\nmodule.exports = parser;\n","/* parser generated by jison 0.4.17 */\n/*\n  Returns a Parser object of the following structure:\n\n  Parser: {\n    yy: {}\n  }\n\n  Parser.prototype: {\n    yy: {},\n    trace: function(),\n    symbols_: {associative list: name ==> number},\n    terminals_: {associative list: number ==> name},\n    productions_: [...],\n    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),\n    table: [...],\n    defaultActions: {...},\n    parseError: function(str, hash),\n    parse: function(input),\n\n    lexer: {\n        EOF: 1,\n        parseError: function(str, hash),\n        setInput: function(input),\n        input: function(),\n        unput: function(str),\n        more: function(),\n        less: function(n),\n        pastInput: function(),\n        upcomingInput: function(),\n        showPosition: function(),\n        test_match: function(regex_match_array, rule_index),\n        next: function(),\n        lex: function(),\n        begin: function(condition),\n        popState: function(),\n        _currentRules: function(),\n        topState: function(),\n        pushState: function(condition),\n\n        options: {\n            ranges: boolean           (optional: true ==> token location info will include a .range[] member)\n            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)\n            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)\n        },\n\n        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),\n        rules: [...],\n        conditions: {associative list: name ==> set},\n    }\n  }\n\n\n  token location info (@$, _$, etc.): {\n    first_line: n,\n    last_line: n,\n    first_column: n,\n    last_column: n,\n    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)\n  }\n\n\n  the parseError function receives a 'hash' object with these members for lexer and parser errors: {\n    text:        (matched text)\n    token:       (the produced terminal token, if any)\n    line:        (yylineno)\n  }\n  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {\n    loc:         (yylloc)\n    expected:    (string describing the set of expected tokens)\n    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)\n  }\n*/\nvar parser = (function(){\nvar o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,9],$V1=[1,10],$V2=[1,11],$V3=[1,12],$V4=[5,11,12,13,14,15];\nvar parser = {trace: function trace() { },\nyy: {},\nsymbols_: {\"error\":2,\"root\":3,\"expressions\":4,\"EOF\":5,\"expression\":6,\"optional\":7,\"literal\":8,\"splat\":9,\"param\":10,\"(\":11,\")\":12,\"LITERAL\":13,\"SPLAT\":14,\"PARAM\":15,\"$accept\":0,\"$end\":1},\nterminals_: {2:\"error\",5:\"EOF\",11:\"(\",12:\")\",13:\"LITERAL\",14:\"SPLAT\",15:\"PARAM\"},\nproductions_: [0,[3,2],[3,1],[4,2],[4,1],[6,1],[6,1],[6,1],[6,1],[7,3],[8,1],[9,1],[10,1]],\nperformAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {\n/* this == yyval */\n\nvar $0 = $$.length - 1;\nswitch (yystate) {\ncase 1:\nreturn new yy.Root({},[$$[$0-1]])\nbreak;\ncase 2:\nreturn new yy.Root({},[new yy.Literal({value: ''})])\nbreak;\ncase 3:\nthis.$ = new yy.Concat({},[$$[$0-1],$$[$0]]);\nbreak;\ncase 4: case 5:\nthis.$ = $$[$0];\nbreak;\ncase 6:\nthis.$ = new yy.Literal({value: $$[$0]});\nbreak;\ncase 7:\nthis.$ = new yy.Splat({name: $$[$0]});\nbreak;\ncase 8:\nthis.$ = new yy.Param({name: $$[$0]});\nbreak;\ncase 9:\nthis.$ = new yy.Optional({},[$$[$0-1]]);\nbreak;\ncase 10:\nthis.$ = yytext;\nbreak;\ncase 11: case 12:\nthis.$ = yytext.slice(1);\nbreak;\n}\n},\ntable: [{3:1,4:2,5:[1,3],6:4,7:5,8:6,9:7,10:8,11:$V0,13:$V1,14:$V2,15:$V3},{1:[3]},{5:[1,13],6:14,7:5,8:6,9:7,10:8,11:$V0,13:$V1,14:$V2,15:$V3},{1:[2,2]},o($V4,[2,4]),o($V4,[2,5]),o($V4,[2,6]),o($V4,[2,7]),o($V4,[2,8]),{4:15,6:4,7:5,8:6,9:7,10:8,11:$V0,13:$V1,14:$V2,15:$V3},o($V4,[2,10]),o($V4,[2,11]),o($V4,[2,12]),{1:[2,1]},o($V4,[2,3]),{6:14,7:5,8:6,9:7,10:8,11:$V0,12:[1,16],13:$V1,14:$V2,15:$V3},o($V4,[2,9])],\ndefaultActions: {3:[2,2],13:[2,1]},\nparseError: function parseError(str, hash) {\n    if (hash.recoverable) {\n        this.trace(str);\n    } else {\n        function _parseError (msg, hash) {\n            this.message = msg;\n            this.hash = hash;\n        }\n        _parseError.prototype = Error;\n\n        throw new _parseError(str, hash);\n    }\n},\nparse: function parse(input) {\n    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;\n    var args = lstack.slice.call(arguments, 1);\n    var lexer = Object.create(this.lexer);\n    var sharedState = { yy: {} };\n    for (var k in this.yy) {\n        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {\n            sharedState.yy[k] = this.yy[k];\n        }\n    }\n    lexer.setInput(input, sharedState.yy);\n    sharedState.yy.lexer = lexer;\n    sharedState.yy.parser = this;\n    if (typeof lexer.yylloc == 'undefined') {\n        lexer.yylloc = {};\n    }\n    var yyloc = lexer.yylloc;\n    lstack.push(yyloc);\n    var ranges = lexer.options && lexer.options.ranges;\n    if (typeof sharedState.yy.parseError === 'function') {\n        this.parseError = sharedState.yy.parseError;\n    } else {\n        this.parseError = Object.getPrototypeOf(this).parseError;\n    }\n    function popStack(n) {\n        stack.length = stack.length - 2 * n;\n        vstack.length = vstack.length - n;\n        lstack.length = lstack.length - n;\n    }\n    _token_stack:\n        var lex = function () {\n            var token;\n            token = lexer.lex() || EOF;\n            if (typeof token !== 'number') {\n                token = self.symbols_[token] || token;\n            }\n            return token;\n        };\n    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;\n    while (true) {\n        state = stack[stack.length - 1];\n        if (this.defaultActions[state]) {\n            action = this.defaultActions[state];\n        } else {\n            if (symbol === null || typeof symbol == 'undefined') {\n                symbol = lex();\n            }\n            action = table[state] && table[state][symbol];\n        }\n                    if (typeof action === 'undefined' || !action.length || !action[0]) {\n                var errStr = '';\n                expected = [];\n                for (p in table[state]) {\n                    if (this.terminals_[p] && p > TERROR) {\n                        expected.push('\\'' + this.terminals_[p] + '\\'');\n                    }\n                }\n                if (lexer.showPosition) {\n                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\\n' + lexer.showPosition() + '\\nExpecting ' + expected.join(', ') + ', got \\'' + (this.terminals_[symbol] || symbol) + '\\'';\n                } else {\n                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\\'' + (this.terminals_[symbol] || symbol) + '\\'');\n                }\n                this.parseError(errStr, {\n                    text: lexer.match,\n                    token: this.terminals_[symbol] || symbol,\n                    line: lexer.yylineno,\n                    loc: yyloc,\n                    expected: expected\n                });\n            }\n        if (action[0] instanceof Array && action.length > 1) {\n            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);\n        }\n        switch (action[0]) {\n        case 1:\n            stack.push(symbol);\n            vstack.push(lexer.yytext);\n            lstack.push(lexer.yylloc);\n            stack.push(action[1]);\n            symbol = null;\n            if (!preErrorSymbol) {\n                yyleng = lexer.yyleng;\n                yytext = lexer.yytext;\n                yylineno = lexer.yylineno;\n                yyloc = lexer.yylloc;\n                if (recovering > 0) {\n                    recovering--;\n                }\n            } else {\n                symbol = preErrorSymbol;\n                preErrorSymbol = null;\n            }\n            break;\n        case 2:\n            len = this.productions_[action[1]][1];\n            yyval.$ = vstack[vstack.length - len];\n            yyval._$ = {\n                first_line: lstack[lstack.length - (len || 1)].first_line,\n                last_line: lstack[lstack.length - 1].last_line,\n                first_column: lstack[lstack.length - (len || 1)].first_column,\n                last_column: lstack[lstack.length - 1].last_column\n            };\n            if (ranges) {\n                yyval._$.range = [\n                    lstack[lstack.length - (len || 1)].range[0],\n                    lstack[lstack.length - 1].range[1]\n                ];\n            }\n            r = this.performAction.apply(yyval, [\n                yytext,\n                yyleng,\n                yylineno,\n                sharedState.yy,\n                action[1],\n                vstack,\n                lstack\n            ].concat(args));\n            if (typeof r !== 'undefined') {\n                return r;\n            }\n            if (len) {\n                stack = stack.slice(0, -1 * len * 2);\n                vstack = vstack.slice(0, -1 * len);\n                lstack = lstack.slice(0, -1 * len);\n            }\n            stack.push(this.productions_[action[1]][0]);\n            vstack.push(yyval.$);\n            lstack.push(yyval._$);\n            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];\n            stack.push(newState);\n            break;\n        case 3:\n            return true;\n        }\n    }\n    return true;\n}};\n/* generated by jison-lex 0.3.4 */\nvar lexer = (function(){\nvar lexer = ({\n\nEOF:1,\n\nparseError:function parseError(str, hash) {\n        if (this.yy.parser) {\n            this.yy.parser.parseError(str, hash);\n        } else {\n            throw new Error(str);\n        }\n    },\n\n// resets the lexer, sets new input\nsetInput:function (input, yy) {\n        this.yy = yy || this.yy || {};\n        this._input = input;\n        this._more = this._backtrack = this.done = false;\n        this.yylineno = this.yyleng = 0;\n        this.yytext = this.matched = this.match = '';\n        this.conditionStack = ['INITIAL'];\n        this.yylloc = {\n            first_line: 1,\n            first_column: 0,\n            last_line: 1,\n            last_column: 0\n        };\n        if (this.options.ranges) {\n            this.yylloc.range = [0,0];\n        }\n        this.offset = 0;\n        return this;\n    },\n\n// consumes and returns one char from the input\ninput:function () {\n        var ch = this._input[0];\n        this.yytext += ch;\n        this.yyleng++;\n        this.offset++;\n        this.match += ch;\n        this.matched += ch;\n        var lines = ch.match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno++;\n            this.yylloc.last_line++;\n        } else {\n            this.yylloc.last_column++;\n        }\n        if (this.options.ranges) {\n            this.yylloc.range[1]++;\n        }\n\n        this._input = this._input.slice(1);\n        return ch;\n    },\n\n// unshifts one char (or a string) into the input\nunput:function (ch) {\n        var len = ch.length;\n        var lines = ch.split(/(?:\\r\\n?|\\n)/g);\n\n        this._input = ch + this._input;\n        this.yytext = this.yytext.substr(0, this.yytext.length - len);\n        //this.yyleng -= len;\n        this.offset -= len;\n        var oldLines = this.match.split(/(?:\\r\\n?|\\n)/g);\n        this.match = this.match.substr(0, this.match.length - 1);\n        this.matched = this.matched.substr(0, this.matched.length - 1);\n\n        if (lines.length - 1) {\n            this.yylineno -= lines.length - 1;\n        }\n        var r = this.yylloc.range;\n\n        this.yylloc = {\n            first_line: this.yylloc.first_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.first_column,\n            last_column: lines ?\n                (lines.length === oldLines.length ? this.yylloc.first_column : 0)\n                 + oldLines[oldLines.length - lines.length].length - lines[0].length :\n              this.yylloc.first_column - len\n        };\n\n        if (this.options.ranges) {\n            this.yylloc.range = [r[0], r[0] + this.yyleng - len];\n        }\n        this.yyleng = this.yytext.length;\n        return this;\n    },\n\n// When called from action, caches matched text and appends it on next action\nmore:function () {\n        this._more = true;\n        return this;\n    },\n\n// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.\nreject:function () {\n        if (this.options.backtrack_lexer) {\n            this._backtrack = true;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n\n        }\n        return this;\n    },\n\n// retain first n characters of the match\nless:function (n) {\n        this.unput(this.match.slice(n));\n    },\n\n// displays already matched input, i.e. for error messages\npastInput:function () {\n        var past = this.matched.substr(0, this.matched.length - this.match.length);\n        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\\n/g, \"\");\n    },\n\n// displays upcoming input, i.e. for error messages\nupcomingInput:function () {\n        var next = this.match;\n        if (next.length < 20) {\n            next += this._input.substr(0, 20-next.length);\n        }\n        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\\n/g, \"\");\n    },\n\n// displays the character position where the lexing error occurred, i.e. for error messages\nshowPosition:function () {\n        var pre = this.pastInput();\n        var c = new Array(pre.length + 1).join(\"-\");\n        return pre + this.upcomingInput() + \"\\n\" + c + \"^\";\n    },\n\n// test the lexed token: return FALSE when not a match, otherwise return token\ntest_match:function (match, indexed_rule) {\n        var token,\n            lines,\n            backup;\n\n        if (this.options.backtrack_lexer) {\n            // save context\n            backup = {\n                yylineno: this.yylineno,\n                yylloc: {\n                    first_line: this.yylloc.first_line,\n                    last_line: this.last_line,\n                    first_column: this.yylloc.first_column,\n                    last_column: this.yylloc.last_column\n                },\n                yytext: this.yytext,\n                match: this.match,\n                matches: this.matches,\n                matched: this.matched,\n                yyleng: this.yyleng,\n                offset: this.offset,\n                _more: this._more,\n                _input: this._input,\n                yy: this.yy,\n                conditionStack: this.conditionStack.slice(0),\n                done: this.done\n            };\n            if (this.options.ranges) {\n                backup.yylloc.range = this.yylloc.range.slice(0);\n            }\n        }\n\n        lines = match[0].match(/(?:\\r\\n?|\\n).*/g);\n        if (lines) {\n            this.yylineno += lines.length;\n        }\n        this.yylloc = {\n            first_line: this.yylloc.last_line,\n            last_line: this.yylineno + 1,\n            first_column: this.yylloc.last_column,\n            last_column: lines ?\n                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\\r?\\n?/)[0].length :\n                         this.yylloc.last_column + match[0].length\n        };\n        this.yytext += match[0];\n        this.match += match[0];\n        this.matches = match;\n        this.yyleng = this.yytext.length;\n        if (this.options.ranges) {\n            this.yylloc.range = [this.offset, this.offset += this.yyleng];\n        }\n        this._more = false;\n        this._backtrack = false;\n        this._input = this._input.slice(match[0].length);\n        this.matched += match[0];\n        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);\n        if (this.done && this._input) {\n            this.done = false;\n        }\n        if (token) {\n            return token;\n        } else if (this._backtrack) {\n            // recover context\n            for (var k in backup) {\n                this[k] = backup[k];\n            }\n            return false; // rule action called reject() implying the next rule should be tested instead.\n        }\n        return false;\n    },\n\n// return next match in input\nnext:function () {\n        if (this.done) {\n            return this.EOF;\n        }\n        if (!this._input) {\n            this.done = true;\n        }\n\n        var token,\n            match,\n            tempMatch,\n            index;\n        if (!this._more) {\n            this.yytext = '';\n            this.match = '';\n        }\n        var rules = this._currentRules();\n        for (var i = 0; i < rules.length; i++) {\n            tempMatch = this._input.match(this.rules[rules[i]]);\n            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {\n                match = tempMatch;\n                index = i;\n                if (this.options.backtrack_lexer) {\n                    token = this.test_match(tempMatch, rules[i]);\n                    if (token !== false) {\n                        return token;\n                    } else if (this._backtrack) {\n                        match = false;\n                        continue; // rule action called reject() implying a rule MISmatch.\n                    } else {\n                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n                        return false;\n                    }\n                } else if (!this.options.flex) {\n                    break;\n                }\n            }\n        }\n        if (match) {\n            token = this.test_match(match, rules[index]);\n            if (token !== false) {\n                return token;\n            }\n            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)\n            return false;\n        }\n        if (this._input === \"\") {\n            return this.EOF;\n        } else {\n            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\\n' + this.showPosition(), {\n                text: \"\",\n                token: null,\n                line: this.yylineno\n            });\n        }\n    },\n\n// return next match that has a token\nlex:function lex() {\n        var r = this.next();\n        if (r) {\n            return r;\n        } else {\n            return this.lex();\n        }\n    },\n\n// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)\nbegin:function begin(condition) {\n        this.conditionStack.push(condition);\n    },\n\n// pop the previously active lexer condition state off the condition stack\npopState:function popState() {\n        var n = this.conditionStack.length - 1;\n        if (n > 0) {\n            return this.conditionStack.pop();\n        } else {\n            return this.conditionStack[0];\n        }\n    },\n\n// produce the lexer rule set which is active for the currently active lexer condition state\n_currentRules:function _currentRules() {\n        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {\n            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;\n        } else {\n            return this.conditions[\"INITIAL\"].rules;\n        }\n    },\n\n// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available\ntopState:function topState(n) {\n        n = this.conditionStack.length - 1 - Math.abs(n || 0);\n        if (n >= 0) {\n            return this.conditionStack[n];\n        } else {\n            return \"INITIAL\";\n        }\n    },\n\n// alias for begin(condition)\npushState:function pushState(condition) {\n        this.begin(condition);\n    },\n\n// return the number of states currently on the stack\nstateStackSize:function stateStackSize() {\n        return this.conditionStack.length;\n    },\noptions: {},\nperformAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {\nvar YYSTATE=YY_START;\nswitch($avoiding_name_collisions) {\ncase 0:return \"(\";\nbreak;\ncase 1:return \")\";\nbreak;\ncase 2:return \"SPLAT\";\nbreak;\ncase 3:return \"PARAM\";\nbreak;\ncase 4:return \"LITERAL\";\nbreak;\ncase 5:return \"LITERAL\";\nbreak;\ncase 6:return \"EOF\";\nbreak;\n}\n},\nrules: [/^(?:\\()/,/^(?:\\))/,/^(?:\\*+\\w+)/,/^(?::+\\w+)/,/^(?:[\\w%\\-~\\n]+)/,/^(?:.)/,/^(?:$)/],\nconditions: {\"INITIAL\":{\"rules\":[0,1,2,3,4,5,6],\"inclusive\":true}}\n});\nreturn lexer;\n})();\nparser.lexer = lexer;\nfunction Parser () {\n  this.yy = {};\n}\nParser.prototype = parser;parser.Parser = Parser;\nreturn new Parser;\n})();\n\n\nif (typeof require !== 'undefined' && typeof exports !== 'undefined') {\nexports.parser = parser;\nexports.Parser = parser.Parser;\nexports.parse = function () { return parser.parse.apply(parser, arguments); };\n}","'use strict';\n\nvar createVisitor  = require('./create_visitor'),\n    escapeRegExp = /[\\-{}\\[\\]+?.,\\\\\\^$|#\\s]/g;\n\n/**\n * @class\n * @private\n */\nfunction Matcher(options) {\n  this.captures = options.captures;\n  this.re = options.re;\n}\n\n/**\n * Try matching a path against the generated regular expression\n * @param  {String} path The path to try to match\n * @return {Object|false}      matched parameters or false\n */\nMatcher.prototype.match = function (path) {\n  var match = this.re.exec(path),\n      matchParams = {};\n\n  if( !match ) {\n    return;\n  }\n\n  this.captures.forEach( function(capture, i) {\n    if( typeof match[i+1] === 'undefined' ) {\n      matchParams[capture] = undefined;\n    }\n    else {\n      matchParams[capture] = decodeURIComponent(match[i+1]);\n    }\n  });\n\n  return matchParams;\n};\n\n/**\n * Visitor for the AST to create a regular expression matcher\n * @class RegexpVisitor\n * @borrows Visitor-visit\n */\nvar RegexpVisitor = createVisitor({\n  'Concat': function(node) {\n    return node.children\n      .reduce(\n        function(memo, child) {\n          var childResult = this.visit(child);\n          return {\n            re: memo.re + childResult.re,\n            captures: memo.captures.concat(childResult.captures)\n          };\n        }.bind(this),\n        {re: '', captures: []}\n      );\n  },\n  'Literal': function(node) {\n    return {\n      re: node.props.value.replace(escapeRegExp, '\\\\$&'),\n      captures: []\n    };\n  },\n\n  'Splat': function(node) {\n    return {\n      re: '([^?]*?)',\n      captures: [node.props.name]\n    };\n  },\n\n  'Param': function(node) {\n    return {\n      re: '([^\\\\/\\\\?]+)',\n      captures: [node.props.name]\n    };\n  },\n\n  'Optional': function(node) {\n    var child = this.visit(node.children[0]);\n    return {\n      re: '(?:' + child.re + ')?',\n      captures: child.captures\n    };\n  },\n\n  'Root': function(node) {\n    var childResult = this.visit(node.children[0]);\n    return new Matcher({\n      re: new RegExp('^' + childResult.re + '(?=\\\\?|$)' ),\n      captures: childResult.captures\n    });\n  }\n});\n\nmodule.exports = RegexpVisitor;","'use strict';\n\nvar createVisitor  = require('./create_visitor');\n\n/**\n * Visitor for the AST to construct a path with filled in parameters\n * @class ReverseVisitor\n * @borrows Visitor-visit\n */\nvar ReverseVisitor = createVisitor({\n  'Concat': function(node, context) {\n    var childResults =  node.children\n      .map( function(child) {\n        return this.visit(child,context);\n      }.bind(this));\n\n    if( childResults.some(function(c) { return c === false; }) ) {\n      return false;\n    }\n    else {\n      return childResults.join('');\n    }\n  },\n\n  'Literal': function(node) {\n    return decodeURI(node.props.value);\n  },\n\n  'Splat': function(node, context) {\n    if( context[node.props.name] ) {\n      return context[node.props.name];\n    }\n    else {\n      return false;\n    }\n  },\n\n  'Param': function(node, context) {\n    if( context[node.props.name] ) {\n      return context[node.props.name];\n    }\n    else {\n      return false;\n    }\n  },\n\n  'Optional': function(node, context) {\n    var childResult = this.visit(node.children[0], context);\n    if( childResult ) {\n      return childResult;\n    }\n    else {\n      return '';\n    }\n  },\n\n  'Root': function(node, context) {\n    context = context || {};\n    var childResult = this.visit(node.children[0], context);\n    if( !childResult ) {\n      return false;\n    }\n    return encodeURI(childResult);\n  }\n});\n\nmodule.exports = ReverseVisitor;","// @flow\n\nconst { EventEmitter } = require('events');\nconst WebSocket = require('isomorphic-ws');\nconst muxjs = require('mux.js');\n\n/**\n * Class representing a Blend Client\n */\nclass Client extends EventEmitter {\n//  /**\n//   * Create a Blend Client.\n//   */\n  constructor() {\n    super();\n    this.transmuxer = new muxjs.mp4.Transmuxer();\n    let initSegment;\n    this.transmuxer.on('data', (event) => {\n      if (event.initSegment && !initSegment) {\n        initSegment = new Uint8Array(event.initSegment);\n        const merged = new Uint8Array(initSegment.length + event.data.length);\n        merged.set(initSegment);\n        merged.set(event.data, initSegment.length);\n        this.emit('initSegment', initSegment);\n      }\n      if (event.data) {\n        this.emit('data', event.data);\n      }\n      event.captions.forEach((cue) => {\n        this.emit('caption', cue.text);\n      });\n    });\n  }\n\n  /**\n   * Connects to a server.\n   * @param {string} address Websocket URL of the server\n   * @return {Promise<void>}\n   */\n  async open(address:string) {\n    this.address = address;\n\n    const ws = new WebSocket(address);\n\n    let heartbeatInterval;\n\n    ws.binaryType = 'arraybuffer';\n\n    ws.onopen = () => {\n      this.emit('open');\n      this.ws = ws;\n      heartbeatInterval = setInterval(() => {\n        ws.send(new Uint8Array([]));\n      }, 5000);\n    };\n\n    ws.onclose = (event) => {\n      clearInterval(heartbeatInterval);\n      const { wasClean, reason, code } = event;\n      console.log(`${wasClean ? 'Cleanly' : 'Uncleanly'} closed websocket connection to ${this.address} with code ${code}${reason ? `: ${reason}` : ''}`);\n      delete this.ws;\n      this.emit('close', code, reason);\n    };\n\n    let started;\n    ws.onmessage = (event) => {\n      const typedArray = new Uint8Array(event.data);\n      this.transmuxer.push(typedArray);\n      if (!started) {\n        started = true;\n        setTimeout(() => {\n          setInterval(() => {\n            this.transmuxer.flush();\n          }, 1000);\n        }, 1000);\n      }\n    };\n\n    ws.onerror = (event) => {\n      console.log(event);\n      this.emit('error', event);\n    };\n\n    await new Promise((resolve, reject) => {\n      const onOpen = () => {\n        this.removeListener('error', onError);\n        resolve();\n      };\n      const onError = (event: Event) => {\n        this.removeListener('open', onOpen);\n        reject(event);\n      };\n      this.once('error', onError);\n      this.once('open', onOpen);\n    });\n  }\n\n  /**\n   * Close connection to server.\n   * @param {number} [code] Websocket close reason code to send to the server\n   * @param {string} [reason] Websocket close reason to send to the server\n   * @return {Promise<void>}\n   */\n  async close(code?: number, reason?: string) {\n    if (!this.ws) {\n      return;\n    }\n    await new Promise((resolve, reject) => {\n      const onClose = () => {\n        this.removeListener('error', onError);\n        resolve();\n      };\n      const onError = (event: Event) => {\n        this.removeListener('close', onClose);\n        reject(event);\n      };\n      this.once('error', onError);\n      this.once('close', onClose);\n      this.ws.close(code, reason);\n    });\n  }\n\n  id:string;\n  address:string;\n  ws: WebSocket;\n  transmuxer: Object;\n}\n\nmodule.exports = Client;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = $getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  var args = [];\n  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    ReflectApply(this.listener, this.target, args);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n","// https://github.com/maxogden/websocket-stream/blob/48dc3ddf943e5ada668c31ccd94e9186f02fafbd/ws-fallback.js\n\nvar ws = null\n\nif (typeof WebSocket !== 'undefined') {\n  ws = WebSocket\n} else if (typeof MozWebSocket !== 'undefined') {\n  ws = MozWebSocket\n} else if (typeof global !== 'undefined') {\n  ws = global.WebSocket || global.MozWebSocket\n} else if (typeof window !== 'undefined') {\n  ws = window.WebSocket || window.MozWebSocket\n} else if (typeof self !== 'undefined') {\n  ws = self.WebSocket || self.MozWebSocket\n}\n\nmodule.exports = ws\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","'use strict';\n\nvar muxjs = {\n  codecs: require('./codecs'),\n  mp4: require('./mp4'),\n  flv: require('./flv'),\n  mp2t: require('./m2ts')\n};\n\n// include all the tools when the full library is required\nmuxjs.mp4.tools = require('./tools/mp4-inspector');\nmuxjs.flv.tools = require('./tools/flv-inspector');\nmuxjs.mp2t.tools = require('./tools/ts-inspector');\n\n\nmodule.exports = muxjs;\n","module.exports = {\n  adts: require('./adts'),\n  h264: require('./h264')\n};\n","'use strict';\n\nvar ExpGolomb;\n\n/**\n * Parser for exponential Golomb codes, a variable-bitwidth number encoding\n * scheme used by h264.\n */\nExpGolomb = function(workingData) {\n  var\n    // the number of bytes left to examine in workingData\n    workingBytesAvailable = workingData.byteLength,\n\n    // the current word being examined\n    workingWord = 0, // :uint\n\n    // the number of bits left to examine in the current word\n    workingBitsAvailable = 0; // :uint;\n\n  // ():uint\n  this.length = function() {\n    return (8 * workingBytesAvailable);\n  };\n\n  // ():uint\n  this.bitsAvailable = function() {\n    return (8 * workingBytesAvailable) + workingBitsAvailable;\n  };\n\n  // ():void\n  this.loadWord = function() {\n    var\n      position = workingData.byteLength - workingBytesAvailable,\n      workingBytes = new Uint8Array(4),\n      availableBytes = Math.min(4, workingBytesAvailable);\n\n    if (availableBytes === 0) {\n      throw new Error('no bytes available');\n    }\n\n    workingBytes.set(workingData.subarray(position,\n                                          position + availableBytes));\n    workingWord = new DataView(workingBytes.buffer).getUint32(0);\n\n    // track the amount of workingData that has been processed\n    workingBitsAvailable = availableBytes * 8;\n    workingBytesAvailable -= availableBytes;\n  };\n\n  // (count:int):void\n  this.skipBits = function(count) {\n    var skipBytes; // :int\n    if (workingBitsAvailable > count) {\n      workingWord          <<= count;\n      workingBitsAvailable -= count;\n    } else {\n      count -= workingBitsAvailable;\n      skipBytes = Math.floor(count / 8);\n\n      count -= (skipBytes * 8);\n      workingBytesAvailable -= skipBytes;\n\n      this.loadWord();\n\n      workingWord <<= count;\n      workingBitsAvailable -= count;\n    }\n  };\n\n  // (size:int):uint\n  this.readBits = function(size) {\n    var\n      bits = Math.min(workingBitsAvailable, size), // :uint\n      valu = workingWord >>> (32 - bits); // :uint\n    // if size > 31, handle error\n    workingBitsAvailable -= bits;\n    if (workingBitsAvailable > 0) {\n      workingWord <<= bits;\n    } else if (workingBytesAvailable > 0) {\n      this.loadWord();\n    }\n\n    bits = size - bits;\n    if (bits > 0) {\n      return valu << bits | this.readBits(bits);\n    }\n    return valu;\n  };\n\n  // ():uint\n  this.skipLeadingZeros = function() {\n    var leadingZeroCount; // :uint\n    for (leadingZeroCount = 0; leadingZeroCount < workingBitsAvailable; ++leadingZeroCount) {\n      if ((workingWord & (0x80000000 >>> leadingZeroCount)) !== 0) {\n        // the first bit of working word is 1\n        workingWord <<= leadingZeroCount;\n        workingBitsAvailable -= leadingZeroCount;\n        return leadingZeroCount;\n      }\n    }\n\n    // we exhausted workingWord and still have not found a 1\n    this.loadWord();\n    return leadingZeroCount + this.skipLeadingZeros();\n  };\n\n  // ():void\n  this.skipUnsignedExpGolomb = function() {\n    this.skipBits(1 + this.skipLeadingZeros());\n  };\n\n  // ():void\n  this.skipExpGolomb = function() {\n    this.skipBits(1 + this.skipLeadingZeros());\n  };\n\n  // ():uint\n  this.readUnsignedExpGolomb = function() {\n    var clz = this.skipLeadingZeros(); // :uint\n    return this.readBits(clz + 1) - 1;\n  };\n\n  // ():int\n  this.readExpGolomb = function() {\n    var valu = this.readUnsignedExpGolomb(); // :int\n    if (0x01 & valu) {\n      // the number is odd if the low order bit is set\n      return (1 + valu) >>> 1; // add 1 to make it even, and divide by 2\n    }\n    return -1 * (valu >>> 1); // divide by two then make it negative\n  };\n\n  // Some convenience functions\n  // :Boolean\n  this.readBoolean = function() {\n    return this.readBits(1) === 1;\n  };\n\n  // ():int\n  this.readUnsignedByte = function() {\n    return this.readBits(8);\n  };\n\n  this.loadWord();\n};\n\nmodule.exports = ExpGolomb;\n","module.exports = {\n  generator: require('./mp4-generator'),\n  probe: require('./probe'),\n  Transmuxer: require('./transmuxer').Transmuxer,\n  AudioSegmentStream: require('./transmuxer').AudioSegmentStream,\n  VideoSegmentStream: require('./transmuxer').VideoSegmentStream,\n  CaptionParser: require('./caption-parser')\n};\n","var toUnsigned = function(value) {\n  return value >>> 0;\n};\n\nmodule.exports = {\n  toUnsigned: toUnsigned\n};\n","// Convert an array of nal units into an array of frames with each frame being\n// composed of the nal units that make up that frame\n// Also keep track of cummulative data about the frame from the nal units such\n// as the frame duration, starting pts, etc.\nvar groupNalsIntoFrames = function(nalUnits) {\n  var\n    i,\n    currentNal,\n    currentFrame = [],\n    frames = [];\n\n  currentFrame.byteLength = 0;\n\n  for (i = 0; i < nalUnits.length; i++) {\n    currentNal = nalUnits[i];\n\n    // Split on 'aud'-type nal units\n    if (currentNal.nalUnitType === 'access_unit_delimiter_rbsp') {\n      // Since the very first nal unit is expected to be an AUD\n      // only push to the frames array when currentFrame is not empty\n      if (currentFrame.length) {\n        currentFrame.duration = currentNal.dts - currentFrame.dts;\n        frames.push(currentFrame);\n      }\n      currentFrame = [currentNal];\n      currentFrame.byteLength = currentNal.data.byteLength;\n      currentFrame.pts = currentNal.pts;\n      currentFrame.dts = currentNal.dts;\n    } else {\n      // Specifically flag key frames for ease of use later\n      if (currentNal.nalUnitType === 'slice_layer_without_partitioning_rbsp_idr') {\n        currentFrame.keyFrame = true;\n      }\n      currentFrame.duration = currentNal.dts - currentFrame.dts;\n      currentFrame.byteLength += currentNal.data.byteLength;\n      currentFrame.push(currentNal);\n    }\n  }\n\n  // For the last frame, use the duration of the previous frame if we\n  // have nothing better to go on\n  if (frames.length &&\n      (!currentFrame.duration ||\n       currentFrame.duration <= 0)) {\n    currentFrame.duration = frames[frames.length - 1].duration;\n  }\n\n  // Push the final frame\n  frames.push(currentFrame);\n  return frames;\n};\n\n// Convert an array of frames into an array of Gop with each Gop being composed\n// of the frames that make up that Gop\n// Also keep track of cummulative data about the Gop from the frames such as the\n// Gop duration, starting pts, etc.\nvar groupFramesIntoGops = function(frames) {\n  var\n    i,\n    currentFrame,\n    currentGop = [],\n    gops = [];\n\n  // We must pre-set some of the values on the Gop since we\n  // keep running totals of these values\n  currentGop.byteLength = 0;\n  currentGop.nalCount = 0;\n  currentGop.duration = 0;\n  currentGop.pts = frames[0].pts;\n  currentGop.dts = frames[0].dts;\n\n  // store some metadata about all the Gops\n  gops.byteLength = 0;\n  gops.nalCount = 0;\n  gops.duration = 0;\n  gops.pts = frames[0].pts;\n  gops.dts = frames[0].dts;\n\n  for (i = 0; i < frames.length; i++) {\n    currentFrame = frames[i];\n\n    if (currentFrame.keyFrame) {\n      // Since the very first frame is expected to be an keyframe\n      // only push to the gops array when currentGop is not empty\n      if (currentGop.length) {\n        gops.push(currentGop);\n        gops.byteLength += currentGop.byteLength;\n        gops.nalCount += currentGop.nalCount;\n        gops.duration += currentGop.duration;\n      }\n\n      currentGop = [currentFrame];\n      currentGop.nalCount = currentFrame.length;\n      currentGop.byteLength = currentFrame.byteLength;\n      currentGop.pts = currentFrame.pts;\n      currentGop.dts = currentFrame.dts;\n      currentGop.duration = currentFrame.duration;\n    } else {\n      currentGop.duration += currentFrame.duration;\n      currentGop.nalCount += currentFrame.length;\n      currentGop.byteLength += currentFrame.byteLength;\n      currentGop.push(currentFrame);\n    }\n  }\n\n  if (gops.length && currentGop.duration <= 0) {\n    currentGop.duration = gops[gops.length - 1].duration;\n  }\n  gops.byteLength += currentGop.byteLength;\n  gops.nalCount += currentGop.nalCount;\n  gops.duration += currentGop.duration;\n\n  // push the final Gop\n  gops.push(currentGop);\n  return gops;\n};\n\n/*\n * Search for the first keyframe in the GOPs and throw away all frames\n * until that keyframe. Then extend the duration of the pulled keyframe\n * and pull the PTS and DTS of the keyframe so that it covers the time\n * range of the frames that were disposed.\n *\n * @param {Array} gops video GOPs\n * @returns {Array} modified video GOPs\n */\nvar extendFirstKeyFrame = function(gops) {\n  var currentGop;\n\n  if (!gops[0][0].keyFrame && gops.length > 1) {\n    // Remove the first GOP\n    currentGop = gops.shift();\n\n    gops.byteLength -= currentGop.byteLength;\n    gops.nalCount -= currentGop.nalCount;\n\n    // Extend the first frame of what is now the\n    // first gop to cover the time period of the\n    // frames we just removed\n    gops[0][0].dts = currentGop.dts;\n    gops[0][0].pts = currentGop.pts;\n    gops[0][0].duration += currentGop.duration;\n  }\n\n  return gops;\n};\n\n/**\n * Default sample object\n * see ISO/IEC 14496-12:2012, section 8.6.4.3\n */\nvar createDefaultSample = function() {\n  return {\n    size: 0,\n    flags: {\n      isLeading: 0,\n      dependsOn: 1,\n      isDependedOn: 0,\n      hasRedundancy: 0,\n      degradationPriority: 0,\n      isNonSyncSample: 1\n    }\n  };\n};\n\n/*\n * Collates information from a video frame into an object for eventual\n * entry into an MP4 sample table.\n *\n * @param {Object} frame the video frame\n * @param {Number} dataOffset the byte offset to position the sample\n * @return {Object} object containing sample table info for a frame\n */\nvar sampleForFrame = function(frame, dataOffset) {\n  var sample = createDefaultSample();\n\n  sample.dataOffset = dataOffset;\n  sample.compositionTimeOffset = frame.pts - frame.dts;\n  sample.duration = frame.duration;\n  sample.size = 4 * frame.length; // Space for nal unit size\n  sample.size += frame.byteLength;\n\n  if (frame.keyFrame) {\n    sample.flags.dependsOn = 2;\n    sample.flags.isNonSyncSample = 0;\n  }\n\n  return sample;\n};\n\n// generate the track's sample table from an array of gops\nvar generateSampleTable = function(gops, baseDataOffset) {\n  var\n    h, i,\n    sample,\n    currentGop,\n    currentFrame,\n    dataOffset = baseDataOffset || 0,\n    samples = [];\n\n  for (h = 0; h < gops.length; h++) {\n    currentGop = gops[h];\n\n    for (i = 0; i < currentGop.length; i++) {\n      currentFrame = currentGop[i];\n\n      sample = sampleForFrame(currentFrame, dataOffset);\n\n      dataOffset += sample.size;\n\n      samples.push(sample);\n    }\n  }\n  return samples;\n};\n\n// generate the track's raw mdat data from an array of gops\nvar concatenateNalData = function(gops) {\n  var\n    h, i, j,\n    currentGop,\n    currentFrame,\n    currentNal,\n    dataOffset = 0,\n    nalsByteLength = gops.byteLength,\n    numberOfNals = gops.nalCount,\n    totalByteLength = nalsByteLength + 4 * numberOfNals,\n    data = new Uint8Array(totalByteLength),\n    view = new DataView(data.buffer);\n\n  // For each Gop..\n  for (h = 0; h < gops.length; h++) {\n    currentGop = gops[h];\n\n    // For each Frame..\n    for (i = 0; i < currentGop.length; i++) {\n      currentFrame = currentGop[i];\n\n      // For each NAL..\n      for (j = 0; j < currentFrame.length; j++) {\n        currentNal = currentFrame[j];\n\n        view.setUint32(dataOffset, currentNal.data.byteLength);\n        dataOffset += 4;\n        data.set(currentNal.data, dataOffset);\n        dataOffset += currentNal.data.byteLength;\n      }\n    }\n  }\n  return data;\n};\n\nmodule.exports = {\n  groupNalsIntoFrames: groupNalsIntoFrames,\n  groupFramesIntoGops: groupFramesIntoGops,\n  extendFirstKeyFrame: extendFirstKeyFrame,\n  generateSampleTable: generateSampleTable,\n  concatenateNalData: concatenateNalData\n};\n","var coneOfSilence = require('../data/silence');\nvar clock = require('../utils/clock');\n\nvar ONE_SECOND_IN_TS = 90000; // 90kHz clock\n\n/**\n * Sum the `byteLength` properties of the data in each AAC frame\n */\nvar sumFrameByteLengths = function(array) {\n  var\n    i,\n    currentObj,\n    sum = 0;\n\n  // sum the byteLength's all each nal unit in the frame\n  for (i = 0; i < array.length; i++) {\n    currentObj = array[i];\n    sum += currentObj.data.byteLength;\n  }\n\n  return sum;\n};\n\n// Possibly pad (prefix) the audio track with silence if appending this track\n// would lead to the introduction of a gap in the audio buffer\nvar prefixWithSilence = function(\n  track,\n  frames,\n  audioAppendStartTs,\n  videoBaseMediaDecodeTime\n) {\n  var\n    baseMediaDecodeTimeTs,\n    frameDuration = 0,\n    audioGapDuration = 0,\n    audioFillFrameCount = 0,\n    audioFillDuration = 0,\n    silentFrame,\n    i;\n\n  if (!frames.length) {\n    return;\n  }\n\n  baseMediaDecodeTimeTs =\n    clock.audioTsToVideoTs(track.baseMediaDecodeTime, track.samplerate);\n  // determine frame clock duration based on sample rate, round up to avoid overfills\n  frameDuration = Math.ceil(ONE_SECOND_IN_TS / (track.samplerate / 1024));\n\n  if (audioAppendStartTs && videoBaseMediaDecodeTime) {\n    // insert the shortest possible amount (audio gap or audio to video gap)\n    audioGapDuration =\n      baseMediaDecodeTimeTs - Math.max(audioAppendStartTs, videoBaseMediaDecodeTime);\n    // number of full frames in the audio gap\n    audioFillFrameCount = Math.floor(audioGapDuration / frameDuration);\n    audioFillDuration = audioFillFrameCount * frameDuration;\n  }\n\n  // don't attempt to fill gaps smaller than a single frame or larger\n  // than a half second\n  if (audioFillFrameCount < 1 || audioFillDuration > ONE_SECOND_IN_TS / 2) {\n    return;\n  }\n\n  silentFrame = coneOfSilence[track.samplerate];\n\n  if (!silentFrame) {\n    // we don't have a silent frame pregenerated for the sample rate, so use a frame\n    // from the content instead\n    silentFrame = frames[0].data;\n  }\n\n  for (i = 0; i < audioFillFrameCount; i++) {\n    frames.splice(i, 0, {\n      data: silentFrame\n    });\n  }\n\n  track.baseMediaDecodeTime -=\n    Math.floor(clock.videoTsToAudioTs(audioFillDuration, track.samplerate));\n};\n\n// If the audio segment extends before the earliest allowed dts\n// value, remove AAC frames until starts at or after the earliest\n// allowed DTS so that we don't end up with a negative baseMedia-\n// DecodeTime for the audio track\nvar trimAdtsFramesByEarliestDts = function(adtsFrames, track, earliestAllowedDts) {\n  if (track.minSegmentDts >= earliestAllowedDts) {\n    return adtsFrames;\n  }\n\n  // We will need to recalculate the earliest segment Dts\n  track.minSegmentDts = Infinity;\n\n  return adtsFrames.filter(function(currentFrame) {\n    // If this is an allowed frame, keep it and record it's Dts\n    if (currentFrame.dts >= earliestAllowedDts) {\n      track.minSegmentDts = Math.min(track.minSegmentDts, currentFrame.dts);\n      track.minSegmentPts = track.minSegmentDts;\n      return true;\n    }\n    // Otherwise, discard it\n    return false;\n  });\n};\n\n// generate the track's raw mdat data from an array of frames\nvar generateSampleTable = function(frames) {\n  var\n    i,\n    currentFrame,\n    samples = [];\n\n  for (i = 0; i < frames.length; i++) {\n    currentFrame = frames[i];\n    samples.push({\n      size: currentFrame.data.byteLength,\n      duration: 1024 // For AAC audio, all samples contain 1024 samples\n    });\n  }\n  return samples;\n};\n\n// generate the track's sample table from an array of frames\nvar concatenateFrameData = function(frames) {\n  var\n    i,\n    currentFrame,\n    dataOffset = 0,\n    data = new Uint8Array(sumFrameByteLengths(frames));\n\n  for (i = 0; i < frames.length; i++) {\n    currentFrame = frames[i];\n\n    data.set(currentFrame.data, dataOffset);\n    dataOffset += currentFrame.data.byteLength;\n  }\n  return data;\n};\n\nmodule.exports = {\n  prefixWithSilence: prefixWithSilence,\n  trimAdtsFramesByEarliestDts: trimAdtsFramesByEarliestDts,\n  generateSampleTable: generateSampleTable,\n  concatenateFrameData: concatenateFrameData\n};\n","var highPrefix = [33, 16, 5, 32, 164, 27];\nvar lowPrefix = [33, 65, 108, 84, 1, 2, 4, 8, 168, 2, 4, 8, 17, 191, 252];\nvar zeroFill = function(count) {\n  var a = [];\n  while (count--) {\n    a.push(0);\n  }\n  return a;\n};\n\nvar makeTable = function(metaTable) {\n  return Object.keys(metaTable).reduce(function(obj, key) {\n    obj[key] = new Uint8Array(metaTable[key].reduce(function(arr, part) {\n      return arr.concat(part);\n    }, []));\n    return obj;\n  }, {});\n};\n\n// Frames-of-silence to use for filling in missing AAC frames\nvar coneOfSilence = {\n  96000: [highPrefix, [227, 64], zeroFill(154), [56]],\n  88200: [highPrefix, [231], zeroFill(170), [56]],\n  64000: [highPrefix, [248, 192], zeroFill(240), [56]],\n  48000: [highPrefix, [255, 192], zeroFill(268), [55, 148, 128], zeroFill(54), [112]],\n  44100: [highPrefix, [255, 192], zeroFill(268), [55, 163, 128], zeroFill(84), [112]],\n  32000: [highPrefix, [255, 192], zeroFill(268), [55, 234], zeroFill(226), [112]],\n  24000: [highPrefix, [255, 192], zeroFill(268), [55, 255, 128], zeroFill(268), [111, 112], zeroFill(126), [224]],\n  16000: [highPrefix, [255, 192], zeroFill(268), [55, 255, 128], zeroFill(268), [111, 255], zeroFill(269), [223, 108], zeroFill(195), [1, 192]],\n  12000: [lowPrefix, zeroFill(268), [3, 127, 248], zeroFill(268), [6, 255, 240], zeroFill(268), [13, 255, 224], zeroFill(268), [27, 253, 128], zeroFill(259), [56]],\n  11025: [lowPrefix, zeroFill(268), [3, 127, 248], zeroFill(268), [6, 255, 240], zeroFill(268), [13, 255, 224], zeroFill(268), [27, 255, 192], zeroFill(268), [55, 175, 128], zeroFill(108), [112]],\n  8000: [lowPrefix, zeroFill(268), [3, 121, 16], zeroFill(47), [7]]\n};\n\nmodule.exports = makeTable(coneOfSilence);\n","var\n  ONE_SECOND_IN_TS = 90000, // 90kHz clock\n  secondsToVideoTs,\n  secondsToAudioTs,\n  videoTsToSeconds,\n  audioTsToSeconds,\n  audioTsToVideoTs,\n  videoTsToAudioTs;\n\nsecondsToVideoTs = function(seconds) {\n  return seconds * ONE_SECOND_IN_TS;\n};\n\nsecondsToAudioTs = function(seconds, sampleRate) {\n  return seconds * sampleRate;\n};\n\nvideoTsToSeconds = function(timestamp) {\n  return timestamp / ONE_SECOND_IN_TS;\n};\n\naudioTsToSeconds = function(timestamp, sampleRate) {\n  return timestamp / sampleRate;\n};\n\naudioTsToVideoTs = function(timestamp, sampleRate) {\n  return secondsToVideoTs(audioTsToSeconds(timestamp, sampleRate));\n};\n\nvideoTsToAudioTs = function(timestamp, sampleRate) {\n  return secondsToAudioTs(videoTsToSeconds(timestamp), sampleRate);\n};\n\nmodule.exports = {\n  secondsToVideoTs: secondsToVideoTs,\n  secondsToAudioTs: secondsToAudioTs,\n  videoTsToSeconds: videoTsToSeconds,\n  audioTsToSeconds: audioTsToSeconds,\n  audioTsToVideoTs: audioTsToVideoTs,\n  videoTsToAudioTs: videoTsToAudioTs\n};\n","var ONE_SECOND_IN_TS = 90000; // 90kHz clock\n\n/**\n * Store information about the start and end of the track and the\n * duration for each frame/sample we process in order to calculate\n * the baseMediaDecodeTime\n */\nvar collectDtsInfo = function(track, data) {\n  if (typeof data.pts === 'number') {\n    if (track.timelineStartInfo.pts === undefined) {\n      track.timelineStartInfo.pts = data.pts;\n    }\n\n    if (track.minSegmentPts === undefined) {\n      track.minSegmentPts = data.pts;\n    } else {\n      track.minSegmentPts = Math.min(track.minSegmentPts, data.pts);\n    }\n\n    if (track.maxSegmentPts === undefined) {\n      track.maxSegmentPts = data.pts;\n    } else {\n      track.maxSegmentPts = Math.max(track.maxSegmentPts, data.pts);\n    }\n  }\n\n  if (typeof data.dts === 'number') {\n    if (track.timelineStartInfo.dts === undefined) {\n      track.timelineStartInfo.dts = data.dts;\n    }\n\n    if (track.minSegmentDts === undefined) {\n      track.minSegmentDts = data.dts;\n    } else {\n      track.minSegmentDts = Math.min(track.minSegmentDts, data.dts);\n    }\n\n    if (track.maxSegmentDts === undefined) {\n      track.maxSegmentDts = data.dts;\n    } else {\n      track.maxSegmentDts = Math.max(track.maxSegmentDts, data.dts);\n    }\n  }\n};\n\n/**\n * Clear values used to calculate the baseMediaDecodeTime between\n * tracks\n */\nvar clearDtsInfo = function(track) {\n  delete track.minSegmentDts;\n  delete track.maxSegmentDts;\n  delete track.minSegmentPts;\n  delete track.maxSegmentPts;\n};\n\n/**\n * Calculate the track's baseMediaDecodeTime based on the earliest\n * DTS the transmuxer has ever seen and the minimum DTS for the\n * current track\n * @param track {object} track metadata configuration\n * @param keepOriginalTimestamps {boolean} If true, keep the timestamps\n *        in the source; false to adjust the first segment to start at 0.\n */\nvar calculateTrackBaseMediaDecodeTime = function(track, keepOriginalTimestamps) {\n  var\n    baseMediaDecodeTime,\n    scale,\n    minSegmentDts = track.minSegmentDts;\n\n  // Optionally adjust the time so the first segment starts at zero.\n  if (!keepOriginalTimestamps) {\n    minSegmentDts -= track.timelineStartInfo.dts;\n  }\n\n  // track.timelineStartInfo.baseMediaDecodeTime is the location, in time, where\n  // we want the start of the first segment to be placed\n  baseMediaDecodeTime = track.timelineStartInfo.baseMediaDecodeTime;\n\n  // Add to that the distance this segment is from the very first\n  baseMediaDecodeTime += minSegmentDts;\n\n  // baseMediaDecodeTime must not become negative\n  baseMediaDecodeTime = Math.max(0, baseMediaDecodeTime);\n\n  if (track.type === 'audio') {\n    // Audio has a different clock equal to the sampling_rate so we need to\n    // scale the PTS values into the clock rate of the track\n    scale = track.samplerate / ONE_SECOND_IN_TS;\n    baseMediaDecodeTime *= scale;\n    baseMediaDecodeTime = Math.floor(baseMediaDecodeTime);\n  }\n\n  return baseMediaDecodeTime;\n};\n\nmodule.exports = {\n  clearDtsInfo: clearDtsInfo,\n  calculateTrackBaseMediaDecodeTime: calculateTrackBaseMediaDecodeTime,\n  collectDtsInfo: collectDtsInfo\n};\n","/**\n * Accepts program elementary stream (PES) data events and parses out\n * ID3 metadata from them, if present.\n * @see http://id3.org/id3v2.3.0\n */\n'use strict';\nvar\n  Stream = require('../utils/stream'),\n  StreamTypes = require('./stream-types'),\n  // return a percent-encoded representation of the specified byte range\n  // @see http://en.wikipedia.org/wiki/Percent-encoding\n  percentEncode = function(bytes, start, end) {\n    var i, result = '';\n    for (i = start; i < end; i++) {\n      result += '%' + ('00' + bytes[i].toString(16)).slice(-2);\n    }\n    return result;\n  },\n  // return the string representation of the specified byte range,\n  // interpreted as UTf-8.\n  parseUtf8 = function(bytes, start, end) {\n    return decodeURIComponent(percentEncode(bytes, start, end));\n  },\n  // return the string representation of the specified byte range,\n  // interpreted as ISO-8859-1.\n  parseIso88591 = function(bytes, start, end) {\n    return unescape(percentEncode(bytes, start, end)); // jshint ignore:line\n  },\n  parseSyncSafeInteger = function(data) {\n    return (data[0] << 21) |\n            (data[1] << 14) |\n            (data[2] << 7) |\n            (data[3]);\n  },\n  tagParsers = {\n    TXXX: function(tag) {\n      var i;\n      if (tag.data[0] !== 3) {\n        // ignore frames with unrecognized character encodings\n        return;\n      }\n\n      for (i = 1; i < tag.data.length; i++) {\n        if (tag.data[i] === 0) {\n          // parse the text fields\n          tag.description = parseUtf8(tag.data, 1, i);\n          // do not include the null terminator in the tag value\n          tag.value = parseUtf8(tag.data, i + 1, tag.data.length).replace(/\\0*$/, '');\n          break;\n        }\n      }\n      tag.data = tag.value;\n    },\n    WXXX: function(tag) {\n      var i;\n      if (tag.data[0] !== 3) {\n        // ignore frames with unrecognized character encodings\n        return;\n      }\n\n      for (i = 1; i < tag.data.length; i++) {\n        if (tag.data[i] === 0) {\n          // parse the description and URL fields\n          tag.description = parseUtf8(tag.data, 1, i);\n          tag.url = parseUtf8(tag.data, i + 1, tag.data.length);\n          break;\n        }\n      }\n    },\n    PRIV: function(tag) {\n      var i;\n\n      for (i = 0; i < tag.data.length; i++) {\n        if (tag.data[i] === 0) {\n          // parse the description and URL fields\n          tag.owner = parseIso88591(tag.data, 0, i);\n          break;\n        }\n      }\n      tag.privateData = tag.data.subarray(i + 1);\n      tag.data = tag.privateData;\n    }\n  },\n  MetadataStream;\n\nMetadataStream = function(options) {\n  var\n    settings = {\n      debug: !!(options && options.debug),\n\n      // the bytes of the program-level descriptor field in MP2T\n      // see ISO/IEC 13818-1:2013 (E), section 2.6 \"Program and\n      // program element descriptors\"\n      descriptor: options && options.descriptor\n    },\n    // the total size in bytes of the ID3 tag being parsed\n    tagSize = 0,\n    // tag data that is not complete enough to be parsed\n    buffer = [],\n    // the total number of bytes currently in the buffer\n    bufferSize = 0,\n    i;\n\n  MetadataStream.prototype.init.call(this);\n\n  // calculate the text track in-band metadata track dispatch type\n  // https://html.spec.whatwg.org/multipage/embedded-content.html#steps-to-expose-a-media-resource-specific-text-track\n  this.dispatchType = StreamTypes.METADATA_STREAM_TYPE.toString(16);\n  if (settings.descriptor) {\n    for (i = 0; i < settings.descriptor.length; i++) {\n      this.dispatchType += ('00' + settings.descriptor[i].toString(16)).slice(-2);\n    }\n  }\n\n  this.push = function(chunk) {\n    var tag, frameStart, frameSize, frame, i, frameHeader;\n    if (chunk.type !== 'timed-metadata') {\n      return;\n    }\n\n    // if data_alignment_indicator is set in the PES header,\n    // we must have the start of a new ID3 tag. Assume anything\n    // remaining in the buffer was malformed and throw it out\n    if (chunk.dataAlignmentIndicator) {\n      bufferSize = 0;\n      buffer.length = 0;\n    }\n\n    // ignore events that don't look like ID3 data\n    if (buffer.length === 0 &&\n        (chunk.data.length < 10 ||\n          chunk.data[0] !== 'I'.charCodeAt(0) ||\n          chunk.data[1] !== 'D'.charCodeAt(0) ||\n          chunk.data[2] !== '3'.charCodeAt(0))) {\n      if (settings.debug) {\n        // eslint-disable-next-line no-console\n        console.log('Skipping unrecognized metadata packet');\n      }\n      return;\n    }\n\n    // add this chunk to the data we've collected so far\n\n    buffer.push(chunk);\n    bufferSize += chunk.data.byteLength;\n\n    // grab the size of the entire frame from the ID3 header\n    if (buffer.length === 1) {\n      // the frame size is transmitted as a 28-bit integer in the\n      // last four bytes of the ID3 header.\n      // The most significant bit of each byte is dropped and the\n      // results concatenated to recover the actual value.\n      tagSize = parseSyncSafeInteger(chunk.data.subarray(6, 10));\n\n      // ID3 reports the tag size excluding the header but it's more\n      // convenient for our comparisons to include it\n      tagSize += 10;\n    }\n\n    // if the entire frame has not arrived, wait for more data\n    if (bufferSize < tagSize) {\n      return;\n    }\n\n    // collect the entire frame so it can be parsed\n    tag = {\n      data: new Uint8Array(tagSize),\n      frames: [],\n      pts: buffer[0].pts,\n      dts: buffer[0].dts\n    };\n    for (i = 0; i < tagSize;) {\n      tag.data.set(buffer[0].data.subarray(0, tagSize - i), i);\n      i += buffer[0].data.byteLength;\n      bufferSize -= buffer[0].data.byteLength;\n      buffer.shift();\n    }\n\n    // find the start of the first frame and the end of the tag\n    frameStart = 10;\n    if (tag.data[5] & 0x40) {\n      // advance the frame start past the extended header\n      frameStart += 4; // header size field\n      frameStart += parseSyncSafeInteger(tag.data.subarray(10, 14));\n\n      // clip any padding off the end\n      tagSize -= parseSyncSafeInteger(tag.data.subarray(16, 20));\n    }\n\n    // parse one or more ID3 frames\n    // http://id3.org/id3v2.3.0#ID3v2_frame_overview\n    do {\n      // determine the number of bytes in this frame\n      frameSize = parseSyncSafeInteger(tag.data.subarray(frameStart + 4, frameStart + 8));\n      if (frameSize < 1) {\n         // eslint-disable-next-line no-console\n        return console.log('Malformed ID3 frame encountered. Skipping metadata parsing.');\n      }\n      frameHeader = String.fromCharCode(tag.data[frameStart],\n                                        tag.data[frameStart + 1],\n                                        tag.data[frameStart + 2],\n                                        tag.data[frameStart + 3]);\n\n\n      frame = {\n        id: frameHeader,\n        data: tag.data.subarray(frameStart + 10, frameStart + frameSize + 10)\n      };\n      frame.key = frame.id;\n      if (tagParsers[frame.id]) {\n        tagParsers[frame.id](frame);\n\n        // handle the special PRIV frame used to indicate the start\n        // time for raw AAC data\n        if (frame.owner === 'com.apple.streaming.transportStreamTimestamp') {\n          var\n            d = frame.data,\n            size = ((d[3] & 0x01)  << 30) |\n                   (d[4]  << 22) |\n                   (d[5] << 14) |\n                   (d[6] << 6) |\n                   (d[7] >>> 2);\n\n          size *= 4;\n          size += d[7] & 0x03;\n          frame.timeStamp = size;\n          // in raw AAC, all subsequent data will be timestamped based\n          // on the value of this frame\n          // we couldn't have known the appropriate pts and dts before\n          // parsing this ID3 tag so set those values now\n          if (tag.pts === undefined && tag.dts === undefined) {\n            tag.pts = frame.timeStamp;\n            tag.dts = frame.timeStamp;\n          }\n          this.trigger('timestamp', frame);\n        }\n      }\n      tag.frames.push(frame);\n\n      frameStart += 10; // advance past the frame header\n      frameStart += frameSize; // advance past the frame body\n    } while (frameStart < tagSize);\n    this.trigger('data', tag);\n  };\n};\nMetadataStream.prototype = new Stream();\n\nmodule.exports = MetadataStream;\n","/**\n * mux.js\n *\n * Copyright (c) 2016 Brightcove\n * All rights reserved.\n *\n * A stream-based aac to mp4 converter. This utility can be used to\n * deliver mp4s to a SourceBuffer on platforms that support native\n * Media Source Extensions.\n */\n'use strict';\nvar Stream = require('../utils/stream.js');\nvar aacUtils = require('./utils');\n\n// Constants\nvar AacStream;\n\n/**\n * Splits an incoming stream of binary data into ADTS and ID3 Frames.\n */\n\nAacStream = function() {\n  var\n    everything = new Uint8Array(),\n    timeStamp = 0;\n\n  AacStream.prototype.init.call(this);\n\n  this.setTimestamp = function(timestamp) {\n    timeStamp = timestamp;\n  };\n\n  this.push = function(bytes) {\n    var\n      frameSize = 0,\n      byteIndex = 0,\n      bytesLeft,\n      chunk,\n      packet,\n      tempLength;\n\n    // If there are bytes remaining from the last segment, prepend them to the\n    // bytes that were pushed in\n    if (everything.length) {\n      tempLength = everything.length;\n      everything = new Uint8Array(bytes.byteLength + tempLength);\n      everything.set(everything.subarray(0, tempLength));\n      everything.set(bytes, tempLength);\n    } else {\n      everything = bytes;\n    }\n\n    while (everything.length - byteIndex >= 3) {\n      if ((everything[byteIndex] === 'I'.charCodeAt(0)) &&\n          (everything[byteIndex + 1] === 'D'.charCodeAt(0)) &&\n          (everything[byteIndex + 2] === '3'.charCodeAt(0))) {\n\n        // Exit early because we don't have enough to parse\n        // the ID3 tag header\n        if (everything.length - byteIndex < 10) {\n          break;\n        }\n\n        // check framesize\n        frameSize = aacUtils.parseId3TagSize(everything, byteIndex);\n\n        // Exit early if we don't have enough in the buffer\n        // to emit a full packet\n        // Add to byteIndex to support multiple ID3 tags in sequence\n        if (byteIndex + frameSize > everything.length) {\n          break;\n        }\n        chunk = {\n          type: 'timed-metadata',\n          data: everything.subarray(byteIndex, byteIndex + frameSize)\n        };\n        this.trigger('data', chunk);\n        byteIndex += frameSize;\n        continue;\n      } else if (((everything[byteIndex] & 0xff) === 0xff) &&\n                 ((everything[byteIndex + 1] & 0xf0) === 0xf0)) {\n\n        // Exit early because we don't have enough to parse\n        // the ADTS frame header\n        if (everything.length - byteIndex < 7) {\n          break;\n        }\n\n        frameSize = aacUtils.parseAdtsSize(everything, byteIndex);\n\n        // Exit early if we don't have enough in the buffer\n        // to emit a full packet\n        if (byteIndex + frameSize > everything.length) {\n          break;\n        }\n\n        packet = {\n          type: 'audio',\n          data: everything.subarray(byteIndex, byteIndex + frameSize),\n          pts: timeStamp,\n          dts: timeStamp\n        };\n        this.trigger('data', packet);\n        byteIndex += frameSize;\n        continue;\n      }\n      byteIndex++;\n    }\n    bytesLeft = everything.length - byteIndex;\n\n    if (bytesLeft > 0) {\n      everything = everything.subarray(byteIndex);\n    } else {\n      everything = new Uint8Array();\n    }\n  };\n};\n\nAacStream.prototype = new Stream();\n\nmodule.exports = AacStream;\n","/**\n * mux.js\n *\n * Copyright (c) 2015 Brightcove\n * All rights reserved.\n *\n * Reads in-band CEA-708 captions out of FMP4 segments.\n * @see https://en.wikipedia.org/wiki/CEA-708\n */\n'use strict';\n\nvar discardEmulationPreventionBytes = require('../tools/caption-packet-parser').discardEmulationPreventionBytes;\nvar CaptionStream = require('../m2ts/caption-stream').CaptionStream;\nvar probe = require('./probe');\nvar inspect = require('../tools/mp4-inspector');\n\n/**\n  * Maps an offset in the mdat to a sample based on the the size of the samples.\n  * Assumes that `parseSamples` has been called first.\n  *\n  * @param {Number} offset - The offset into the mdat\n  * @param {Object[]} samples - An array of samples, parsed using `parseSamples`\n  * @return {?Object} The matching sample, or null if no match was found.\n  *\n  * @see ISO-BMFF-12/2015, Section 8.8.8\n **/\nvar mapToSample = function(offset, samples) {\n  var approximateOffset = offset;\n\n  for (var i = 0; i < samples.length; i++) {\n    var sample = samples[i];\n\n    if (approximateOffset < sample.size) {\n      return sample;\n    }\n\n    approximateOffset -= sample.size;\n  }\n\n  return null;\n};\n\n/**\n  * Finds SEI nal units contained in a Media Data Box.\n  * Assumes that `parseSamples` has been called first.\n  *\n  * @param {Uint8Array} avcStream - The bytes of the mdat\n  * @param {Object[]} samples - The samples parsed out by `parseSamples`\n  * @param {Number} trackId - The trackId of this video track\n  * @return {Object[]} seiNals - the parsed SEI NALUs found.\n  *   The contents of the seiNal should match what is expected by\n  *   CaptionStream.push (nalUnitType, size, data, escapedRBSP, pts, dts)\n  *\n  * @see ISO-BMFF-12/2015, Section 8.1.1\n  * @see Rec. ITU-T H.264, 7.3.2.3.1\n **/\nvar findSeiNals = function(avcStream, samples, trackId) {\n  var\n    avcView = new DataView(avcStream.buffer, avcStream.byteOffset, avcStream.byteLength),\n    result = [],\n    seiNal,\n    i,\n    length,\n    lastMatchedSample;\n\n  for (i = 0; i + 4 < avcStream.length; i += length) {\n    length = avcView.getUint32(i);\n    i += 4;\n\n    // Bail if this doesn't appear to be an H264 stream\n    if (length <= 0) {\n      continue;\n    }\n\n    switch (avcStream[i] & 0x1F) {\n    case 0x06:\n      var data = avcStream.subarray(i + 1, i + 1 + length);\n      var matchingSample = mapToSample(i, samples);\n\n      seiNal = {\n        nalUnitType: 'sei_rbsp',\n        size: length,\n        data: data,\n        escapedRBSP: discardEmulationPreventionBytes(data),\n        trackId: trackId\n      };\n\n      if (matchingSample) {\n        seiNal.pts = matchingSample.pts;\n        seiNal.dts = matchingSample.dts;\n        lastMatchedSample = matchingSample;\n      } else {\n        // If a matching sample cannot be found, use the last\n        // sample's values as they should be as close as possible\n        seiNal.pts = lastMatchedSample.pts;\n        seiNal.dts = lastMatchedSample.dts;\n      }\n\n      result.push(seiNal);\n      break;\n    default:\n      break;\n    }\n  }\n\n  return result;\n};\n\n/**\n  * Parses sample information out of Track Run Boxes and calculates\n  * the absolute presentation and decode timestamps of each sample.\n  *\n  * @param {Array<Uint8Array>} truns - The Trun Run boxes to be parsed\n  * @param {Number} baseMediaDecodeTime - base media decode time from tfdt\n      @see ISO-BMFF-12/2015, Section 8.8.12\n  * @param {Object} tfhd - The parsed Track Fragment Header\n  *   @see inspect.parseTfhd\n  * @return {Object[]} the parsed samples\n  *\n  * @see ISO-BMFF-12/2015, Section 8.8.8\n **/\nvar parseSamples = function(truns, baseMediaDecodeTime, tfhd) {\n  var currentDts = baseMediaDecodeTime;\n  var defaultSampleDuration = tfhd.defaultSampleDuration || 0;\n  var defaultSampleSize = tfhd.defaultSampleSize || 0;\n  var trackId = tfhd.trackId;\n  var allSamples = [];\n\n  truns.forEach(function(trun) {\n    // Note: We currently do not parse the sample table as well\n    // as the trun. It's possible some sources will require this.\n    // moov > trak > mdia > minf > stbl\n    var trackRun = inspect.parseTrun(trun);\n    var samples = trackRun.samples;\n\n    samples.forEach(function(sample) {\n      if (sample.duration === undefined) {\n        sample.duration = defaultSampleDuration;\n      }\n      if (sample.size === undefined) {\n        sample.size = defaultSampleSize;\n      }\n      sample.trackId = trackId;\n      sample.dts = currentDts;\n      if (sample.compositionTimeOffset === undefined) {\n        sample.compositionTimeOffset = 0;\n      }\n      sample.pts = currentDts + sample.compositionTimeOffset;\n\n      currentDts += sample.duration;\n    });\n\n    allSamples = allSamples.concat(samples);\n  });\n\n  return allSamples;\n};\n\n/**\n  * Parses out caption nals from an FMP4 segment's video tracks.\n  *\n  * @param {Uint8Array} segment - The bytes of a single segment\n  * @param {Number} videoTrackId - The trackId of a video track in the segment\n  * @return {Object.<Number, Object[]>} A mapping of video trackId to\n  *   a list of seiNals found in that track\n **/\nvar parseCaptionNals = function(segment, videoTrackId) {\n  // To get the samples\n  var trafs = probe.findBox(segment, ['moof', 'traf']);\n  // To get SEI NAL units\n  var mdats = probe.findBox(segment, ['mdat']);\n  var captionNals = {};\n  var mdatTrafPairs = [];\n\n  // Pair up each traf with a mdat as moofs and mdats are in pairs\n  mdats.forEach(function(mdat, index) {\n    var matchingTraf = trafs[index];\n    mdatTrafPairs.push({\n      mdat: mdat,\n      traf: matchingTraf\n    });\n  });\n\n  mdatTrafPairs.forEach(function(pair) {\n    var mdat = pair.mdat;\n    var traf = pair.traf;\n    var tfhd = probe.findBox(traf, ['tfhd']);\n    // Exactly 1 tfhd per traf\n    var headerInfo = inspect.parseTfhd(tfhd[0]);\n    var trackId = headerInfo.trackId;\n    var tfdt = probe.findBox(traf, ['tfdt']);\n    // Either 0 or 1 tfdt per traf\n    var baseMediaDecodeTime = (tfdt.length > 0) ? inspect.parseTfdt(tfdt[0]).baseMediaDecodeTime : 0;\n    var truns = probe.findBox(traf, ['trun']);\n    var samples;\n    var seiNals;\n\n    // Only parse video data for the chosen video track\n    if (videoTrackId === trackId && truns.length > 0) {\n      samples = parseSamples(truns, baseMediaDecodeTime, headerInfo);\n\n      seiNals = findSeiNals(mdat, samples, trackId);\n\n      if (!captionNals[trackId]) {\n        captionNals[trackId] = [];\n      }\n\n      captionNals[trackId] = captionNals[trackId].concat(seiNals);\n    }\n  });\n\n  return captionNals;\n};\n\n/**\n  * Parses out inband captions from an MP4 container and returns\n  * caption objects that can be used by WebVTT and the TextTrack API.\n  * @see https://developer.mozilla.org/en-US/docs/Web/API/VTTCue\n  * @see https://developer.mozilla.org/en-US/docs/Web/API/TextTrack\n  * Assumes that `probe.getVideoTrackIds` and `probe.timescale` have been called first\n  *\n  * @param {Uint8Array} segment - The fmp4 segment containing embedded captions\n  * @param {Number} trackId - The id of the video track to parse\n  * @param {Number} timescale - The timescale for the video track from the init segment\n  *\n  * @return {?Object[]} parsedCaptions - A list of captions or null if no video tracks\n  * @return {Number} parsedCaptions[].startTime - The time to show the caption in seconds\n  * @return {Number} parsedCaptions[].endTime - The time to stop showing the caption in seconds\n  * @return {String} parsedCaptions[].text - The visible content of the caption\n **/\nvar parseEmbeddedCaptions = function(segment, trackId, timescale) {\n  var seiNals;\n\n  if (!trackId) {\n    return null;\n  }\n\n  seiNals = parseCaptionNals(segment, trackId);\n\n  return {\n    seiNals: seiNals[trackId],\n    timescale: timescale\n  };\n};\n\n/**\n  * Converts SEI NALUs into captions that can be used by video.js\n **/\nvar CaptionParser = function() {\n  var isInitialized = false;\n  var captionStream;\n\n  // Stores segments seen before trackId and timescale are set\n  var segmentCache;\n  // Stores video track ID of the track being parsed\n  var trackId;\n  // Stores the timescale of the track being parsed\n  var timescale;\n  // Stores captions parsed so far\n  var parsedCaptions;\n\n  /**\n    * A method to indicate whether a CaptionParser has been initalized\n    * @returns {Boolean}\n   **/\n  this.isInitialized = function() {\n    return isInitialized;\n  };\n\n  /**\n    * Initializes the underlying CaptionStream, SEI NAL parsing\n    * and management, and caption collection\n   **/\n  this.init = function() {\n    captionStream = new CaptionStream();\n    isInitialized = true;\n\n    // Collect dispatched captions\n    captionStream.on('data', function(event) {\n      // Convert to seconds in the source's timescale\n      event.startTime = event.startPts / timescale;\n      event.endTime = event.endPts / timescale;\n\n      parsedCaptions.captions.push(event);\n      parsedCaptions.captionStreams[event.stream] = true;\n    });\n  };\n\n  /**\n    * Determines if a new video track will be selected\n    * or if the timescale changed\n    * @return {Boolean}\n   **/\n  this.isNewInit = function(videoTrackIds, timescales) {\n    if ((videoTrackIds && videoTrackIds.length === 0) ||\n        (timescales && typeof timescales === 'object' &&\n          Object.keys(timescales).length === 0)) {\n      return false;\n    }\n\n    return trackId !== videoTrackIds[0] ||\n      timescale !== timescales[trackId];\n  };\n\n  /**\n    * Parses out SEI captions and interacts with underlying\n    * CaptionStream to return dispatched captions\n    *\n    * @param {Uint8Array} segment - The fmp4 segment containing embedded captions\n    * @param {Number[]} videoTrackIds - A list of video tracks found in the init segment\n    * @param {Object.<Number, Number>} timescales - The timescales found in the init segment\n    * @see parseEmbeddedCaptions\n    * @see m2ts/caption-stream.js\n   **/\n  this.parse = function(segment, videoTrackIds, timescales) {\n    var parsedData;\n\n    if (!this.isInitialized()) {\n      return null;\n\n    // This is not likely to be a video segment\n    } else if (!videoTrackIds || !timescales) {\n      return null;\n\n    } else if (this.isNewInit(videoTrackIds, timescales)) {\n      // Use the first video track only as there is no\n      // mechanism to switch to other video tracks\n      trackId = videoTrackIds[0];\n      timescale = timescales[trackId];\n\n    // If an init segment has not been seen yet, hold onto segment\n    // data until we have one\n    } else if (!trackId || !timescale) {\n      segmentCache.push(segment);\n      return null;\n    }\n\n    // Now that a timescale and trackId is set, parse cached segments\n    while (segmentCache.length > 0) {\n      var cachedSegment = segmentCache.shift();\n\n      this.parse(cachedSegment, videoTrackIds, timescales);\n    }\n\n    parsedData = parseEmbeddedCaptions(segment, trackId, timescale);\n\n    if (parsedData === null || !parsedData.seiNals) {\n      return null;\n    }\n\n    this.pushNals(parsedData.seiNals);\n    // Force the parsed captions to be dispatched\n    this.flushStream();\n\n    return parsedCaptions;\n  };\n\n  /**\n    * Pushes SEI NALUs onto CaptionStream\n    * @param {Object[]} nals - A list of SEI nals parsed using `parseCaptionNals`\n    * Assumes that `parseCaptionNals` has been called first\n    * @see m2ts/caption-stream.js\n    **/\n  this.pushNals = function(nals) {\n    if (!this.isInitialized() || !nals || nals.length === 0) {\n      return null;\n    }\n\n    nals.forEach(function(nal) {\n      captionStream.push(nal);\n    });\n  };\n\n  /**\n    * Flushes underlying CaptionStream to dispatch processed, displayable captions\n    * @see m2ts/caption-stream.js\n   **/\n  this.flushStream = function() {\n    if (!this.isInitialized()) {\n      return null;\n    }\n\n    captionStream.flush();\n  };\n\n  /**\n    * Reset caption buckets for new data\n   **/\n  this.clearParsedCaptions = function() {\n    parsedCaptions.captions = [];\n    parsedCaptions.captionStreams = {};\n  };\n\n  /**\n    * Resets underlying CaptionStream\n    * @see m2ts/caption-stream.js\n   **/\n  this.resetCaptionStream = function() {\n    if (!this.isInitialized()) {\n      return null;\n    }\n\n    captionStream.reset();\n  };\n\n  /**\n    * Convenience method to clear all captions flushed from the\n    * CaptionStream and still being parsed\n    * @see m2ts/caption-stream.js\n   **/\n  this.clearAllCaptions = function() {\n    this.clearParsedCaptions();\n    this.resetCaptionStream();\n  };\n\n  /**\n    * Reset caption parser\n   **/\n  this.reset = function() {\n    segmentCache = [];\n    trackId = null;\n    timescale = null;\n\n    if (!parsedCaptions) {\n      parsedCaptions = {\n        captions: [],\n        // CC1, CC2, CC3, CC4\n        captionStreams: {}\n      };\n    } else {\n      this.clearParsedCaptions();\n    }\n\n    this.resetCaptionStream();\n  };\n\n  this.reset();\n};\n\nmodule.exports = CaptionParser;\n","module.exports = {\n  tag: require('./flv-tag'),\n  Transmuxer: require('./transmuxer'),\n  getFlvHeader: require('./flv-header')\n};\n","'use strict';\n\nvar Stream = require('../utils/stream.js');\nvar FlvTag = require('./flv-tag.js');\nvar m2ts = require('../m2ts/m2ts.js');\nvar AdtsStream = require('../codecs/adts.js');\nvar H264Stream = require('../codecs/h264').H264Stream;\nvar CoalesceStream = require('./coalesce-stream.js');\nvar TagList = require('./tag-list.js');\n\nvar\n  Transmuxer,\n  VideoSegmentStream,\n  AudioSegmentStream,\n  collectTimelineInfo,\n  metaDataTag,\n  extraDataTag;\n\n/**\n * Store information about the start and end of the tracka and the\n * duration for each frame/sample we process in order to calculate\n * the baseMediaDecodeTime\n */\ncollectTimelineInfo = function(track, data) {\n  if (typeof data.pts === 'number') {\n    if (track.timelineStartInfo.pts === undefined) {\n      track.timelineStartInfo.pts = data.pts;\n    } else {\n      track.timelineStartInfo.pts =\n        Math.min(track.timelineStartInfo.pts, data.pts);\n    }\n  }\n\n  if (typeof data.dts === 'number') {\n    if (track.timelineStartInfo.dts === undefined) {\n      track.timelineStartInfo.dts = data.dts;\n    } else {\n      track.timelineStartInfo.dts =\n        Math.min(track.timelineStartInfo.dts, data.dts);\n    }\n  }\n};\n\nmetaDataTag = function(track, pts) {\n  var\n    tag = new FlvTag(FlvTag.METADATA_TAG); // :FlvTag\n\n  tag.dts = pts;\n  tag.pts = pts;\n\n  tag.writeMetaDataDouble('videocodecid', 7);\n  tag.writeMetaDataDouble('width', track.width);\n  tag.writeMetaDataDouble('height', track.height);\n\n  return tag;\n};\n\nextraDataTag = function(track, pts) {\n  var\n    i,\n    tag = new FlvTag(FlvTag.VIDEO_TAG, true);\n\n  tag.dts = pts;\n  tag.pts = pts;\n\n  tag.writeByte(0x01);// version\n  tag.writeByte(track.profileIdc);// profile\n  tag.writeByte(track.profileCompatibility);// compatibility\n  tag.writeByte(track.levelIdc);// level\n  tag.writeByte(0xFC | 0x03); // reserved (6 bits), NULA length size - 1 (2 bits)\n  tag.writeByte(0xE0 | 0x01); // reserved (3 bits), num of SPS (5 bits)\n  tag.writeShort(track.sps[0].length); // data of SPS\n  tag.writeBytes(track.sps[0]); // SPS\n\n  tag.writeByte(track.pps.length); // num of PPS (will there ever be more that 1 PPS?)\n  for (i = 0; i < track.pps.length; ++i) {\n    tag.writeShort(track.pps[i].length); // 2 bytes for length of PPS\n    tag.writeBytes(track.pps[i]); // data of PPS\n  }\n\n  return tag;\n};\n\n/**\n * Constructs a single-track, media segment from AAC data\n * events. The output of this stream can be fed to flash.\n */\nAudioSegmentStream = function(track) {\n  var\n    adtsFrames = [],\n    videoKeyFrames = [],\n    oldExtraData;\n\n  AudioSegmentStream.prototype.init.call(this);\n\n  this.push = function(data) {\n    collectTimelineInfo(track, data);\n\n    if (track) {\n      track.audioobjecttype = data.audioobjecttype;\n      track.channelcount = data.channelcount;\n      track.samplerate = data.samplerate;\n      track.samplingfrequencyindex = data.samplingfrequencyindex;\n      track.samplesize = data.samplesize;\n      track.extraData = (track.audioobjecttype << 11) |\n                        (track.samplingfrequencyindex << 7) |\n                        (track.channelcount << 3);\n    }\n\n    data.pts = Math.round(data.pts / 90);\n    data.dts = Math.round(data.dts / 90);\n\n    // buffer audio data until end() is called\n    adtsFrames.push(data);\n  };\n\n  this.flush = function() {\n    var currentFrame, adtsFrame, lastMetaPts, tags = new TagList();\n    // return early if no audio data has been observed\n    if (adtsFrames.length === 0) {\n      this.trigger('done', 'AudioSegmentStream');\n      return;\n    }\n\n    lastMetaPts = -Infinity;\n\n    while (adtsFrames.length) {\n      currentFrame = adtsFrames.shift();\n\n      // write out a metadata frame at every video key frame\n      if (videoKeyFrames.length && currentFrame.pts >= videoKeyFrames[0]) {\n        lastMetaPts = videoKeyFrames.shift();\n        this.writeMetaDataTags(tags, lastMetaPts);\n      }\n\n      // also write out metadata tags every 1 second so that the decoder\n      // is re-initialized quickly after seeking into a different\n      // audio configuration.\n      if (track.extraData !== oldExtraData || currentFrame.pts - lastMetaPts >= 1000) {\n        this.writeMetaDataTags(tags, currentFrame.pts);\n        oldExtraData = track.extraData;\n        lastMetaPts = currentFrame.pts;\n      }\n\n      adtsFrame = new FlvTag(FlvTag.AUDIO_TAG);\n      adtsFrame.pts = currentFrame.pts;\n      adtsFrame.dts = currentFrame.dts;\n\n      adtsFrame.writeBytes(currentFrame.data);\n\n      tags.push(adtsFrame.finalize());\n    }\n\n    videoKeyFrames.length = 0;\n    oldExtraData = null;\n    this.trigger('data', {track: track, tags: tags.list});\n\n    this.trigger('done', 'AudioSegmentStream');\n  };\n\n  this.writeMetaDataTags = function(tags, pts) {\n    var adtsFrame;\n\n    adtsFrame = new FlvTag(FlvTag.METADATA_TAG);\n    // For audio, DTS is always the same as PTS. We want to set the DTS\n    // however so we can compare with video DTS to determine approximate\n    // packet order\n    adtsFrame.pts = pts;\n    adtsFrame.dts = pts;\n\n    // AAC is always 10\n    adtsFrame.writeMetaDataDouble('audiocodecid', 10);\n    adtsFrame.writeMetaDataBoolean('stereo', track.channelcount === 2);\n    adtsFrame.writeMetaDataDouble('audiosamplerate', track.samplerate);\n    // Is AAC always 16 bit?\n    adtsFrame.writeMetaDataDouble('audiosamplesize', 16);\n\n    tags.push(adtsFrame.finalize());\n\n    adtsFrame = new FlvTag(FlvTag.AUDIO_TAG, true);\n    // For audio, DTS is always the same as PTS. We want to set the DTS\n    // however so we can compare with video DTS to determine approximate\n    // packet order\n    adtsFrame.pts = pts;\n    adtsFrame.dts = pts;\n\n    adtsFrame.view.setUint16(adtsFrame.position, track.extraData);\n    adtsFrame.position += 2;\n    adtsFrame.length = Math.max(adtsFrame.length, adtsFrame.position);\n\n    tags.push(adtsFrame.finalize());\n  };\n\n  this.onVideoKeyFrame = function(pts) {\n    videoKeyFrames.push(pts);\n  };\n};\nAudioSegmentStream.prototype = new Stream();\n\n/**\n * Store FlvTags for the h264 stream\n * @param track {object} track metadata configuration\n */\nVideoSegmentStream = function(track) {\n  var\n    nalUnits = [],\n    config,\n    h264Frame;\n  VideoSegmentStream.prototype.init.call(this);\n\n  this.finishFrame = function(tags, frame) {\n    if (!frame) {\n      return;\n    }\n    // Check if keyframe and the length of tags.\n    // This makes sure we write metadata on the first frame of a segment.\n    if (config && track && track.newMetadata &&\n        (frame.keyFrame || tags.length === 0)) {\n      // Push extra data on every IDR frame in case we did a stream change + seek\n      var metaTag = metaDataTag(config, frame.dts).finalize();\n      var extraTag = extraDataTag(track, frame.dts).finalize();\n\n      metaTag.metaDataTag = extraTag.metaDataTag = true;\n\n      tags.push(metaTag);\n      tags.push(extraTag);\n      track.newMetadata = false;\n\n      this.trigger('keyframe', frame.dts);\n    }\n\n    frame.endNalUnit();\n    tags.push(frame.finalize());\n    h264Frame = null;\n  };\n\n  this.push = function(data) {\n    collectTimelineInfo(track, data);\n\n    data.pts = Math.round(data.pts / 90);\n    data.dts = Math.round(data.dts / 90);\n\n    // buffer video until flush() is called\n    nalUnits.push(data);\n  };\n\n  this.flush = function() {\n    var\n      currentNal,\n      tags = new TagList();\n\n    // Throw away nalUnits at the start of the byte stream until we find\n    // the first AUD\n    while (nalUnits.length) {\n      if (nalUnits[0].nalUnitType === 'access_unit_delimiter_rbsp') {\n        break;\n      }\n      nalUnits.shift();\n    }\n\n    // return early if no video data has been observed\n    if (nalUnits.length === 0) {\n      this.trigger('done', 'VideoSegmentStream');\n      return;\n    }\n\n    while (nalUnits.length) {\n      currentNal = nalUnits.shift();\n\n      // record the track config\n      if (currentNal.nalUnitType === 'seq_parameter_set_rbsp') {\n        track.newMetadata = true;\n        config = currentNal.config;\n        track.width = config.width;\n        track.height = config.height;\n        track.sps = [currentNal.data];\n        track.profileIdc = config.profileIdc;\n        track.levelIdc = config.levelIdc;\n        track.profileCompatibility = config.profileCompatibility;\n        h264Frame.endNalUnit();\n      } else if (currentNal.nalUnitType === 'pic_parameter_set_rbsp') {\n        track.newMetadata = true;\n        track.pps = [currentNal.data];\n        h264Frame.endNalUnit();\n      } else if (currentNal.nalUnitType === 'access_unit_delimiter_rbsp') {\n        if (h264Frame) {\n          this.finishFrame(tags, h264Frame);\n        }\n        h264Frame = new FlvTag(FlvTag.VIDEO_TAG);\n        h264Frame.pts = currentNal.pts;\n        h264Frame.dts = currentNal.dts;\n      } else {\n        if (currentNal.nalUnitType === 'slice_layer_without_partitioning_rbsp_idr') {\n          // the current sample is a key frame\n          h264Frame.keyFrame = true;\n        }\n        h264Frame.endNalUnit();\n      }\n      h264Frame.startNalUnit();\n      h264Frame.writeBytes(currentNal.data);\n    }\n    if (h264Frame) {\n      this.finishFrame(tags, h264Frame);\n    }\n\n    this.trigger('data', {track: track, tags: tags.list});\n\n    // Continue with the flush process now\n    this.trigger('done', 'VideoSegmentStream');\n  };\n};\n\nVideoSegmentStream.prototype = new Stream();\n\n/**\n * An object that incrementally transmuxes MPEG2 Trasport Stream\n * chunks into an FLV.\n */\nTransmuxer = function(options) {\n  var\n    self = this,\n\n    packetStream, parseStream, elementaryStream,\n    videoTimestampRolloverStream, audioTimestampRolloverStream,\n    timedMetadataTimestampRolloverStream,\n    adtsStream, h264Stream,\n    videoSegmentStream, audioSegmentStream, captionStream,\n    coalesceStream;\n\n  Transmuxer.prototype.init.call(this);\n\n  options = options || {};\n\n  // expose the metadata stream\n  this.metadataStream = new m2ts.MetadataStream();\n\n  options.metadataStream = this.metadataStream;\n\n  // set up the parsing pipeline\n  packetStream = new m2ts.TransportPacketStream();\n  parseStream = new m2ts.TransportParseStream();\n  elementaryStream = new m2ts.ElementaryStream();\n  videoTimestampRolloverStream = new m2ts.TimestampRolloverStream('video');\n  audioTimestampRolloverStream = new m2ts.TimestampRolloverStream('audio');\n  timedMetadataTimestampRolloverStream = new m2ts.TimestampRolloverStream('timed-metadata');\n\n  adtsStream = new AdtsStream();\n  h264Stream = new H264Stream();\n  coalesceStream = new CoalesceStream(options);\n\n  // disassemble MPEG2-TS packets into elementary streams\n  packetStream\n    .pipe(parseStream)\n    .pipe(elementaryStream);\n\n  // !!THIS ORDER IS IMPORTANT!!\n  // demux the streams\n  elementaryStream\n    .pipe(videoTimestampRolloverStream)\n    .pipe(h264Stream);\n  elementaryStream\n    .pipe(audioTimestampRolloverStream)\n    .pipe(adtsStream);\n\n  elementaryStream\n    .pipe(timedMetadataTimestampRolloverStream)\n    .pipe(this.metadataStream)\n    .pipe(coalesceStream);\n  // if CEA-708 parsing is available, hook up a caption stream\n  captionStream = new m2ts.CaptionStream();\n  h264Stream.pipe(captionStream)\n    .pipe(coalesceStream);\n\n  // hook up the segment streams once track metadata is delivered\n  elementaryStream.on('data', function(data) {\n    var i, videoTrack, audioTrack;\n\n    if (data.type === 'metadata') {\n      i = data.tracks.length;\n\n      // scan the tracks listed in the metadata\n      while (i--) {\n        if (data.tracks[i].type === 'video') {\n          videoTrack = data.tracks[i];\n        } else if (data.tracks[i].type === 'audio') {\n          audioTrack = data.tracks[i];\n        }\n      }\n\n      // hook up the video segment stream to the first track with h264 data\n      if (videoTrack && !videoSegmentStream) {\n        coalesceStream.numberOfTracks++;\n        videoSegmentStream = new VideoSegmentStream(videoTrack);\n\n        // Set up the final part of the video pipeline\n        h264Stream\n          .pipe(videoSegmentStream)\n          .pipe(coalesceStream);\n      }\n\n      if (audioTrack && !audioSegmentStream) {\n        // hook up the audio segment stream to the first track with aac data\n        coalesceStream.numberOfTracks++;\n        audioSegmentStream = new AudioSegmentStream(audioTrack);\n\n        // Set up the final part of the audio pipeline\n        adtsStream\n          .pipe(audioSegmentStream)\n          .pipe(coalesceStream);\n\n        if (videoSegmentStream) {\n          videoSegmentStream.on('keyframe', audioSegmentStream.onVideoKeyFrame);\n        }\n      }\n    }\n  });\n\n  // feed incoming data to the front of the parsing pipeline\n  this.push = function(data) {\n    packetStream.push(data);\n  };\n\n  // flush any buffered data\n  this.flush = function() {\n    // Start at the top of the pipeline and flush all pending work\n    packetStream.flush();\n  };\n\n  // Caption data has to be reset when seeking outside buffered range\n  this.resetCaptions = function() {\n    captionStream.reset();\n  };\n\n  // Re-emit any data coming from the coalesce stream to the outside world\n  coalesceStream.on('data', function(event) {\n    self.trigger('data', event);\n  });\n\n  // Let the consumer know we have finished flushing the entire pipeline\n  coalesceStream.on('done', function() {\n    self.trigger('done');\n  });\n};\nTransmuxer.prototype = new Stream();\n\n// forward compatibility\nmodule.exports = Transmuxer;\n","'use strict';\n\nvar Stream = require('../utils/stream.js');\n\n/**\n * The final stage of the transmuxer that emits the flv tags\n * for audio, video, and metadata. Also tranlates in time and\n * outputs caption data and id3 cues.\n */\nvar CoalesceStream = function(options) {\n  // Number of Tracks per output segment\n  // If greater than 1, we combine multiple\n  // tracks into a single segment\n  this.numberOfTracks = 0;\n  this.metadataStream = options.metadataStream;\n\n  this.videoTags = [];\n  this.audioTags = [];\n  this.videoTrack = null;\n  this.audioTrack = null;\n  this.pendingCaptions = [];\n  this.pendingMetadata = [];\n  this.pendingTracks = 0;\n  this.processedTracks = 0;\n\n  CoalesceStream.prototype.init.call(this);\n\n  // Take output from multiple\n  this.push = function(output) {\n    // buffer incoming captions until the associated video segment\n    // finishes\n    if (output.text) {\n      return this.pendingCaptions.push(output);\n    }\n    // buffer incoming id3 tags until the final flush\n    if (output.frames) {\n      return this.pendingMetadata.push(output);\n    }\n\n    if (output.track.type === 'video') {\n      this.videoTrack = output.track;\n      this.videoTags = output.tags;\n      this.pendingTracks++;\n    }\n    if (output.track.type === 'audio') {\n      this.audioTrack = output.track;\n      this.audioTags = output.tags;\n      this.pendingTracks++;\n    }\n  };\n};\n\nCoalesceStream.prototype = new Stream();\nCoalesceStream.prototype.flush = function(flushSource) {\n  var\n    id3,\n    caption,\n    i,\n    timelineStartPts,\n    event = {\n      tags: {},\n      captions: [],\n      captionStreams: {},\n      metadata: []\n    };\n\n  if (this.pendingTracks < this.numberOfTracks) {\n    if (flushSource !== 'VideoSegmentStream' &&\n        flushSource !== 'AudioSegmentStream') {\n      // Return because we haven't received a flush from a data-generating\n      // portion of the segment (meaning that we have only recieved meta-data\n      // or captions.)\n      return;\n    } else if (this.pendingTracks === 0) {\n      // In the case where we receive a flush without any data having been\n      // received we consider it an emitted track for the purposes of coalescing\n      // `done` events.\n      // We do this for the case where there is an audio and video track in the\n      // segment but no audio data. (seen in several playlists with alternate\n      // audio tracks and no audio present in the main TS segments.)\n      this.processedTracks++;\n\n      if (this.processedTracks < this.numberOfTracks) {\n        return;\n      }\n    }\n  }\n\n  this.processedTracks += this.pendingTracks;\n  this.pendingTracks = 0;\n\n  if (this.processedTracks < this.numberOfTracks) {\n    return;\n  }\n\n  if (this.videoTrack) {\n    timelineStartPts = this.videoTrack.timelineStartInfo.pts;\n  } else if (this.audioTrack) {\n    timelineStartPts = this.audioTrack.timelineStartInfo.pts;\n  }\n\n  event.tags.videoTags = this.videoTags;\n  event.tags.audioTags = this.audioTags;\n\n  // Translate caption PTS times into second offsets into the\n  // video timeline for the segment, and add track info\n  for (i = 0; i < this.pendingCaptions.length; i++) {\n    caption = this.pendingCaptions[i];\n    caption.startTime = caption.startPts - timelineStartPts;\n    caption.startTime /= 90e3;\n    caption.endTime = caption.endPts - timelineStartPts;\n    caption.endTime /= 90e3;\n    event.captionStreams[caption.stream] = true;\n    event.captions.push(caption);\n  }\n\n  // Translate ID3 frame PTS times into second offsets into the\n  // video timeline for the segment\n  for (i = 0; i < this.pendingMetadata.length; i++) {\n    id3 = this.pendingMetadata[i];\n    id3.cueTime = id3.pts - timelineStartPts;\n    id3.cueTime /= 90e3;\n    event.metadata.push(id3);\n  }\n  // We add this to every single emitted segment even though we only need\n  // it for the first\n  event.metadata.dispatchType = this.metadataStream.dispatchType;\n\n  // Reset stream state\n  this.videoTrack = null;\n  this.audioTrack = null;\n  this.videoTags = [];\n  this.audioTags = [];\n  this.pendingCaptions.length = 0;\n  this.pendingMetadata.length = 0;\n  this.pendingTracks = 0;\n  this.processedTracks = 0;\n\n  // Emit the final segment\n  this.trigger('data', event);\n\n  this.trigger('done');\n};\n\nmodule.exports = CoalesceStream;\n","'use strict';\n\nvar TagList = function() {\n  var self = this;\n\n  this.list = [];\n\n  this.push = function(tag) {\n    this.list.push({\n      bytes: tag.bytes,\n      dts: tag.dts,\n      pts: tag.pts,\n      keyFrame: tag.keyFrame,\n      metaDataTag: tag.metaDataTag\n    });\n  };\n\n  Object.defineProperty(this, 'length', {\n    get: function() {\n      return self.list.length;\n    }\n  });\n};\n\nmodule.exports = TagList;\n","'use strict';\n\nvar FlvTag = require('./flv-tag.js');\n\n// For information on the FLV format, see\n// http://download.macromedia.com/f4v/video_file_format_spec_v10_1.pdf.\n// Technically, this function returns the header and a metadata FLV tag\n// if duration is greater than zero\n// duration in seconds\n// @return {object} the bytes of the FLV header as a Uint8Array\nvar getFlvHeader = function(duration, audio, video) { // :ByteArray {\n  var\n    headBytes = new Uint8Array(3 + 1 + 1 + 4),\n    head = new DataView(headBytes.buffer),\n    metadata,\n    result,\n    metadataLength;\n\n  // default arguments\n  duration = duration || 0;\n  audio = audio === undefined ? true : audio;\n  video = video === undefined ? true : video;\n\n  // signature\n  head.setUint8(0, 0x46); // 'F'\n  head.setUint8(1, 0x4c); // 'L'\n  head.setUint8(2, 0x56); // 'V'\n\n  // version\n  head.setUint8(3, 0x01);\n\n  // flags\n  head.setUint8(4, (audio ? 0x04 : 0x00) | (video ? 0x01 : 0x00));\n\n  // data offset, should be 9 for FLV v1\n  head.setUint32(5, headBytes.byteLength);\n\n  // init the first FLV tag\n  if (duration <= 0) {\n    // no duration available so just write the first field of the first\n    // FLV tag\n    result = new Uint8Array(headBytes.byteLength + 4);\n    result.set(headBytes);\n    result.set([0, 0, 0, 0], headBytes.byteLength);\n    return result;\n  }\n\n  // write out the duration metadata tag\n  metadata = new FlvTag(FlvTag.METADATA_TAG);\n  metadata.pts = metadata.dts = 0;\n  metadata.writeMetaDataDouble('duration', duration);\n  metadataLength = metadata.finalize().length;\n  result = new Uint8Array(headBytes.byteLength + metadataLength);\n  result.set(headBytes);\n  result.set(head.byteLength, metadataLength);\n\n  return result;\n};\n\nmodule.exports = getFlvHeader;\n","module.exports = require('./m2ts');\n","'use strict';\n\nvar\n  tagTypes = {\n    0x08: 'audio',\n    0x09: 'video',\n    0x12: 'metadata'\n  },\n  hex = function(val) {\n    return '0x' + ('00' + val.toString(16)).slice(-2).toUpperCase();\n  },\n  hexStringList = function(data) {\n    var arr = [], i;\n\n    while (data.byteLength > 0) {\n      i = 0;\n      arr.push(hex(data[i++]));\n      data = data.subarray(i);\n    }\n    return arr.join(' ');\n  },\n  parseAVCTag = function(tag, obj) {\n    var\n      avcPacketTypes = [\n        'AVC Sequence Header',\n        'AVC NALU',\n        'AVC End-of-Sequence'\n      ],\n      compositionTime = (tag[1] & parseInt('01111111', 2) << 16) | (tag[2] << 8) | tag[3];\n\n    obj = obj || {};\n\n    obj.avcPacketType = avcPacketTypes[tag[0]];\n    obj.CompositionTime = (tag[1] & parseInt('10000000', 2)) ? -compositionTime : compositionTime;\n\n    if (tag[0] === 1) {\n      obj.nalUnitTypeRaw = hexStringList(tag.subarray(4, 100));\n    } else {\n      obj.data = hexStringList(tag.subarray(4));\n    }\n\n    return obj;\n  },\n  parseVideoTag = function(tag, obj) {\n    var\n      frameTypes = [\n        'Unknown',\n        'Keyframe (for AVC, a seekable frame)',\n        'Inter frame (for AVC, a nonseekable frame)',\n        'Disposable inter frame (H.263 only)',\n        'Generated keyframe (reserved for server use only)',\n        'Video info/command frame'\n      ],\n      codecID = tag[0] & parseInt('00001111', 2);\n\n    obj = obj || {};\n\n    obj.frameType = frameTypes[(tag[0] & parseInt('11110000', 2)) >>> 4];\n    obj.codecID = codecID;\n\n    if (codecID === 7) {\n      return parseAVCTag(tag.subarray(1), obj);\n    }\n    return obj;\n  },\n  parseAACTag = function(tag, obj) {\n    var packetTypes = [\n      'AAC Sequence Header',\n      'AAC Raw'\n    ];\n\n    obj = obj || {};\n\n    obj.aacPacketType = packetTypes[tag[0]];\n    obj.data = hexStringList(tag.subarray(1));\n\n    return obj;\n  },\n  parseAudioTag = function(tag, obj) {\n    var\n      formatTable = [\n        'Linear PCM, platform endian',\n        'ADPCM',\n        'MP3',\n        'Linear PCM, little endian',\n        'Nellymoser 16-kHz mono',\n        'Nellymoser 8-kHz mono',\n        'Nellymoser',\n        'G.711 A-law logarithmic PCM',\n        'G.711 mu-law logarithmic PCM',\n        'reserved',\n        'AAC',\n        'Speex',\n        'MP3 8-Khz',\n        'Device-specific sound'\n      ],\n      samplingRateTable = [\n        '5.5-kHz',\n        '11-kHz',\n        '22-kHz',\n        '44-kHz'\n      ],\n      soundFormat = (tag[0] & parseInt('11110000', 2)) >>> 4;\n\n    obj = obj || {};\n\n    obj.soundFormat = formatTable[soundFormat];\n    obj.soundRate = samplingRateTable[(tag[0] & parseInt('00001100', 2)) >>> 2];\n    obj.soundSize = ((tag[0] & parseInt('00000010', 2)) >>> 1) ? '16-bit' : '8-bit';\n    obj.soundType = (tag[0] & parseInt('00000001', 2)) ? 'Stereo' : 'Mono';\n\n    if (soundFormat === 10) {\n      return parseAACTag(tag.subarray(1), obj);\n    }\n    return obj;\n  },\n  parseGenericTag = function(tag) {\n    return {\n      tagType: tagTypes[tag[0]],\n      dataSize: (tag[1] << 16) | (tag[2] << 8) | tag[3],\n      timestamp: (tag[7] << 24) | (tag[4] << 16) | (tag[5] << 8) | tag[6],\n      streamID: (tag[8] << 16) | (tag[9] << 8) | tag[10]\n    };\n  },\n  inspectFlvTag = function(tag) {\n    var header = parseGenericTag(tag);\n    switch (tag[0]) {\n      case 0x08:\n        parseAudioTag(tag.subarray(11), header);\n        break;\n      case 0x09:\n        parseVideoTag(tag.subarray(11), header);\n        break;\n      case 0x12:\n    }\n    return header;\n  },\n  inspectFlv = function(bytes) {\n    var i = 9, // header\n        dataSize,\n        parsedResults = [],\n        tag;\n\n    // traverse the tags\n    i += 4; // skip previous tag size\n    while (i < bytes.byteLength) {\n      dataSize = bytes[i + 1] << 16;\n      dataSize |= bytes[i + 2] << 8;\n      dataSize |= bytes[i + 3];\n      dataSize += 11;\n\n      tag = bytes.subarray(i, i + dataSize);\n      parsedResults.push(inspectFlvTag(tag));\n      i += dataSize + 4;\n    }\n    return parsedResults;\n  },\n  textifyFlv = function(flvTagArray) {\n    return JSON.stringify(flvTagArray, null, 2);\n  };\n\nmodule.exports = {\n  inspectTag: inspectFlvTag,\n  inspect: inspectFlv,\n  textify: textifyFlv\n};\n","/**\n * mux.js\n *\n * Copyright (c) 2016 Brightcove\n * All rights reserved.\n *\n * Parse mpeg2 transport stream packets to extract basic timing information\n */\n'use strict';\n\nvar StreamTypes = require('../m2ts/stream-types.js');\nvar handleRollover = require('../m2ts/timestamp-rollover-stream.js').handleRollover;\nvar probe = {};\nprobe.ts = require('../m2ts/probe.js');\nprobe.aac = require('../aac/utils.js');\n\n\nvar\n  PES_TIMESCALE = 90000,\n  MP2T_PACKET_LENGTH = 188, // bytes\n  SYNC_BYTE = 0x47;\n\n/**\n * walks through segment data looking for pat and pmt packets to parse out\n * program map table information\n */\nvar parsePsi_ = function(bytes, pmt) {\n  var\n    startIndex = 0,\n    endIndex = MP2T_PACKET_LENGTH,\n    packet, type;\n\n  while (endIndex < bytes.byteLength) {\n    // Look for a pair of start and end sync bytes in the data..\n    if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n      // We found a packet\n      packet = bytes.subarray(startIndex, endIndex);\n      type = probe.ts.parseType(packet, pmt.pid);\n\n      switch (type) {\n        case 'pat':\n          if (!pmt.pid) {\n            pmt.pid = probe.ts.parsePat(packet);\n          }\n          break;\n        case 'pmt':\n          if (!pmt.table) {\n            pmt.table = probe.ts.parsePmt(packet);\n          }\n          break;\n        default:\n          break;\n      }\n\n      // Found the pat and pmt, we can stop walking the segment\n      if (pmt.pid && pmt.table) {\n        return;\n      }\n\n      startIndex += MP2T_PACKET_LENGTH;\n      endIndex += MP2T_PACKET_LENGTH;\n      continue;\n    }\n\n    // If we get here, we have somehow become de-synchronized and we need to step\n    // forward one byte at a time until we find a pair of sync bytes that denote\n    // a packet\n    startIndex++;\n    endIndex++;\n  }\n};\n\n/**\n * walks through the segment data from the start and end to get timing information\n * for the first and last audio pes packets\n */\nvar parseAudioPes_ = function(bytes, pmt, result) {\n  var\n    startIndex = 0,\n    endIndex = MP2T_PACKET_LENGTH,\n    packet, type, pesType, pusi, parsed;\n\n  var endLoop = false;\n\n  // Start walking from start of segment to get first audio packet\n  while (endIndex <= bytes.byteLength) {\n    // Look for a pair of start and end sync bytes in the data..\n    if (bytes[startIndex] === SYNC_BYTE &&\n        (bytes[endIndex] === SYNC_BYTE || endIndex === bytes.byteLength)) {\n      // We found a packet\n      packet = bytes.subarray(startIndex, endIndex);\n      type = probe.ts.parseType(packet, pmt.pid);\n\n      switch (type) {\n        case 'pes':\n          pesType = probe.ts.parsePesType(packet, pmt.table);\n          pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n          if (pesType === 'audio' && pusi) {\n            parsed = probe.ts.parsePesTime(packet);\n            if (parsed) {\n              parsed.type = 'audio';\n              result.audio.push(parsed);\n              endLoop = true;\n            }\n          }\n          break;\n        default:\n          break;\n      }\n\n      if (endLoop) {\n        break;\n      }\n\n      startIndex += MP2T_PACKET_LENGTH;\n      endIndex += MP2T_PACKET_LENGTH;\n      continue;\n    }\n\n    // If we get here, we have somehow become de-synchronized and we need to step\n    // forward one byte at a time until we find a pair of sync bytes that denote\n    // a packet\n    startIndex++;\n    endIndex++;\n  }\n\n  // Start walking from end of segment to get last audio packet\n  endIndex = bytes.byteLength;\n  startIndex = endIndex - MP2T_PACKET_LENGTH;\n  endLoop = false;\n  while (startIndex >= 0) {\n    // Look for a pair of start and end sync bytes in the data..\n    if (bytes[startIndex] === SYNC_BYTE &&\n        (bytes[endIndex] === SYNC_BYTE || endIndex === bytes.byteLength)) {\n      // We found a packet\n      packet = bytes.subarray(startIndex, endIndex);\n      type = probe.ts.parseType(packet, pmt.pid);\n\n      switch (type) {\n        case 'pes':\n          pesType = probe.ts.parsePesType(packet, pmt.table);\n          pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n          if (pesType === 'audio' && pusi) {\n            parsed = probe.ts.parsePesTime(packet);\n            if (parsed) {\n              parsed.type = 'audio';\n              result.audio.push(parsed);\n              endLoop = true;\n            }\n          }\n          break;\n        default:\n          break;\n      }\n\n      if (endLoop) {\n        break;\n      }\n\n      startIndex -= MP2T_PACKET_LENGTH;\n      endIndex -= MP2T_PACKET_LENGTH;\n      continue;\n    }\n\n    // If we get here, we have somehow become de-synchronized and we need to step\n    // forward one byte at a time until we find a pair of sync bytes that denote\n    // a packet\n    startIndex--;\n    endIndex--;\n  }\n};\n\n/**\n * walks through the segment data from the start and end to get timing information\n * for the first and last video pes packets as well as timing information for the first\n * key frame.\n */\nvar parseVideoPes_ = function(bytes, pmt, result) {\n  var\n    startIndex = 0,\n    endIndex = MP2T_PACKET_LENGTH,\n    packet, type, pesType, pusi, parsed, frame, i, pes;\n\n  var endLoop = false;\n\n  var currentFrame = {\n    data: [],\n    size: 0\n  };\n\n  // Start walking from start of segment to get first video packet\n  while (endIndex < bytes.byteLength) {\n    // Look for a pair of start and end sync bytes in the data..\n    if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n      // We found a packet\n      packet = bytes.subarray(startIndex, endIndex);\n      type = probe.ts.parseType(packet, pmt.pid);\n\n      switch (type) {\n        case 'pes':\n          pesType = probe.ts.parsePesType(packet, pmt.table);\n          pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n          if (pesType === 'video') {\n            if (pusi && !endLoop) {\n              parsed = probe.ts.parsePesTime(packet);\n              if (parsed) {\n                parsed.type = 'video';\n                result.video.push(parsed);\n                endLoop = true;\n              }\n            }\n            if (!result.firstKeyFrame) {\n              if (pusi) {\n                if (currentFrame.size !== 0) {\n                  frame = new Uint8Array(currentFrame.size);\n                  i = 0;\n                  while (currentFrame.data.length) {\n                    pes = currentFrame.data.shift();\n                    frame.set(pes, i);\n                    i += pes.byteLength;\n                  }\n                  if (probe.ts.videoPacketContainsKeyFrame(frame)) {\n                    result.firstKeyFrame = probe.ts.parsePesTime(frame);\n                    result.firstKeyFrame.type = 'video';\n                  }\n                  currentFrame.size = 0;\n                }\n              }\n              currentFrame.data.push(packet);\n              currentFrame.size += packet.byteLength;\n            }\n          }\n          break;\n        default:\n          break;\n      }\n\n      if (endLoop && result.firstKeyFrame) {\n        break;\n      }\n\n      startIndex += MP2T_PACKET_LENGTH;\n      endIndex += MP2T_PACKET_LENGTH;\n      continue;\n    }\n\n    // If we get here, we have somehow become de-synchronized and we need to step\n    // forward one byte at a time until we find a pair of sync bytes that denote\n    // a packet\n    startIndex++;\n    endIndex++;\n  }\n\n  // Start walking from end of segment to get last video packet\n  endIndex = bytes.byteLength;\n  startIndex = endIndex - MP2T_PACKET_LENGTH;\n  endLoop = false;\n  while (startIndex >= 0) {\n    // Look for a pair of start and end sync bytes in the data..\n    if (bytes[startIndex] === SYNC_BYTE && bytes[endIndex] === SYNC_BYTE) {\n      // We found a packet\n      packet = bytes.subarray(startIndex, endIndex);\n      type = probe.ts.parseType(packet, pmt.pid);\n\n      switch (type) {\n        case 'pes':\n          pesType = probe.ts.parsePesType(packet, pmt.table);\n          pusi = probe.ts.parsePayloadUnitStartIndicator(packet);\n          if (pesType === 'video' && pusi) {\n              parsed = probe.ts.parsePesTime(packet);\n              if (parsed) {\n                parsed.type = 'video';\n                result.video.push(parsed);\n                endLoop = true;\n              }\n          }\n          break;\n        default:\n          break;\n      }\n\n      if (endLoop) {\n        break;\n      }\n\n      startIndex -= MP2T_PACKET_LENGTH;\n      endIndex -= MP2T_PACKET_LENGTH;\n      continue;\n    }\n\n    // If we get here, we have somehow become de-synchronized and we need to step\n    // forward one byte at a time until we find a pair of sync bytes that denote\n    // a packet\n    startIndex--;\n    endIndex--;\n  }\n};\n\n/**\n * Adjusts the timestamp information for the segment to account for\n * rollover and convert to seconds based on pes packet timescale (90khz clock)\n */\nvar adjustTimestamp_ = function(segmentInfo, baseTimestamp) {\n  if (segmentInfo.audio && segmentInfo.audio.length) {\n    var audioBaseTimestamp = baseTimestamp;\n    if (typeof audioBaseTimestamp === 'undefined') {\n      audioBaseTimestamp = segmentInfo.audio[0].dts;\n    }\n    segmentInfo.audio.forEach(function(info) {\n      info.dts = handleRollover(info.dts, audioBaseTimestamp);\n      info.pts = handleRollover(info.pts, audioBaseTimestamp);\n      // time in seconds\n      info.dtsTime = info.dts / PES_TIMESCALE;\n      info.ptsTime = info.pts / PES_TIMESCALE;\n    });\n  }\n\n  if (segmentInfo.video && segmentInfo.video.length) {\n    var videoBaseTimestamp = baseTimestamp;\n    if (typeof videoBaseTimestamp === 'undefined') {\n      videoBaseTimestamp = segmentInfo.video[0].dts;\n    }\n    segmentInfo.video.forEach(function(info) {\n      info.dts = handleRollover(info.dts, videoBaseTimestamp);\n      info.pts = handleRollover(info.pts, videoBaseTimestamp);\n      // time in seconds\n      info.dtsTime = info.dts / PES_TIMESCALE;\n      info.ptsTime = info.pts / PES_TIMESCALE;\n    });\n    if (segmentInfo.firstKeyFrame) {\n      var frame = segmentInfo.firstKeyFrame;\n      frame.dts = handleRollover(frame.dts, videoBaseTimestamp);\n      frame.pts = handleRollover(frame.pts, videoBaseTimestamp);\n      // time in seconds\n      frame.dtsTime = frame.dts / PES_TIMESCALE;\n      frame.ptsTime = frame.dts / PES_TIMESCALE;\n    }\n  }\n};\n\n/**\n * inspects the aac data stream for start and end time information\n */\nvar inspectAac_ = function(bytes) {\n  var\n    endLoop = false,\n    audioCount = 0,\n    sampleRate = null,\n    timestamp = null,\n    frameSize = 0,\n    byteIndex = 0,\n    packet;\n\n  while (bytes.length - byteIndex >= 3) {\n    var type = probe.aac.parseType(bytes, byteIndex);\n    switch (type) {\n      case 'timed-metadata':\n        // Exit early because we don't have enough to parse\n        // the ID3 tag header\n        if (bytes.length - byteIndex < 10) {\n          endLoop = true;\n          break;\n        }\n\n        frameSize = probe.aac.parseId3TagSize(bytes, byteIndex);\n\n        // Exit early if we don't have enough in the buffer\n        // to emit a full packet\n        if (frameSize > bytes.length) {\n          endLoop = true;\n          break;\n        }\n        if (timestamp === null) {\n          packet = bytes.subarray(byteIndex, byteIndex + frameSize);\n          timestamp = probe.aac.parseAacTimestamp(packet);\n        }\n        byteIndex += frameSize;\n        break;\n      case 'audio':\n        // Exit early because we don't have enough to parse\n        // the ADTS frame header\n        if (bytes.length - byteIndex < 7) {\n          endLoop = true;\n          break;\n        }\n\n        frameSize = probe.aac.parseAdtsSize(bytes, byteIndex);\n\n        // Exit early if we don't have enough in the buffer\n        // to emit a full packet\n        if (frameSize > bytes.length) {\n          endLoop = true;\n          break;\n        }\n        if (sampleRate === null) {\n          packet = bytes.subarray(byteIndex, byteIndex + frameSize);\n          sampleRate = probe.aac.parseSampleRate(packet);\n        }\n        audioCount++;\n        byteIndex += frameSize;\n        break;\n      default:\n        byteIndex++;\n        break;\n    }\n    if (endLoop) {\n      return null;\n    }\n  }\n  if (sampleRate === null || timestamp === null) {\n    return null;\n  }\n\n  var audioTimescale = PES_TIMESCALE / sampleRate;\n\n  var result = {\n    audio: [\n      {\n        type: 'audio',\n        dts: timestamp,\n        pts: timestamp\n      },\n      {\n        type: 'audio',\n        dts: timestamp + (audioCount * 1024 * audioTimescale),\n        pts: timestamp + (audioCount * 1024 * audioTimescale)\n      }\n    ]\n  };\n\n  return result;\n};\n\n/**\n * inspects the transport stream segment data for start and end time information\n * of the audio and video tracks (when present) as well as the first key frame's\n * start time.\n */\nvar inspectTs_ = function(bytes) {\n  var pmt = {\n    pid: null,\n    table: null\n  };\n\n  var result = {};\n\n  parsePsi_(bytes, pmt);\n\n  for (var pid in pmt.table) {\n    if (pmt.table.hasOwnProperty(pid)) {\n      var type = pmt.table[pid];\n      switch (type) {\n        case StreamTypes.H264_STREAM_TYPE:\n          result.video = [];\n          parseVideoPes_(bytes, pmt, result);\n          if (result.video.length === 0) {\n            delete result.video;\n          }\n          break;\n        case StreamTypes.ADTS_STREAM_TYPE:\n          result.audio = [];\n          parseAudioPes_(bytes, pmt, result);\n          if (result.audio.length === 0) {\n            delete result.audio;\n          }\n          break;\n        default:\n          break;\n      }\n    }\n  }\n  return result;\n};\n\n/**\n * Inspects segment byte data and returns an object with start and end timing information\n *\n * @param {Uint8Array} bytes The segment byte data\n * @param {Number} baseTimestamp Relative reference timestamp used when adjusting frame\n *  timestamps for rollover. This value must be in 90khz clock.\n * @return {Object} Object containing start and end frame timing info of segment.\n */\nvar inspect = function(bytes, baseTimestamp) {\n  var isAacData = probe.aac.isLikelyAacData(bytes);\n\n  var result;\n\n  if (isAacData) {\n    result = inspectAac_(bytes);\n  } else {\n    result = inspectTs_(bytes);\n  }\n\n  if (!result || (!result.audio && !result.video)) {\n    return null;\n  }\n\n  adjustTimestamp_(result, baseTimestamp);\n\n  return result;\n};\n\nmodule.exports = {\n  inspect: inspect,\n  parseAudioPes_: parseAudioPes_\n};\n","/**\n * mux.js\n *\n * Copyright (c) 2016 Brightcove\n * All rights reserved.\n *\n * Utilities to detect basic properties and metadata about TS Segments.\n */\n'use strict';\n\nvar StreamTypes = require('./stream-types.js');\n\nvar parsePid = function(packet) {\n  var pid = packet[1] & 0x1f;\n  pid <<= 8;\n  pid |= packet[2];\n  return pid;\n};\n\nvar parsePayloadUnitStartIndicator = function(packet) {\n  return !!(packet[1] & 0x40);\n};\n\nvar parseAdaptionField = function(packet) {\n  var offset = 0;\n  // if an adaption field is present, its length is specified by the\n  // fifth byte of the TS packet header. The adaptation field is\n  // used to add stuffing to PES packets that don't fill a complete\n  // TS packet, and to specify some forms of timing and control data\n  // that we do not currently use.\n  if (((packet[3] & 0x30) >>> 4) > 0x01) {\n    offset += packet[4] + 1;\n  }\n  return offset;\n};\n\nvar parseType = function(packet, pmtPid) {\n  var pid = parsePid(packet);\n  if (pid === 0) {\n    return 'pat';\n  } else if (pid === pmtPid) {\n    return 'pmt';\n  } else if (pmtPid) {\n    return 'pes';\n  }\n  return null;\n};\n\nvar parsePat = function(packet) {\n  var pusi = parsePayloadUnitStartIndicator(packet);\n  var offset = 4 + parseAdaptionField(packet);\n\n  if (pusi) {\n    offset += packet[offset] + 1;\n  }\n\n  return (packet[offset + 10] & 0x1f) << 8 | packet[offset + 11];\n};\n\nvar parsePmt = function(packet) {\n  var programMapTable = {};\n  var pusi = parsePayloadUnitStartIndicator(packet);\n  var payloadOffset = 4 + parseAdaptionField(packet);\n\n  if (pusi) {\n    payloadOffset += packet[payloadOffset] + 1;\n  }\n\n  // PMTs can be sent ahead of the time when they should actually\n  // take effect. We don't believe this should ever be the case\n  // for HLS but we'll ignore \"forward\" PMT declarations if we see\n  // them. Future PMT declarations have the current_next_indicator\n  // set to zero.\n  if (!(packet[payloadOffset + 5] & 0x01)) {\n    return;\n  }\n\n  var sectionLength, tableEnd, programInfoLength;\n  // the mapping table ends at the end of the current section\n  sectionLength = (packet[payloadOffset + 1] & 0x0f) << 8 | packet[payloadOffset + 2];\n  tableEnd = 3 + sectionLength - 4;\n\n  // to determine where the table is, we have to figure out how\n  // long the program info descriptors are\n  programInfoLength = (packet[payloadOffset + 10] & 0x0f) << 8 | packet[payloadOffset + 11];\n\n  // advance the offset to the first entry in the mapping table\n  var offset = 12 + programInfoLength;\n  while (offset < tableEnd) {\n    var i = payloadOffset + offset;\n    // add an entry that maps the elementary_pid to the stream_type\n    programMapTable[(packet[i + 1] & 0x1F) << 8 | packet[i + 2]] = packet[i];\n\n    // move to the next table entry\n    // skip past the elementary stream descriptors, if present\n    offset += ((packet[i + 3] & 0x0F) << 8 | packet[i + 4]) + 5;\n  }\n  return programMapTable;\n};\n\nvar parsePesType = function(packet, programMapTable) {\n  var pid = parsePid(packet);\n  var type = programMapTable[pid];\n  switch (type) {\n    case StreamTypes.H264_STREAM_TYPE:\n      return 'video';\n    case StreamTypes.ADTS_STREAM_TYPE:\n      return 'audio';\n    case StreamTypes.METADATA_STREAM_TYPE:\n      return 'timed-metadata';\n    default:\n      return null;\n  }\n};\n\nvar parsePesTime = function(packet) {\n  var pusi = parsePayloadUnitStartIndicator(packet);\n  if (!pusi) {\n    return null;\n  }\n\n  var offset = 4 + parseAdaptionField(packet);\n\n  if (offset >= packet.byteLength) {\n    // From the H 222.0 MPEG-TS spec\n    // \"For transport stream packets carrying PES packets, stuffing is needed when there\n    //  is insufficient PES packet data to completely fill the transport stream packet\n    //  payload bytes. Stuffing is accomplished by defining an adaptation field longer than\n    //  the sum of the lengths of the data elements in it, so that the payload bytes\n    //  remaining after the adaptation field exactly accommodates the available PES packet\n    //  data.\"\n    //\n    // If the offset is >= the length of the packet, then the packet contains no data\n    // and instead is just adaption field stuffing bytes\n    return null;\n  }\n\n  var pes = null;\n  var ptsDtsFlags;\n\n  // PES packets may be annotated with a PTS value, or a PTS value\n  // and a DTS value. Determine what combination of values is\n  // available to work with.\n  ptsDtsFlags = packet[offset + 7];\n\n  // PTS and DTS are normally stored as a 33-bit number.  Javascript\n  // performs all bitwise operations on 32-bit integers but javascript\n  // supports a much greater range (52-bits) of integer using standard\n  // mathematical operations.\n  // We construct a 31-bit value using bitwise operators over the 31\n  // most significant bits and then multiply by 4 (equal to a left-shift\n  // of 2) before we add the final 2 least significant bits of the\n  // timestamp (equal to an OR.)\n  if (ptsDtsFlags & 0xC0) {\n    pes = {};\n    // the PTS and DTS are not written out directly. For information\n    // on how they are encoded, see\n    // http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\n    pes.pts = (packet[offset + 9] & 0x0E) << 27 |\n      (packet[offset + 10] & 0xFF) << 20 |\n      (packet[offset + 11] & 0xFE) << 12 |\n      (packet[offset + 12] & 0xFF) <<  5 |\n      (packet[offset + 13] & 0xFE) >>>  3;\n    pes.pts *= 4; // Left shift by 2\n    pes.pts += (packet[offset + 13] & 0x06) >>> 1; // OR by the two LSBs\n    pes.dts = pes.pts;\n    if (ptsDtsFlags & 0x40) {\n      pes.dts = (packet[offset + 14] & 0x0E) << 27 |\n        (packet[offset + 15] & 0xFF) << 20 |\n        (packet[offset + 16] & 0xFE) << 12 |\n        (packet[offset + 17] & 0xFF) << 5 |\n        (packet[offset + 18] & 0xFE) >>> 3;\n      pes.dts *= 4; // Left shift by 2\n      pes.dts += (packet[offset + 18] & 0x06) >>> 1; // OR by the two LSBs\n    }\n  }\n  return pes;\n};\n\nvar parseNalUnitType = function(type) {\n  switch (type) {\n    case 0x05:\n      return 'slice_layer_without_partitioning_rbsp_idr';\n    case 0x06:\n      return 'sei_rbsp';\n    case 0x07:\n      return 'seq_parameter_set_rbsp';\n    case 0x08:\n      return 'pic_parameter_set_rbsp';\n    case 0x09:\n      return 'access_unit_delimiter_rbsp';\n    default:\n      return null;\n  }\n};\n\nvar videoPacketContainsKeyFrame = function(packet) {\n  var offset = 4 + parseAdaptionField(packet);\n  var frameBuffer = packet.subarray(offset);\n  var frameI = 0;\n  var frameSyncPoint = 0;\n  var foundKeyFrame = false;\n  var nalType;\n\n  // advance the sync point to a NAL start, if necessary\n  for (; frameSyncPoint < frameBuffer.byteLength - 3; frameSyncPoint++) {\n    if (frameBuffer[frameSyncPoint + 2] === 1) {\n      // the sync point is properly aligned\n      frameI = frameSyncPoint + 5;\n      break;\n    }\n  }\n\n  while (frameI < frameBuffer.byteLength) {\n    // look at the current byte to determine if we've hit the end of\n    // a NAL unit boundary\n    switch (frameBuffer[frameI]) {\n    case 0:\n      // skip past non-sync sequences\n      if (frameBuffer[frameI - 1] !== 0) {\n        frameI += 2;\n        break;\n      } else if (frameBuffer[frameI - 2] !== 0) {\n        frameI++;\n        break;\n      }\n\n      if (frameSyncPoint + 3 !== frameI - 2) {\n        nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 0x1f);\n        if (nalType === 'slice_layer_without_partitioning_rbsp_idr') {\n          foundKeyFrame = true;\n        }\n      }\n\n      // drop trailing zeroes\n      do {\n        frameI++;\n      } while (frameBuffer[frameI] !== 1 && frameI < frameBuffer.length);\n      frameSyncPoint = frameI - 2;\n      frameI += 3;\n      break;\n    case 1:\n      // skip past non-sync sequences\n      if (frameBuffer[frameI - 1] !== 0 ||\n          frameBuffer[frameI - 2] !== 0) {\n        frameI += 3;\n        break;\n      }\n\n      nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 0x1f);\n      if (nalType === 'slice_layer_without_partitioning_rbsp_idr') {\n        foundKeyFrame = true;\n      }\n      frameSyncPoint = frameI - 2;\n      frameI += 3;\n      break;\n    default:\n      // the current byte isn't a one or zero, so it cannot be part\n      // of a sync sequence\n      frameI += 3;\n      break;\n    }\n  }\n  frameBuffer = frameBuffer.subarray(frameSyncPoint);\n  frameI -= frameSyncPoint;\n  frameSyncPoint = 0;\n  // parse the final nal\n  if (frameBuffer && frameBuffer.byteLength > 3) {\n    nalType = parseNalUnitType(frameBuffer[frameSyncPoint + 3] & 0x1f);\n    if (nalType === 'slice_layer_without_partitioning_rbsp_idr') {\n      foundKeyFrame = true;\n    }\n  }\n\n  return foundKeyFrame;\n};\n\n\nmodule.exports = {\n  parseType: parseType,\n  parsePat: parsePat,\n  parsePmt: parsePmt,\n  parsePayloadUnitStartIndicator: parsePayloadUnitStartIndicator,\n  parsePesType: parsePesType,\n  parsePesTime: parsePesTime,\n  videoPacketContainsKeyFrame: videoPacketContainsKeyFrame\n};\n","var Flatted = (function (Primitive, primitive) {\n\n  /*!\n   * ISC License\n   *\n   * Copyright (c) 2018, Andrea Giammarchi, @WebReflection\n   *\n   * Permission to use, copy, modify, and/or distribute this software for any\n   * purpose with or without fee is hereby granted, provided that the above\n   * copyright notice and this permission notice appear in all copies.\n   *\n   * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n   * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n   * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n   * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n   * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n   * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n   * PERFORMANCE OF THIS SOFTWARE.\n   */\n\n  var Flatted = {\n\n    parse: function parse(text, reviver) {\n      var input = JSON.parse(text, Primitives).map(primitives);\n      var value = input[0];\n      var $ = reviver || noop;\n      var tmp = typeof value === 'object' && value ?\n                  revive(input, new Set, value, $) :\n                  value;\n      return $.call({'': tmp}, '', tmp);\n    },\n\n    stringify: function stringify(value, replacer, space) {\n      for (var\n        firstRun,\n        known = new Map,\n        input = [],\n        output = [],\n        $ = replacer && typeof replacer === typeof input ?\n              function (k, v) {\n                if (k === '' || -1 < replacer.indexOf(k)) return v;\n              } :\n              (replacer || noop),\n        i = +set(known, input, $.call({'': value}, '', value)),\n        replace = function (key, value) {\n          if (firstRun) {\n            firstRun = !firstRun;\n            return value;\n            // this was invoking twice each root object\n            // return i < 1 ? value : $.call(this, key, value);\n          }\n          var after = $.call(this, key, value);\n          switch (typeof after) {\n            case 'object':\n              if (after === null) return after;\n            case primitive:\n              return known.get(after) || set(known, input, after);\n          }\n          return after;\n        };\n        i < input.length; i++\n      ) {\n        firstRun = true;\n        output[i] = JSON.stringify(input[i], replace, space);\n      }\n      return '[' + output.join(',') + ']';\n    }\n\n  };\n\n  return Flatted;\n\n  function noop(key, value) {\n    return value;\n  }\n\n  function revive(input, parsed, output, $) {\n    return Object.keys(output).reduce(\n      function (output, key) {\n        var value = output[key];\n        if (value instanceof Primitive) {\n          var tmp = input[value];\n          if (typeof tmp === 'object' && !parsed.has(tmp)) {\n            parsed.add(tmp);\n            output[key] = $.call(output, key, revive(input, parsed, tmp, $));\n          } else {\n            output[key] = $.call(output, key, tmp);\n          }\n        } else\n          output[key] = $.call(output, key, value);\n        return output;\n      },\n      output\n    );\n  }\n\n  function set(known, input, value) {\n    var index = Primitive(input.push(value) - 1);\n    known.set(value, index);\n    return index;\n  }\n\n  // the two kinds of primitives\n  //  1. the real one\n  //  2. the wrapped one\n\n  function primitives(value) {\n    return value instanceof Primitive ? Primitive(value) : value;\n  }\n\n  function Primitives(key, value) {\n    return typeof value === primitive ? new Primitive(value) : value;\n  }\n\n}(String, 'string'));\nexport default Flatted;\nexport const parse = Flatted.parse;\nexport const stringify = Flatted.stringify;\n","// @flow\n\n/* eslint-disable no-console */\n\nimport superagent from 'superagent';\nimport { stringify } from 'flatted';\n\nconst log = (name:string, level:string, value:any, description?: string) => {\n  let color = 'gray';\n  switch (level) {\n    case 'debug':\n      color = 'blue';\n      break;\n    case 'info':\n      color = 'green';\n      break;\n    case 'warn':\n      color = 'orange';\n      break;\n    case 'error':\n      color = 'red';\n      break;\n    default:\n      throw new Error(`Unknown level ${level}`);\n  }\n  if (typeof value === 'string') {\n    console.log(`%c${name}: %c${value}`, `color:${color}; font-weight: bold`, `color:${color}`);\n    // superagent.post('/api/1.0/log').set('Content-Type', 'application/json').send({ name, level, value, description }).end((error) => {\n    //  if (error) {\n    //    console.error('Unable to post to logging API');\n    //    console.error(error);\n    //  }\n    // });\n  } else {\n    const sanitizedValue = JSON.parse(stringify(value));\n    JSON.stringify(sanitizedValue, null, 2).split('\\n').forEach((line) => {\n      console.log(`%c${name}: %c${line}`, `color:${color}; font-weight: bold`, `color:${color}`);\n    });\n    // superagent.post('/api/1.0/log').set('Content-Type', 'application/json').send({ name, level, value: sanitizedValue, description }).end((error) => {\n    //  if (error) {\n    //    console.error('Unable to post to logging API');\n    //    console.error(error);\n    //  }\n    // });\n  }\n  if (typeof description === 'string') {\n    console.log(`%c\\t${description}`, 'color:gray');\n  }\n};\n\nexport default (name: string) => ({\n  debug: (value:any, description?: string) => {\n    log(name, 'debug', value, description);\n  },\n  info: (value:any, description?: string) => {\n    log(name, 'info', value, description);\n  },\n  warn: (value:any, description?: string) => {\n    log(name, 'warn', value, description);\n  },\n  error: (value:any, description?: string) => {\n    log(name, 'error', value, description);\n  },\n});\n","// @flow\n\n/* eslint-disable no-unused-vars */\n\nimport makeLogger from './logger';\n\nconst Route = require('route-parser');\nconst Client = require('../../client');\n\nconst reconnectAttempt = 0;\nconst totalReconnectAttempts = 0;\nlet reconnectAttemptResetTimeout;\nconst recoveryTimeout = null;\n\nconst element = document.querySelector('video');\n\nif (!element) {\n  throw new Error('Video element does not exist');\n}\nconst windowLogger = makeLogger('Window');\nconst videoLogger = makeLogger('Video Element');\nconst mediaSourceLogger = makeLogger('Media Source');\nconst sourceBufferLogger = makeLogger('Source Buffer');\nconst websocketLogger = makeLogger('WebSocket');\n\nwindow.addEventListener('unhandledrejection', (event) => {\n  if (event && event.error) {\n    if (event.error.stack) {\n      windowLogger.error(event.error.stack);\n    } else if (event.error.message) {\n      windowLogger.error(event.error.message);\n    } else {\n      windowLogger.error('Unhandled rejection');\n    }\n  } else {\n    windowLogger.error('Unhandled rejection');\n  }\n});\n\nwindow.addEventListener('error', (event) => {\n  if (event && event.error) {\n    if (event.error.stack) {\n      windowLogger.error(event.error.stack);\n    } else if (event.error.message) {\n      windowLogger.error(event.error.message);\n    } else {\n      windowLogger.error('Uncaught error');\n    }\n  } else {\n    windowLogger.error('Uncaught error');\n  }\n});\n\nelement.addEventListener('resize', (event) => {\n  videoLogger.info('abort', 'Sent when playback is aborted; for example, if the media is playing and is restarted from the beginning, this event is sent');\n});\nelement.addEventListener('canplay', (event) => {\n  videoLogger.info('canplay', 'Sent when enough data is available that the media can be played, at least for a couple of frames.  This corresponds to the HAVE_ENOUGH_DATA readyState');\n});\nelement.addEventListener('canplaythrough', (event) => {\n  videoLogger.info('canplaythrough', 'Sent when the ready state changes to CAN_PLAY_THROUGH, indicating that the entire media can be played without interruption, assuming the download rate remains at least at the current level. It will also be fired when playback is toggled between paused and playing. Note: Manually setting the currentTime will eventually fire a canplaythrough event in firefox. Other browsers might not fire this event');\n});\nelement.addEventListener('durationchange', (event) => {\n  videoLogger.info('durationchange', 'The metadata has loaded or changed, indicating a change in duration of the media.  This is sent, for example, when the media has loaded enough that the duration is known');\n});\nelement.addEventListener('emptied', (event) => {\n  videoLogger.info('emptied', 'The media has become empty; for example, this event is sent if the media has already been loaded (or partially loaded), and the load() method is called to reload it');\n});\nelement.addEventListener('encrypted', (event) => {\n  videoLogger.info('encrypted', ' The user agent has encountered initialization data in the media data');\n});\nelement.addEventListener('ended', (event) => {\n  videoLogger.info('ended', 'Sent when playback completes');\n});\nelement.addEventListener('error', (event:ProgressEvent) => {\n  const mediaError = element.error;\n  const message = mediaError && mediaError.message ? mediaError.message : null;\n  if (mediaError && message) {\n    videoLogger.error(`${mediaError.code}: ${message}`);\n  } else {\n    videoLogger.error('error', 'Sent when an error occurs.  The element\\'s error attribute contains more information. See HTMLMediaElement.error for details');\n    if (event) {\n      videoLogger.error(event);\n    }\n  }\n});\nelement.addEventListener('interruptbegin', (event) => {\n  videoLogger.info('interruptbegin', 'Sent when audio playing on a Firefox OS device is interrupted, either because the app playing the audio is sent to the background, or audio in a higher priority audio channel begins to play. See Using the AudioChannels API for more details');\n});\nelement.addEventListener('interruptend', (event) => {\n  videoLogger.info('interruptend', 'Sent when previously interrupted audio on a Firefox OS device commences playing again  when the interruption ends. This is when the associated app comes back to the foreground, or when the higher priority audio finished playing. See Using the AudioChannels API for more details');\n});\nelement.addEventListener('loadeddata', (event) => {\n  videoLogger.info('loadeddata', 'The first frame of the media has finished loading');\n});\nelement.addEventListener('loadedmetadata', (event) => {\n  videoLogger.info('loadedmetadata', 'The media\\'s metadata has finished loading; all attributes now contain as much useful information as they\\'re going to');\n});\nelement.addEventListener('loadstart', (event:ProgressEvent) => {\n  videoLogger.info('loadstart', 'Sent when loading of the media begins');\n});\nelement.addEventListener('mozaudioavailable', (event) => {\n  videoLogger.info('mozaudioavailable', 'Sent when an audio buffer is provided to the audio layer for processing; the buffer contains raw audio samples that may or may not already have been played by the time you receive the event');\n});\nelement.addEventListener('pause', (event) => {\n  videoLogger.info('pause', 'Sent when the playback state is changed to paused (paused property is true)');\n});\nelement.addEventListener('play', (event) => {\n  videoLogger.info('play', 'Sent when the playback state is no longer paused, as a result of the play method, or the autoplay attribute');\n});\nelement.addEventListener('playing', (event) => {\n  videoLogger.info('playing', 'Sent when the media has enough data to start playing, after the play event, but also when recovering from being stalled, when looping media restarts, and after seeked, if it was playing before seeking');\n});\nelement.addEventListener('ratechange', (event) => {\n  videoLogger.info('ratechange', 'Sent when the playback speed changes');\n});\nelement.addEventListener('seeked', (event) => {\n  videoLogger.info('seeked', 'Sent when a seek operation completes');\n});\nelement.addEventListener('seeking', (event) => {\n  videoLogger.info('seeking', 'Sent when a seek operation begins');\n});\nelement.addEventListener('stalled', (event) => {\n  videoLogger.info('stalled', 'Sent when the user agent is trying to fetch media data, but data is unexpectedly not forthcoming');\n});\nelement.addEventListener('suspend', (event) => {\n  videoLogger.info('suspend', 'Sent when loading of the media is suspended; this may happen either because the download has completed or because it has been paused for any other reason');\n});\nelement.addEventListener('volumechange', (event) => {\n  videoLogger.info('volumechange', 'Sent when the audio volume changes (both when the volume is set and when the muted attribute is changed)');\n});\nelement.addEventListener('waiting', (event) => {\n  videoLogger.info('waiting', 'Sent when the requested operation (such as playback) is delayed pending the completion of another operation (such as a seek)');\n});\n\nconst logevent:EventListener = function (event) {\n  console.log(event.type);\n};\n\nconst route = new Route('/stream/:streamUrl/(:path)');\nconst parsedRoute = route.match(window.location.pathname);\n\nasync function initialize() {\n  const address = `ws://127.0.0.1:61340/api/1.0/websocket/stream/${encodeURIComponent(parsedRoute.streamUrl)}`;\n  const client = new Client();\n  const mediaSource = new MediaSource();\n  mediaSource.addEventListener('sourceopen', (event) => {\n    mediaSourceLogger.info('sourceopen');\n  });\n  mediaSource.addEventListener('sourceended', (event) => {\n    mediaSourceLogger.info('sourceended');\n  });\n  mediaSource.addEventListener('sourceclose', (event) => {\n    mediaSourceLogger.info('sourceclose');\n  });\n  mediaSource.addEventListener('updatestart', (event) => {\n    mediaSourceLogger.info('updatestart');\n  });\n  mediaSource.addEventListener('update', (event) => {\n    mediaSourceLogger.info('update');\n  });\n  mediaSource.addEventListener('updateend', (event) => {\n    mediaSourceLogger.info('updateend');\n  });\n  mediaSource.addEventListener('error', (event) => {\n    mediaSourceLogger.info('error');\n  });\n  mediaSource.addEventListener('abort', (event) => {\n    mediaSourceLogger.info('abort');\n  });\n  mediaSource.addEventListener('addsourcebuffer', (event) => {\n    mediaSourceLogger.info('addsourcebuffer');\n  });\n  mediaSource.addEventListener('removesourcebuffer', (event) => {\n    mediaSourceLogger.info('removesourcebuffer');\n  });\n  element.src = URL.createObjectURL(mediaSource);\n  await new Promise((resolve) => {\n    const handle = () => {\n      mediaSource.removeEventListener('sourceopen', handle);\n      resolve();\n    };\n    mediaSource.addEventListener('sourceopen', handle);\n  });\n  const queue = [];\n  const buffer = mediaSource.addSourceBuffer('video/mp4; codecs=\"avc1.64001f, mp4a.40.5\"');\n  buffer.addEventListener('updateend', async () => {\n    console.log(`updateend: ${mediaSource.readyState}, queue: ${queue.length}`);\n    if (queue.length > 0 && !buffer.updating) {\n      buffer.appendBuffer(queue.shift());\n    }\n  });\n  buffer.addEventListener('sourceopen', (event) => {\n    sourceBufferLogger.info('sourceopen');\n  });\n  buffer.addEventListener('sourceended', (event) => {\n    sourceBufferLogger.info('sourceended');\n  });\n  buffer.addEventListener('sourceclose', (event) => {\n    sourceBufferLogger.info('sourceclose');\n  });\n  /*\n  buffer.addEventListener('updatestart', (event) => {\n    sourceBufferLogger.info('updatestart');\n  });\n  buffer.addEventListener('update', (event) => {\n    sourceBufferLogger.info('update');\n  });\n  buffer.addEventListener('updateend', (event) => {\n    sourceBufferLogger.info('updateend');\n  });\n  */\n  buffer.addEventListener('error', (event) => {\n    sourceBufferLogger.info('error');\n  });\n  buffer.addEventListener('abort', (event) => {\n    sourceBufferLogger.info('abort');\n  });\n  buffer.addEventListener('addsourcebuffer', (event) => {\n    sourceBufferLogger.info('addsourcebuffer');\n  });\n  buffer.addEventListener('removesourcebuffer', (event) => {\n    sourceBufferLogger.info('removesourcebuffer');\n  });\n  client.on('initSegment', (data) => {\n    buffer.appendBuffer(data);\n  });\n  client.on('caption', (text) => {\n    console.log('caption', text);\n  });\n  client.on('data', (data) => {\n    if (queue.length > 0 || buffer.updating) {\n      queue.push(data);\n    } else {\n      buffer.appendBuffer(data);\n    }\n  });\n  client.on('error', (error) => {\n    websocketLogger(error);\n  });\n  await client.open(address);\n}\n\ninitialize();\n\n"],"sourceRoot":""}